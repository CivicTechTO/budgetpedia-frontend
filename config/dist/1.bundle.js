(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{1137:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./forked_modules/react-google-charts/DEFAULT_CHART_COLORS.js\nvar DEFAULT_CHART_COLORS = __webpack_require__(1262);\nvar DEFAULT_CHART_COLORS_default = /*#__PURE__*/__webpack_require__.n(DEFAULT_CHART_COLORS);\n\n// EXTERNAL MODULE: ./node_modules/scriptjs/dist/script.js\nvar script = __webpack_require__(225);\nvar script_default = /*#__PURE__*/__webpack_require__.n(script);\n\n// CONCATENATED MODULE: ./forked_modules/react-google-charts/GoogleChartLoader.js\n//GoogleChartLoader Singleton\n\n// Based on http://blog.arkency.com/2014/09/react-dot-js-and-google-charts/\n// import Promise from 'bluebird';\n\nconst debug = __webpack_require__(1261)('react-google-charts:GoogleChartLoader');\n\nconst googleChartLoader = {\n\n  isLoaded : false,\n  isLoading: false,\n  initPromise: {},\n  init(packages, version) {\n    debug('init', packages, version);\n\n    if (this.isLoading || this.isLoaded) {\n      return this.initPromise;\n    }\n    this.isLoading = true;\n    this.initPromise =  new Promise((resolve, reject)=> {\n      if(typeof window !== 'undefined') {\n        script_default()(\"https://www.gstatic.com/charts/loader.js\", () => {\n\n          google.charts.load(version || 'current', {packages: packages || ['corechart']});\n          google.charts.setOnLoadCallback(() => {\n            debug('Chart Loaded');\n            this.isLoaded = true;\n            this.isLoading = false;\n            resolve();\n          });\n        });\n      }\n      else {\n        resolve();\n      }\n    });\n    return this.initPromise;\n  }\n}\n\n/* harmony default export */ var GoogleChartLoader = (googleChartLoader);\n\n// CONCATENATED MODULE: ./forked_modules/react-google-charts/Chart.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chart\", function() { return Chart_Chart; });\n\n// import Promise from 'bluebird';\n\n// const debug = require('debug')('react-google-charts:Chart');\n\n\n\nlet uniqueID = 0;\n\nconst generateUniqueID = () => {\n  uniqueID++;\n  return \"reactgooglegraph-\" + uniqueID;\n}\n\nconst googleErrorHandler = (id, message) => {\n  console.error(\"Google Charts encountered an error : \")\n  console.error(`Error ID : ${id}`);\n  console.error(`Error MESSAGE : ${message}`);\n}\n\nclass Chart_Chart extends react_default.a.Component {\n  constructor(props) {\n    if (false) {}\n    // debug('constructor', props);\n    super(props);\n    this.state = {graphID: props.graph_id || generateUniqueID()};\n    this.chart = null;\n    this.wrapper = null;\n    this.hidden_columns = {};\n    this.dataTable = [];\n  }\n  componentDidMount(){\n    // debug('componentDidMount');\n    GoogleChartLoader.init(this.props.chartPackages, this.props.chartVersion).then((asd)=>{\n      // console.log('drawchart from did mount')\n      this.drawChart()\n    });\n  }\n  componentWillUnmount() {\n      try {\n          google.visualization.events.removeAllListeners(this.wrapper);\n      }\n      catch(err) {\n        console.error(\"Error removing events, error : \", err);\n      }\n  }\n  componentDidUpdate(){\n    // debug('componentDidUpdate');\n    if (GoogleChartLoader.isLoading){\n      GoogleChartLoader.initPromise.then(()=>{\n        // console.log('calling drawchart from did update PROMISE')\n        this.drawChart.bind(this)();\n\n      })\n\t\t}\n    else if (GoogleChartLoader.isLoaded) {\n\n      // console.log('calling drawchart from did update ISLOADED')\n      this.drawChart.bind(this)();\n\n    } else {\n        // console.log('drawchart from did update/loading')\n      // console.log('NOT calling drawChart from componentDidUpdate')\n    }\n  }\n  buildDataTableFromProps() {\n    // debug('buildDataTableFromProps', this.props);\n    if (this.props.diffdata) {\n\n        let diffdata = this.props.diffdata\n        let oldData = google.visualization.arrayToDataTable(diffdata.old)\n        let newData = google.visualization.arrayToDataTable(diffdata.new)\n        // must take computeDiff from prototypes since not available with charts early in process\n        let computeDiff = google.visualization[this.props.chartType].prototype.computeDiff\n        let chartDiff = computeDiff(oldData,newData)\n\n        return chartDiff\n\n    }\n\n    if (this.props.data === null && this.props.rows.length === 0){\n      throw new Error(\"Can't build DataTable from rows and columns: rows array in props is empty\");\n    }\n    else if (this.props.data === null && this.props.columns.length === 0) {\n      throw new Error(\"Can't build DataTable from rows and columns: columns array in props is empty\");\n    }\n    if (this.props.data !== null) {\n      try {\n          this.wrapper.setDataTable(this.props.data);\n          let dataTable = this.wrapper.getDataTable();\n          return dataTable;\n      }\n      catch(err) {\n        console.log('Failed to set DataTable from data props ! ', err);\n        throw new Error('Failed to set DataTable from data props ! ', err);\n      }\n    }\n\n    let dataTable = new google.visualization.DataTable();\n    this.props.columns.forEach((column)=>{\n      dataTable.addColumn(column);\n    });\n    dataTable.addRows(this.props.rows);\n    return dataTable;\n  }\n  updateDataTable() {\n    // debug(\"updateDataTable\");\n    google.visualization.errors.removeAll(document.getElementById(this.wrapper.getContainerId()));\n    this.dataTable.removeRows(0, this.dataTable.getNumberOfRows());\n    this.dataTable.removeColumns(0, this.dataTable.getNumberOfColumns());\n    this.dataTable = this.buildDataTableFromProps.bind(this)();\n    return this.dataTable;\n  }\n  //DEPRECATED AND NOT USED\n  getDataTableFromProps() {\n    // debug(\"getDataTableFromProps\");\n    return this.props.data !== null ? this.props.data : this.buildDataTableFromProps.bind(this)();\n  }\n  drawChart() {\n    // console.log(\"drawChart\", this);\n    if (!this.wrapper) {\n      let chartConfig = {\n        chartType: this.props.chartType,\n        options: this.props.options,\n        containerId: this.state.graphID\n      };\n      this.wrapper = new google.visualization.ChartWrapper(chartConfig);\n      // console.log('newly created wrapper', this.wrapper)\n      google.visualization.events.addOneTimeListener(this.wrapper, 'ready', ()=>{\n        this.chart = this.wrapper.getChart();\n        // console.log('ready after create',this.chart)\n        this.listenToChartEvents.bind(this)();\n        this.addChartActions.bind(this)();\n      });\n      this.dataTable = this.buildDataTableFromProps.bind(this)();\n      this.wrapper.setDataTable(this.dataTable)\n      // this.wrapper.draw();\n    }\n    else {\n      if (this.wrapper.getChartType() != this.props.chartType) {\n        google.visualization.events.removeAllListeners(this.wrapper)\n        this.wrapper.setChartType(this.props.chartType)\n        // console.log('newChartType BEFORE ready',this.wrapper.getChartType(),this.wrapper.getChart())\n        var self = this\n        google.visualization.events.addOneTimeListener(this.wrapper, 'ready', () => {\n          this.chart = this.wrapper.getChart();\n          this.listenToChartEvents.bind(this)();\n          this.addChartActions.bind(this)();\n        });\n        self.chart = self.wrapper.getChart();\n        self.updateDataTable.bind(self)();\n        self.wrapper.setDataTable(self.dataTable);\n        self.wrapper.setOptions(self.props.options)\n        // self.wrapper.draw();\n      } else {\n        this.updateDataTable.bind(this)();\n        this.wrapper.setDataTable(this.dataTable);\n        this.wrapper.setOptions(this.props.options)\n        // this.wrapper.draw();\n      }\n      // issue: this draw clears selection\n    }\n    this.wrapper.draw();\n  }\n\n  addChartActions() {\n    // debug('addChartActions', this.props.chartActions);\n    if (this.props.chartActions === null) {\n      return;\n    }\n    this.chart.setAction({\n      id: this.props.chartActions.id,\n      text: this.props.chartActions.text,\n      action: this.props.chartActions.action.bind(this, this.chart)\n    })\n\n  }\n  listenToChartEvents() {\n    // debug('listenToChartEvents', this.props.legend_toggle, this.props.chartEvents);\n    // console.log('listenToChartEvents')\n    if (this.props.legend_toggle) {\n      google.visualization.events.addListener(this.wrapper, 'select', this.onSelectToggle.bind(this));\n    }\n    this.props.chartEvents.forEach((chartEvent)=>{\n      if (chartEvent.eventName === 'ready') {\n        // console.log('ready event')\n        chartEvent.callback(this);\n      }\n      else {\n        ((chartEvent)=>{\n            google.visualization.events.addListener(this.chart, chartEvent.eventName, (e)=>{\n              // console.log('chart event', this.chart)\n              chartEvent.callback(this, e);\n            });\n        })(chartEvent);\n      }\n      });\n  }\n  onSelectToggle() {\n    // debug('onSelectToggle');\n    let selection = this.chart.getSelection();\n    if (selection.length > 0) {\n      if (selection[0].row == null) {\n        let column = selection[0].column;\n        this.togglePoints.bind(this)(column);\n      }\n    }\n  }\n  getColumnColor(columnIndex) {\n    if (this.props.options.colors) {\n      if (this.props.options.colors[columnIndex]) {\n        return this.props.options.colors[columnIndex];\n      }\n    }\n    else {\n      if (typeof DEFAULT_CHART_COLORS_default.a[columnIndex] !== undefined) {\n        return DEFAULT_CHART_COLORS_default.a[columnIndex];\n      }\n      else {\n        return DEFAULT_CHART_COLORS_default.a[0];\n      }\n    }\n  }\n\n  buildColumnFromSourceData(columnIndex) {\n    // debug('buildColumnFromSourceData', columnIndex);\n    return {\n      label: this.dataTable.getColumnLabel(columnIndex),\n      type: this.dataTable.getColumnType(columnIndex),\n      sourceColumn: columnIndex\n    };\n  }\n\n  buildEmptyColumnFromSourceData(columnIndex) {\n    // debug('buildEmptyColumnFromSourceData', columnIndex);\n    return {\n      label: this.dataTable.getColumnLabel(columnIndex),\n      type: this.dataTable.getColumnType(columnIndex),\n      calc: function () {\n        return null;\n      }\n    };\n  }\n  addEmptyColumnTo(columns, columnIndex) {\n    // debug('addEmptyColumnTo', columns, columnIndex);\n    let emptyColumn =  this.buildEmptyColumnFromSourceData(columnIndex);\n    columns.push(emptyColumn);\n  }\n\n  hideColumn(colors, columnIndex) {\n    // debug('hideColumn', colors, columnIndex);\n    if (!this.isHidden(columnIndex)) {\n      this.hidden_columns[columnIndex] = { color : this.getColumnColor(columnIndex-1) };\n    }\n    colors.push('#CCCCCC');\n  }\n  addSourceColumnTo(columns, columnIndex) {\n    // debug('addSourceColumnTo', columns, columnIndex);\n    let sourceColumn = this.buildColumnFromSourceData(columnIndex);\n    columns.push(sourceColumn);\n  }\n  isHidden(columnIndex) {\n    return this.hidden_columns[columnIndex] !== undefined\n  }\n  restoreColorTo(colors, columnIndex) {\n    // debug('restoreColorTo', colors, columnIndex);\n    // debug('hidden_columns',this.hidden_columns);\n    let previousColor;\n    if (this.isHidden(columnIndex)) {\n      previousColor = this.hidden_columns[columnIndex].color;\n      delete this.hidden_columns[columnIndex];\n    }\n    else {\n      previousColor = this.getColumnColor(columnIndex-1)\n    }\n    if (columnIndex !== 0) {\n\t\t\tcolors.push(previousColor);\n\t\t}\n  }\n\n  togglePoints(column) {\n    // debug('togglePoints', column);\n    let view = new google.visualization.DataView(this.wrapper.getDataTable());\n    let columnCount = view.getNumberOfColumns();\n    let colors = [];\n    let columns = [];\n    for (var i = 0; i < columnCount; i++) {\n      // If user clicked on legend\n      if (i === 0) {\n        this.addSourceColumnTo.bind(this)(columns, i);\n      }\n      else if (i === column ) {\n        if (this.isHidden(i)) {\n          this.addSourceColumnTo.bind(this)(columns, i);\n          this.restoreColorTo.bind(this)(colors, i);\n        }\n        else {\n          this.addEmptyColumnTo.bind(this)(columns,i);\n          this.hideColumn.bind(this)(colors, i);\n        }\n      }\n      else {\n        if (this.isHidden(i)) {\n          this.addEmptyColumnTo.bind(this)(columns,i);\n          this.hideColumn.bind(this)(colors, i);\n        }\n        else {\n          this.addSourceColumnTo.bind(this)(columns, i);\n          this.restoreColorTo.bind(this)(colors, i);\n        }\n      }\n    }\n    view.setColumns(columns);\n    this.props.options.colors = colors;\n    this.chart.draw(view, this.props.options);\n  }\n\n  render() { \n    // debug('render', this.props, this.state);\n    let height = this.props.height || this.props.options.height\n    let width = this.props.width || this.props.options.width\n\n    let divStyle= {height, width: width}\n    return (\n       react_default.a.createElement('div', {id:this.state.graphID, style:divStyle},\"Rendering Chart\")\n      )\n  }\n}\n\nChart_Chart.defaultProps = {\n  chartType : 'LineChart',\n  rows: [],\n  columns: [],\n  options: {\n    chart: {\n      title: 'Chart Title',\n      subtitle: 'Subtitle'\n    },\n    hAxis: {title: 'X Label'},\n    vAxis: {title: 'Y Label'},\n    width: '400px',\n    height: '300px'\n  },\n  width: '400px',\n  height: '300px',\n  chartEvents : [],\n  chartActions : null,\n  data: null,\n  onSelect: null,\n  legend_toggle: false\n}\n\n\n\n\n//# sourceURL=webpack:///./forked_modules/react-google-charts/Chart.js_+_1_modules?")},1262:function(module,exports){eval("//Taken from http://there4development.com/blog/2012/05/02/google-chart-color-list/\n\nmodule.exports = [\n\t'#3366CC',\n\t'#DC3912',\n\t'#FF9900',\n\t'#109618',\n\t'#990099',\n\t'#3B3EAC',\n\t'#0099C6',\n\t'#DD4477',\n\t'#66AA00',\n\t'#B82E2E',\n\t'#316395',\n\t'#994499',\n\t'#22AA99',\n\t'#AAAA11',\n\t'#6633CC',\n\t'#E67300',\n\t'#8B0707',\n\t'#329262',\n\t'#5574A6',\n\t'#3B3EAC'\n];\n\n//# sourceURL=webpack:///./forked_modules/react-google-charts/DEFAULT_CHART_COLORS.js?")},1274:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 23 modules\nvar es = __webpack_require__(55);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Card/index.js\nvar Card = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/FontIcon/index.js\nvar FontIcon = __webpack_require__(66);\nvar FontIcon_default = /*#__PURE__*/__webpack_require__.n(FontIcon);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/IconButton/index.js\nvar IconButton = __webpack_require__(97);\nvar IconButton_default = /*#__PURE__*/__webpack_require__.n(IconButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Dialog/index.js\nvar Dialog = __webpack_require__(1134);\nvar Dialog_default = /*#__PURE__*/__webpack_require__.n(Dialog);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/FloatingActionButton/index.js\nvar FloatingActionButton = __webpack_require__(213);\nvar FloatingActionButton_default = /*#__PURE__*/__webpack_require__.n(FloatingActionButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/MenuItem/index.js\nvar MenuItem = __webpack_require__(223);\nvar MenuItem_default = /*#__PURE__*/__webpack_require__.n(MenuItem);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/RaisedButton/index.js\nvar RaisedButton = __webpack_require__(1136);\nvar RaisedButton_default = /*#__PURE__*/__webpack_require__.n(RaisedButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/svg-icons/content/add.js\nvar add = __webpack_require__(1271);\nvar add_default = /*#__PURE__*/__webpack_require__.n(add);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/svg-icons/content/remove.js\nvar remove = __webpack_require__(1270);\nvar remove_default = /*#__PURE__*/__webpack_require__.n(remove);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/DropDownMenu/index.js\nvar DropDownMenu = __webpack_require__(1135);\nvar DropDownMenu_default = /*#__PURE__*/__webpack_require__.n(DropDownMenu);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Divider/index.js\nvar Divider = __webpack_require__(226);\nvar Divider_default = /*#__PURE__*/__webpack_require__.n(Divider);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/LinearProgress/index.js\nvar LinearProgress = __webpack_require__(1264);\nvar LinearProgress_default = /*#__PURE__*/__webpack_require__.n(LinearProgress);\n\n// EXTERNAL MODULE: ./node_modules/react-redux-toastr/lib/index.js\nvar lib = __webpack_require__(119);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Subheader/index.js\nvar Subheader = __webpack_require__(538);\nvar Subheader_default = /*#__PURE__*/__webpack_require__.n(Subheader);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Snackbar/index.js\nvar Snackbar = __webpack_require__(1258);\nvar Snackbar_default = /*#__PURE__*/__webpack_require__.n(Snackbar);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Toggle/index.js\nvar Toggle = __webpack_require__(1251);\nvar Toggle_default = /*#__PURE__*/__webpack_require__.n(Toggle);\n\n// EXTERNAL MODULE: ./node_modules/react-animations/lib/index.js\nvar react_animations_lib = __webpack_require__(1142);\n\n// EXTERNAL MODULE: ./node_modules/radium/es/index.js + 22 modules\nvar radium_es = __webpack_require__(1129);\n\n// EXTERNAL MODULE: ./node_modules/radium/es/keyframes.js\nvar keyframes = __webpack_require__(494);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/modules/onchartcomponentselection.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// onchartcomponentselection.tsx\n// ------------------------[ UPDATE CHART BY SELECTION ]-----------------\n// response to user selection of a chart component (such as a column )\n// called by chart callback\n// on selection, makes a child with the same datasetSpecs offset\nlet applyChartComponentSelection = (budgetBranch, nodeIndex, cellIndex, chartSelectionData) => {\n    // console.log(\'chartSelection data\',chartSelectionData)\n    let { nodes: branchNodes, uid: branchuid } = budgetBranch;\n    let budgetNode = branchNodes[nodeIndex];\n    // budgetnode is undefined on final expendigure chart\n    let budgetCell = budgetNode.cells[cellIndex];\n    if (!budgetCell) {\n        console.error(\'System Error: budgetNode, faulty cellIndex in applyChartComponentSelection\', budgetNode, cellIndex);\n        throw Error(\'faulty cellIndex in applyChartComponentSelection\');\n    }\n    // unpack chartSelectionData\n    let selection = chartSelectionData.selection[0];\n    // console.log(\'budgetCell googlecharttype\',budgetCell.googleChartType, cellIndex)\n    let logicalselectionrow = null;\n    if (selection) {\n        // TODO: understand this: setting column to null avoids bugs\n        // when chart animation is present\n        // selection.column = null\n        switch (budgetCell.googleChartType) {\n            case "ColumnChart":\n                {\n                    if (budgetCell.explorerChartCode == "DiffColumnChart") {\n                        logicalselectionrow = Math.floor(selection.row / 2);\n                    } else {\n                        logicalselectionrow = selection.row;\n                    }\n                    break;\n                }\n            case "AreaChart":\n            case "LineChart":\n                logicalselectionrow = selection.column - 1;\n                if (budgetCell.chartSelection == logicalselectionrow) {\n                    logicalselectionrow = null;\n                }\n                // TODO: save row and column separately and allow\n                // mapping among chart types\n                // chartSelectionData.selection[0].row = null\n                break;\n            // TODO: find out why the piechart column null causes fail\n            // case "PieChart": \n            //     chartSelectionData.selection[0].column = null\n            default:\n                logicalselectionrow = selection.row;\n                break;\n        }\n        // } else {\n        //     logicalselectionrow = null\n        //     // return\n    }\n    // 1. stop if chart is not not drillable\n    if (budgetCell.nodeDataseriesName == \'CommonDimension\') {\n        return;\n    }\n    budgetCell.chartSelection = logicalselectionrow; // selection? chartSelectionData.selection: null\n    // console.log(\'setting chartSelection\', budgetCell.chartSelection, logicalselectionrow, selection)\n    // 2. remove any nodes to be replaced or abandoned\n    let removed = branchNodes.splice(nodeIndex + 1); // remove subsequent charts\n    let removeditems = removed.map((item, index) => {\n        return { nodeuid: item.uid, cellList: item.cellDeclarationList, index };\n    });\n    let priorCellSettings = null;\n    let priorNodeSettings = null;\n    if (removeditems.length > 0) {\n        // console.log(\'removed,removeditems\',removed,removeditems)\n        // TODO: review this for directness and efficiency\n        let removednode = removed[removeditems[0].index];\n        let priorCell = removednode.cells[removednode.nodeDeclaration.cellIndex];\n        if (priorCell) {\n            let chartConfigs = Object.assign({}, priorCell.cellDeclaration.chartConfigs);\n            let yearScope = priorCell.cellDeclaration.yearScope;\n            priorCellSettings = {\n                chartConfigs,\n                yearScope\n            };\n            priorNodeSettings = {\n                yearSelections: Object.assign({}, removednode.nodeDeclaration.yearSelections),\n                cellIndex: removednode.nodeDeclaration.cellIndex\n            };\n        } else {\n            console.log(\'error: did not find priorCell for node\', removednode);\n        }\n        let { removeNodeDeclarations } = budgetBranch.actions;\n        removeNodeDeclarations(removeditems);\n    }\n    let { updateCellChartSelection } = budgetNode.actions;\n    // console.log(\'logicalselectionrow\', logicalselectionrow)\n    updateCellChartSelection(budgetCell.uid, logicalselectionrow); // chartSelectionData.selection)\n    if (logicalselectionrow === null) {\n        // deselected\n        budgetCell.chartSelection = null;\n        return;\n    }\n    // 3. otherwise create new child node\n    budgetCell.chartSelection = logicalselectionrow; // chartSelectionData.selection\n    let childprops = {\n        selectionrow: logicalselectionrow,\n        nodeIndex,\n        cellIndex: parseInt(cellIndex),\n        priorCellSettings,\n        priorNodeSettings\n    };\n    budgetBranch.createChildNodeDeclaration(childprops);\n};\nconst onChartComponentSelection = budgetBranch => nodeIndex => cellIndex => chartSelectionData => {\n    // console.log(\'chart selection data\',chartSelectionData)\n    applyChartComponentSelection(budgetBranch, nodeIndex, cellIndex, chartSelectionData);\n};\n// CONCATENATED MODULE: ./ts/addons/explorer/modules/getbudgetnode.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// getnodedatasets.tsx\n/*\n    a node consists of\n    - Index\n    - NamingConfigRef\n    - years\n    - Components\n    - CommonDimension\n    - SortedComponents\n    - SortedCommonDimension\n*/\nlet getBudgetNode = (node, path) => {\n    let components = node.Components;\n    for (let index of path) {\n        if (!components) {\n            return null;\n        }\n        node = components[index];\n        if (!node) {\n            // can happen legitimately switching from one aspect to another\n            return null;\n        }\n        components = node.Components;\n    }\n    return node;\n};\n/* harmony default export */ var getbudgetnode = (getBudgetNode);\n// EXTERNAL MODULE: ./node_modules/material-ui/Tabs/index.js\nvar Tabs = __webpack_require__(1172);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/SvgIcon/index.js\nvar SvgIcon = __webpack_require__(44);\nvar SvgIcon_default = /*#__PURE__*/__webpack_require__.n(SvgIcon);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/constants.tsx\nvar constants = __webpack_require__(152);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/actions.tsx + 63 modules\nvar explorer_actions = __webpack_require__(7);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/modules/utilities.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// utilities.tsx\n/* requires component.lastactiongeneration property to be present\n    component.waitafteraction is optional if explicit wait is desired\n    - the puprose of this utility is to filter out unneeded updates, to protect\n        performance of the explorer page\n    its complexity comes from its use of lastAction: this is set by redux reducer,\n    but redux does not send notification to subscribers on every state change; rather\n    it accumulates changes during js code block, or has a timer. In any case, some lastActions\n    are overwritten, if they are generated close together. (this after reduction in the use of setTimeout, 0ms)\n    To accommodate this, the lastAction reducer is complemented by a lastTargetedAction reducer\n    which accumulates actions by uid, acting as a kind of cache (and avoiding a queue). see reducer.tsx\n\n    The elaborate logic below is meant to accommodate the various conditions that can obtain.\n    It makes assumptions however:\n    1. that individual uid actions will not be overriden, so the code\n    should only generate one instance-specific action at a time.\n    2. It also makes the assumption that the lastAction is complementary to the lastTargetedAction. so when\n    the latter is allowed through, the former will also run. I think that means that one or the other has\n    to operate on the global state only, so that its complement will cause branching to the correct\n    post-action behaviour. Put another way, I think the post-action behaviour must be designed to support\n    all combinations of post-action behaviour.\n\n    Oh, and all this supports a hybrid redux/flux (global/local) state management system. Global is used\n    for (more or less) persitent settings, whereas local is used for transient constructs.\n\n    These assumptions have not been proven! (but so far it\'s working)\n    TODO: prove these assumptions!\n\n*/\nconst filterActionsForUpdate = (nextProps, component, show = false) => {\n    let componentName = component.constructor.name;\n    let instance, text, targetType;\n    switch (componentName) {\n        case \'ExplorerBranch\':\n            let { budgetBranch } = nextProps;\n            instance = budgetBranch;\n            text = \'BRANCH\';\n            targetType = \'branch\';\n            break;\n        case \'ExplorerNode\':\n            let { budgetNode } = nextProps;\n            instance = budgetNode;\n            text = \'NODE\';\n            targetType = \'node\';\n            break;\n        case \'ExplorerCell\':\n            let { budgetCell } = nextProps;\n            instance = budgetCell;\n            text = \'CELL\';\n            targetType = \'cell\';\n            break;\n        default:\n            throw Error(\'unexpected component called filterActionsForUpdate\');\n    }\n    let { declarationData } = nextProps;\n    let { generation } = declarationData;\n    // 1. explicit call to skip an update\n    if (component.waitafteraction) {\n        component.lastactiongeneration = generation;\n        component.waitafteraction--;\n        if (show) console.log(`should update ${text} return waitafteraction`);\n        return false;\n    }\n    // 2. if the last action is not marked explorer, cancel update\n    let { lastAction } = declarationData;\n    if (generation > component.lastactiongeneration) {\n        if (!lastAction.explorer) {\n            if (show) console.log(`should update ${text} return false for not explorer`, generation, component.lastactiongeneration, lastAction);\n            component.lastactiongeneration = generation;\n            return false;\n        }\n    }\n    // 3. look for targeted action (may have been bypassed with redux race condition)\n    let { lastTargetedAction } = nextProps.declarationData;\n    let uid = instance.uid;\n    let lastTargetedTypeAction = lastTargetedAction[uid];\n    if (lastTargetedTypeAction && component.lastactiongeneration < lastTargetedTypeAction.generation) {\n        if (show) console.log(`returning from targeted ${text} should component update`, instance.uid, true, component.lastactiongeneration, generation, lastAction, lastTargetedAction, lastTargetedTypeAction);\n        component.lastactiongeneration = generation;\n        return true;\n    }\n    // 4. look for general action\n    if (!lastAction[targetType + \'uid\'] && generation > component.lastactiongeneration) {\n        if (show) console.log(`returning TRUE for lastAction without ${text} reference`, instance.uid, component.lastactiongeneration, generation, lastAction);\n        component.lastactiongeneration = generation;\n        return true;\n    }\n    // 5. filter out legitimate mismatched targets\n    let filtered = Object.keys(lastTargetedAction).filter(item => {\n        let itemaction = lastTargetedAction[item];\n        if (itemaction[targetType] && itemaction.generation > component.lastactiongeneration) {\n            return true;\n        }\n    });\n    if (filtered.length > 0) {\n        component.lastactiongeneration = generation;\n        if (show) console.log(`returning FALSE viable ${text} action for another ${text}`, instance.uid);\n        return false;\n    }\n    // 6. explorer actions not targeted let through, but sets lastactiongeneration\n    if (generation > component.lastactiongeneration) {\n        if (show) console.log(`returning default true for ${text} action`, lastAction, generation, component.lastactiongeneration);\n        component.lastactiongeneration = generation;\n        return true;\n    }\n    // 7. default non-actions (local setState) let through\n    if (show) console.log(`returning default true for ${text} NON-ACTION`);\n    return true;\n};\n// from https://css-tricks.com/snippets/javascript/lighten-darken-color/\n// amount is 0 - 256 (probably -- haven\'t tested upper limit; negative makes darker)\nlet ColorBrightness = (col, amt) => {\n    var usePound = false;\n    if (col[0] == "#") {\n        col = col.slice(1);\n        usePound = true;\n    }\n    var num = parseInt(col, 16);\n    var r = (num >> 16) + amt;\n    if (r > 255) r = 255;else if (r < 0) r = 0;\n    var b = (num >> 8 & 0x00FF) + amt;\n    if (b > 255) b = 255;else if (b < 0) b = 0;\n    var g = (num & 0x0000FF) + amt;\n    if (g > 255) g = 255;else if (g < 0) g = 0;\n    return (usePound ? "#" : "") + (g | b << 8 | r << 16).toString(16);\n};\n// from http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\nconst hashCode = string => {\n    let hash = 0;\n    if (string.length == 0) return hash;\n    for (let i = 0; i < string.length; i++) {\n        let char = string.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\n// EXTERNAL MODULE: ./node_modules/react-table/es/index.js + 6 modules\nvar react_table_es = __webpack_require__(1145);\n\n// EXTERNAL MODULE: ./node_modules/react-csv/index.js\nvar react_csv = __webpack_require__(1167);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/components/datatable.tsx\n// datatable.tsx\n\n\n\nvar { Component } = react;\n\n\n\n\n\nlet stringify = __webpack_require__(1163);\nvar format = __webpack_require__(1139);\nvar numberformat = format({ round: 0 });\nvar percentformat = format({ suffix: \'%\', round: 1 });\nclass datatable_DataTable extends Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            dialogOpen: true\n        };\n        this.specifications = null;\n        this.onRequestClose = () => {\n            this.props.onRequestClose();\n        };\n        this.csv = null;\n        this.assembleCSVdata = () => {\n            if (this.csv) return this.csv;\n            let tableparms = this.specifications;\n            let { columns, title, data, footer } = tableparms;\n            let headercells = [];\n            let titlecells = [title];\n            // let footercells = []\n            // let datacells = []\n            for (let n = 0; n < columns.length; n++) {\n                headercells.push(columns[n].Header);\n            }\n            // titlecells[0] = title\n            // for (let n = 0; n < footer.length; n++) {\n            //     footercells.push(footer[n])\n            // }\n            let csv = [titlecells, headercells, ...data, footer];\n            csv = stringify(csv);\n            // console.log(\'csv\',csv)\n            this.csv = csv;\n            return this.csv;\n        };\n        this.assembleTableData = () => {\n            let sourcedata = this.specifications.data;\n            let data = [];\n            for (let row of sourcedata) {\n                let newdata = {};\n                for (let n = 0; n < row.length; n++) {\n                    newdata[n] = row[n];\n                }\n                data.push(newdata);\n            }\n            let newdata = {};\n            let row = this.specifications.footer;\n            for (let n = 0; n < row.length; n++) {\n                newdata[n] = row[n];\n            }\n            data.push(newdata);\n            return data;\n        };\n        this.assembleTableColumns = () => {\n            let sourcecolumns = this.specifications.columns;\n            let columns = [];\n            for (let n = 0; n < sourcecolumns.length; n++) {\n                let column = columns[n] = sourcecolumns[n];\n                column.accessor = n.toString();\n                column.Cell = props => this._formatCell(column, props);\n            }\n            return columns;\n        };\n        this._formatCell = (column, props) => {\n            let cell;\n            if (column.type == \'number\' || column.type == \'ratio\') {\n                cell = react["createElement"]("div", { style: { textAlign: \'right\' } }, this._formatValue(column, props));\n            } else {\n                cell = react["createElement"]("div", null, props.value);\n            }\n            return cell;\n        };\n        this._formatValue = (column, props) => {\n            let value = props.value;\n            if (!value) return null;\n            if (column.type == \'ratio\') {\n                value *= 100;\n                if (value) value = percentformat(value);\n            }\n            if (column.type == \'number\') {\n                value = numberformat(value);\n            }\n            return value;\n        };\n        this.tableDialog = () => {\n            // console.log(\'returning dialog\',this.findAspectChartLookups)\n            return react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\', textAlign: \'center\' } }, "Data Table"), modal: false, open: this.state.dialogOpen, onRequestClose: this.onRequestClose, autoScrollBodyContent: true, autoDetectWindowHeight: true }, react["createElement"](IconButton_default.a, { style: {\n                    top: 0,\n                    right: 0,\n                    padding: 0,\n                    height: "36px",\n                    width: "36px",\n                    position: "absolute",\n                    zIndex: 2\n                }, tooltip: "close", onClick: this.onRequestClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", { style: {\n                    top: 0,\n                    left: 0,\n                    padding: 0,\n                    height: "36px",\n                    position: "absolute",\n                    zIndex: 2\n                } }, react["createElement"](react_csv["CSVLink"], { data: this.assembleCSVdata(), filename: \'budgetpedia.chart.data.csv\' }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer", verticalAlign: \'middle\' } }, "file_download"), react["createElement"]("span", null, "Download")), " (right click \\"Save link as...\\" with ad blocker)"), react["createElement"]("div", { style: { fontWeight: \'bold\' } }, this.specifications.title), react["createElement"](react_table_es["a" /* default */], { style: { height: \'300px\' }, data: this.assembleTableData(), columns: this.assembleTableColumns(), showPagination: false }));\n        };\n    }\n    componentWillMount() {\n        this.specifications = this.props.specifications;\n        // console.log(\'DataTable specs\',this.specifications)\n    }\n    render() {\n        let dialog = this.tableDialog();\n        return dialog;\n    }\n}\n/* harmony default export */ var components_datatable = (datatable_DataTable);\n// CONCATENATED MODULE: ./ts/addons/explorer/components/explorercell.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorerchart.tsx\n/*\n    BUG: The rightmost piechart does not have its selected component reselected\n        after migrate away from, and return to explorer page.\n    TODO: two way arrow icon to signify impose current chart settings on entire branch\n*/\n// <reference path="../../../typings-custom/chart.d.ts" />\n\n\n\nvar { Component: explorercell_Component } = react;\nvar { Chart } = __webpack_require__(1137);\n\n\n\n\n\n\n\n\n\nclass explorercell_ExplorerCell extends explorercell_Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            deltastate: false,\n            netstate: false,\n            variancestate: false,\n            chartParms: null,\n            datatableopen: false\n        };\n        // for use by BudgetCell instance...\n        this.getState = () => this.state;\n        this.getProps = () => this.props;\n        this.urlparms = null;\n        this.lastactiongeneration = 0;\n        this.waitafteraction = 0;\n        // state change manager\n        this._respondToGlobalStateChange = () => {\n            let previousControlData = this._previousControlData;\n            let currentControlData = this.props.declarationData;\n            let { lastAction } = currentControlData;\n            let returnvalue = true;\n            if (!explorer_actions["h" /* cellTypes */][lastAction.type]) {\n                return false;\n            }\n            // only process once\n            if (previousControlData && currentControlData.generation == previousControlData.generation) {\n                return false;\n            }\n            let { budgetCell } = this.props;\n            let cellDeclaration = this.cellDeclaration;\n            switch (lastAction.type) {\n                case explorer_actions["h" /* cellTypes */].UPDATE_CELL_CHART_CODE:\n                    {\n                        budgetCell.switchChartCode();\n                        break;\n                    }\n                case explorer_actions["h" /* cellTypes */].UPDATE_CELL_TIMECODE:\n                    {\n                        budgetCell.switchYearScope();\n                    }\n            }\n            this._previousControlData = currentControlData;\n        };\n        this.onChangeChartCode = explorerChartCode => {\n            let { budgetCell } = this.props;\n            this.props.globalStateActions.updateCellChartCode(budgetCell.uid, explorerChartCode);\n        };\n        this.onChangeChartYears = (leftYear, rightYear) => {\n            let { budgetCell } = this.props;\n            this.props.globalStateActions.updateCellYearSelections(leftYear, rightYear);\n        };\n        this.onChangeTimeCode = explorerTimeCode => {\n            let { budgetCell } = this.props;\n            this.props.globalStateActions.updateCellTimeScope(budgetCell.uid, explorerTimeCode);\n        };\n        this.onToggleDelta = () => {\n            this.setState({\n                deltastate: !this.state.deltastate\n            });\n        };\n        this.onToggleNet = () => {\n            this.setState({\n                netstate: !this.state.netstate\n            });\n        };\n        this.onToggleVariance = () => {\n            this.setState({\n                variancestate: !this.state.variancestate\n            });\n        };\n        this.datatableparms = {\n            tableparms: null\n        };\n        this.onDataTable = e => {\n            let budgetCell = this.props.budgetCell;\n            let tableparms = budgetCell.getDataTable();\n            // console.log(\'onDataTable tableparms\',tableparms)\n            this.datatableparms.tableparms = tableparms;\n            this.setState({\n                datatableopen: true\n            });\n        };\n        this.onReqestCloseDataTable = () => {\n            this.setState({\n                datatableopen: false\n            });\n        };\n        this.onConfirmDataExport = () => {};\n        this.onHarmonize = () => {\n            this.props.callbacks.harmonizeCells(this.props.budgetCell.nodeDataPack.budgetNode.uid, this.props.budgetCell.uid);\n        };\n    }\n    componentWillMount() {\n        let { budgetCell, urlparms } = this.props;\n        budgetCell.getProps = this.getProps;\n        budgetCell.getState = this.getState;\n        budgetCell.setState = this.setState.bind(this);\n        budgetCell.setChartParms();\n        if (urlparms) {\n            this.urlparms = urlparms;\n        }\n    }\n    componentDidMount() {\n        this._previousControlData = this.props.declarationData; // initialize\n        let { budgetCell } = this.props;\n        setTimeout(() => {\n            budgetCell.refreshSelection(); // for re-creation; last pie chart is missed\n        });\n        // console.log(\'budgetCell\',this.props.budgetCell)\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        let cellComponent = this;\n        return filterActionsForUpdate(nextProps, cellComponent);\n    }\n    componentDidUpdate() {\n        let explorerCell = this;\n        explorerCell._respondToGlobalStateChange();\n        explorerCell.props.budgetCell.refreshSelection();\n    }\n    // conveniences... get x 2\n    get cellDeclaration() {\n        return this.props.declarationData.cellsById[this.props.budgetCell.uid];\n    }\n    get chartConfig() {\n        let cellDeclaration = this.cellDeclaration;\n        return cellDeclaration.chartConfigs[cellDeclaration.yearScope];\n    }\n    render() {\n        let { budgetCell } = this.props;\n        let cellDeclaration = this.props.declarationData.cellsById[budgetCell.uid];\n        let yearScope = cellDeclaration.yearScope;\n        let { chartParms, explorerChartCode, graph_id, viewpointConfigPack } = budgetCell;\n        let { datasetConfig } = viewpointConfigPack;\n        let { start: startYear, end: endYear } = datasetConfig.YearsRange;\n        let yearSpan = endYear - startYear;\n        let leftYear = budgetCell.nodeDataPack.yearSelections.leftYear;\n        let rightYear = budgetCell.nodeDataPack.yearSelections.rightYear;\n        // get drilldown message\n        let datanode = budgetCell.nodeDataPack.treeNodeData;\n        let datasetiestype = budgetCell.nodeDataseriesName;\n        let drillDownProperty = datasetiestype + \'Drilldown\';\n        let drillDown = datanode[drillDownProperty] || \'None\';\n        let drilldownmessage;\n        if (drillDown == \'All\') {\n            drilldownmessage = \'drilldown is available for all elements here\';\n        } else if (drillDown == \'Some\') {\n            drilldownmessage = \'some elements allow drilldown here\';\n        } else {\n            drilldownmessage = \'no drilldown is available here\';\n        }\n        let isDataAvailable = true;\n        if (yearScope == \'OneYear\') {\n            isDataAvailable = false;\n            let data = datanode[datasetiestype];\n            for (let index in data) {\n                if (data[index].years && data[index].years[rightYear]) {\n                    isDataAvailable = true;\n                    break;\n                }\n            }\n        }\n        let timescopes = react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                borderRight: "1px solid silver",\n                marginRight: "3px",\n                position: "relative",\n                display: "inline-block"\n            } }, react["createElement"]("div", { style: { position: "absolute", top: "0", left: "0", fontSize: "8px" } }, "number of years to include"), react["createElement"](IconButton_default.a, { tooltip: "One year", tooltipPosition: "top-center", style: {\n                backgroundColor: this.cellDeclaration.yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? "rgba(144,238,144,0.5)" : "rgba(255,255,255,0.5)",\n                borderRadius: "15%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeTimeCode(constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear]);\n            } }, react["createElement"](SvgIcon_default.a, { style: { height: "36px", width: "36px" }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "13", y: "13", width: "10", height: "10" }))), react["createElement"](IconButton_default.a, { tooltip: "Two years", disabled: yearSpan === 0, tooltipPosition: "top-center", style: {\n                backgroundColor: this.cellDeclaration.yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].TwoYears] ? "rgba(144,238,144,0.5)" : "rgba(255,255,255,0.5)",\n                borderRadius: "15%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeTimeCode(constants["d" /* TimeScope */][constants["d" /* TimeScope */].TwoYears]);\n            } }, react["createElement"](SvgIcon_default.a, { style: { height: "36px", width: "36px" }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "4", y: "13", width: "10", height: "10" }), react["createElement"]("rect", { x: "22", y: "13", width: "10", height: "10" }))), react["createElement"](IconButton_default.a, { tooltip: "All years", tooltipPosition: "top-center", disabled: yearSpan === 0, style: {\n                backgroundColor: this.cellDeclaration.yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].AllYears] ? "rgba(144,238,144,0.5)" : "rgba(255,255,255,0.5)",\n                borderRadius: "15%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeTimeCode(constants["d" /* TimeScope */][constants["d" /* TimeScope */].AllYears]);\n            } }, react["createElement"](SvgIcon_default.a, { style: { height: "36px", width: "36px" }, viewBox: "0 0 36 36" }, react["createElement"]("ellipse", { cx: "6", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "18", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "30", cy: "18", rx: "4", ry: "4" }))));\n        // =====================[ options for getchartoptions() ]=======================\n        let columnchart = react["createElement"](IconButton_default.a, { key: \'columnchart\', tooltip: "Column Chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "ColumnChart" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'ColumnChart\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "insert_chart"));\n        let diffcolumnchart = react["createElement"](IconButton_default.a, { key: \'diffchart\', tooltip: "Diff Column Chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "DiffColumnChart" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'DiffColumnChart\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "insert_chart"));\n        let donutchart = react["createElement"](IconButton_default.a, { key: \'donutchart\', tooltip: "Donut Pie Chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "DonutChart" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'DonutChart\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "donut_small"));\n        let diffpiechart = react["createElement"](IconButton_default.a, { key: \'donutchart\', tooltip: "Diff Pie Chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "DiffPieChart" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'DiffPieChart\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "donut_small"));\n        let contextchart = react["createElement"](IconButton_default.a, { disabled: true, key: \'contextchart\', tooltip: "Context Chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "ContextChart" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'ContextChart\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "view_quilt"));\n        let timelines = react["createElement"](IconButton_default.a, { key: \'timelines\', tooltip: "Timeline", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "TimeLine" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0 0 0 6px",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'TimeLine\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "timelines"));\n        let stackedchart = react["createElement"](IconButton_default.a, { key: \'stackedchart\', tooltip: "Stacked chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "StackedArea" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'StackedArea\');\n            } }, react["createElement"](SvgIcon_default.a, { style: { height: "24px", width: "24px" } }, react["createElement"]("path", { d: "M20,6c0-0.587-0.257-1.167-0.75-1.562c-0.863-0.69-2.121-0.551-2.812,0.312l-2.789,3.486L11.2,6.4  c-0.864-0.648-2.087-0.493-2.762,0.351l-4,5C4.144,12.119,4,12.562,4,13v3h16V6z" }), react["createElement"]("path", { d: "M20,19H4c-0.552,0-1,0.447-1,1s0.448,1,1,1h16c0.552,0,1-0.447,1-1S20.552,19,20,19z" })));\n        let proportionalchart = react["createElement"](IconButton_default.a, { key: \'propchart\', tooltip: "Proportional chart", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "Proportional" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onChangeChartCode(\'Proportional\');\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "view_stream"));\n        let getchartoptions = () => {\n            let chartoptions;\n            switch (this.cellDeclaration.yearScope) {\n                case constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear]:\n                    chartoptions = [columnchart, donutchart]; //, contextchart ]\n                    break;\n                case constants["d" /* TimeScope */][constants["d" /* TimeScope */].TwoYears]:\n                    chartoptions = [diffcolumnchart, diffpiechart];\n                    break;\n                case constants["d" /* TimeScope */][constants["d" /* TimeScope */].AllYears]:\n                    chartoptions = [timelines, stackedchart, proportionalchart];\n                    break;\n            }\n            return react["createElement"]("div", { style: {\n                    paddingTop: "10px",\n                    borderRight: "1px solid silver",\n                    marginRight: "3px",\n                    position: "relative",\n                    display: "inline-block"\n                } }, react["createElement"]("div", { style: { position: "absolute", top: "0", left: "0", fontSize: "8px" } }, "available charts"), chartoptions);\n        };\n        let chartoptions = getchartoptions();\n        let deltatoggle = this.cellDeclaration.yearScope != constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                borderRight: "1px solid silver",\n                marginRight: "3px",\n                position: "relative",\n                display: "inline-block"\n            } }, react["createElement"]("div", { style: {\n                position: "absolute",\n                top: "0",\n                left: "0",\n                fontSize: "8px",\n                zIndex: 10\n            } }, "year-over-", react["createElement"]("br", null), " year"), react["createElement"](IconButton_default.a, { disabled: false, tooltip: "Year-over-year change", tooltipPosition: "top-center", style: {\n                backgroundColor: this.state.deltastate ? "rgba(144,238,144,0.5)" : "rgba(255,255,255,0.5)",\n                borderRadius: "15%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onToggleDelta();\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "change_history"))) : null;\n        let nettoggle = this.cellDeclaration.yearScope != constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                borderRight: "1px solid silver",\n                marginRight: "3px",\n                position: "relative",\n                display: "inline-block"\n            } }, react["createElement"]("div", { style: { position: "absolute", top: "0", left: "0", fontSize: "8px" } }, "net"), react["createElement"](IconButton_default.a, { disabled: true, tooltip: "Net (revenue - expenses)", tooltipPosition: "top-center", style: {\n                backgroundColor: this.state.netstate ? "rgba(144,238,144,0.5)" : "rgba(255,255,255,0.5)",\n                borderRadius: "15%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onToggleNet();\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "exposure"))) : null;\n        let variancetoggle = this.cellDeclaration.yearScope != constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                borderRight: "1px solid silver",\n                marginRight: "3px",\n                position: "relative",\n                display: "inline-block"\n            } }, react["createElement"]("div", { style: { position: "absolute", top: "0", left: "0", fontSize: "8px" } }, "variance"), react["createElement"](IconButton_default.a, { disabled: true, tooltip: "Variance (actual - budget)", tooltipPosition: "top-center", style: {\n                backgroundColor: this.state.variancestate ? "rgba(144,238,144,0.5)" : "rgba(255,255,255,0.5)",\n                borderRadius: "15%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onToggleVariance();\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "exposure"))) : null;\n        // ----------------------[ options for below the chart ]---------------------------\n        let datatable = react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                borderLeft: "1px solid silver",\n                marginRight: "3px",\n                position: "relative",\n                display: "inline-block"\n            } }, react["createElement"]("div", { style: {\n                paddingLeft: \'3px\',\n                position: "absolute",\n                top: "0",\n                left: "0",\n                fontSize: "8px",\n                textAlign: "left"\n            } }, "see data", react["createElement"]("br", null), "table"), react["createElement"](IconButton_default.a, { disabled: false, tooltip: "Data Table", tooltipPosition: "top-center", style: {\n                backgroundColor: explorerChartCode == "DataTable" ? "rgba(144,238,144,0.5)" : "transparent",\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onDataTable(e);\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "view_list")));\n        let harmonizeoptions = react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                borderLeft: "1px solid silver",\n                borderRight: "1px solid silver",\n                paddingRight: "3px",\n                position: "relative",\n                display: "inline-block"\n            } }, react["createElement"]("div", { style: {\n                paddingLeft: \'3px\',\n                position: "absolute",\n                top: "0",\n                left: "0",\n                fontSize: "8px"\n            } }, "harmonize ", react["createElement"]("br", null), "settings"), react["createElement"](IconButton_default.a, { tooltip: "Harmonize settings for row", tooltipPosition: "top-center", style: {\n                borderRadius: "50%",\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, onClick: e => {\n                this.onHarmonize();\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "swap_horiz")));\n        let socialoptions = react["createElement"]("div", { style: {\n                paddingTop: "10px",\n                display: "inline-block",\n                position: "relative"\n            } }, react["createElement"]("div", { style: { paddingLeft: "3px", position: "absolute", top: "0", left: "0", fontSize: "8px" } }, "social [deferred]"), react["createElement"](IconButton_default.a, { tooltip: "Shared stories", tooltipPosition: "top-center", style: {\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, disabled: true }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "share")), react["createElement"](IconButton_default.a, { tooltip: "Calls to action", tooltipPosition: "top-center", style: {\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px",\n                marginLeft: "3px"\n            }, disabled: true }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "announcement")));\n        let informationoptions = react["createElement"]("div", { style: {\n                display: "inline-block",\n                paddingTop: "10px",\n                borderLeft: "1px solid silver",\n                borderRight: "1px solid silver",\n                position: "relative"\n            } }, react["createElement"]("div", { style: { paddingLeft: "3px", position: "absolute", top: "0", left: "0", fontSize: "8px" } }, "information [deferred]"), react["createElement"](IconButton_default.a, { tooltip: "Information", tooltipPosition: "top-center", style: {\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px"\n            }, disabled: true }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "info_outline")), react["createElement"](IconButton_default.a, { tooltip: "Technical notes", tooltipPosition: "top-center", style: {\n                padding: "0",\n                height: "36px",\n                width: "36px",\n                marginRight: "3px",\n                marginLeft: "3px"\n            }, disabled: true }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "note")));\n        // ------------------------------[ the chart itself ]-----------------------------\n        // console.log(chartParms)\n        let chart = chartParms ? isDataAvailable ? react["createElement"](Chart, { ref: node => {\n                budgetCell.chartComponent = node;\n            }, chartType: chartParms.chartType, options: chartParms.options, chartEvents: chartParms.events, rows: chartParms.rows, columns: chartParms.columns, diffdata: chartParms.diffdata,\n            // used to create and cache html element id attribute\n            graph_id: graph_id }) : react["createElement"]("div", { style: {\n                width: \'360px\',\n                height: \'220px\',\n                backgroundColor: \'whitesmoke\',\n                textAlign: \'center\',\n                fontStyle: \'italic\',\n                whiteSpace: \'normal\',\n                fontSize: \'smaller\',\n                padding: \'40px 20px\'\n            } }, " ", react["createElement"]("p", null, "no data for this chart for the selected year: "), react["createElement"]("p", null, budgetCell.chartParmsObject.options.title), react["createElement"]("p", null, "(", budgetCell.chartParmsObject.options.hAxis.title, ")")) : react["createElement"]("div", null, " waiting for chart data... ");\n        if (!isDataAvailable) {\n            drilldownmessage = null;\n        }\n        let drilldownprompt = react["createElement"]("div", { style: {\n                position: "absolute",\n                bottom: "-12px",\n                left: "3px",\n                fontSize: "9px",\n                fontStyle: "italic"\n            } }, drilldownmessage);\n        let informationprompt = () => {\n            let viewpoint = this.props.budgetCell.nodeDataPack.budgetNode.branchSettings.viewpoint;\n            let nodepath = this.props.budgetCell.nodeDataPack.budgetNode.dataPath;\n            return viewpoint == \'FUNCTIONAL\' || viewpoint == \'STRUCTURAL\' ? react["createElement"]("div", { style: {\n                    display: \'inline-block\',\n                    // position:"absolute",\n                    // top:"8px",\n                    // right:"3px",\n                    fontSize: "9px",\n                    fontStyle: "italic",\n                    zIndex: 10\n                } }, react["createElement"](IconButton_default.a, { tooltip: "Information", tooltipPosition: "top-center", onClick: () => {\n                    this.props.onCallAnalystNotes(viewpoint, nodepath);\n                }, style: {\n                    padding: "0",\n                    height: "36px",\n                    width: "36px",\n                    marginRight: "3px"\n                } }, react["createElement"](FontIcon_default.a, { className: "material-icons" }, "info_outline"))) : null;\n        };\n        // ----------------------[ year selections ]---------------------------------\n        let yearsoptions = () => {\n            let years = [];\n            for (let year = startYear; year <= endYear; year++) {\n                let yearitem = react["createElement"](MenuItem_default.a, { key: year, value: year, primaryText: year.toString() });\n                years.push(yearitem);\n            }\n            return years;\n        };\n        let yearselection = () => {\n            let height = this.props.showControls ? "53px" : "12px";\n            return react["createElement"]("div", { style: {\n                    height: height,\n                    transition: \'height .5s\'\n                } }, this.props.showControls ? react["createElement"]("div", { style: { paddingBottom: "3px" } }, react["createElement"]("span", { style: { fontStyle: "italic", verticalAlign: \'25px\', lineHeight: \'48px\' } }, "Select ", yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? \'year\' : \'years\', ": "), yearScope != constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? react["createElement"](DropDownMenu_default.a, { value: leftYear, style: {}, onChange: (e, key, payload) => {\n                    this.onChangeChartYears(payload, rightYear);\n                } }, yearsoptions()) : null, yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] ? null : yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].TwoYears] ? react["createElement"]("span", { style: { verticalAlign: \'25px\', lineHeight: \'48px\' } }, ":") : react["createElement"]("span", { style: { verticalAlign: \'25px\', lineHeight: \'48px\' } }, "-"), react["createElement"](DropDownMenu_default.a, { value: rightYear, style: {}, onChange: (e, key, payload) => {\n                    this.onChangeChartYears(leftYear, payload);\n                } }, yearsoptions())) : react["createElement"]("div", { style: { height: "12px" } }));\n        };\n        let controlBarHeight = this.props.showControls ? "52px" : "0px";\n        return react["createElement"]("div", null, react["createElement"]("div", { style: { height: controlBarHeight, transition: \'height .5s\', overflow: \'hidden\' } }, react["createElement"]("div", { style: { padding: "3px" } }, react["createElement"]("div", { style: { float: \'right\' } }, informationprompt(), datatable, harmonizeoptions), timescopes, chartoptions)), react["createElement"]("div", { style: { position: "relative" } }, chart, drilldownprompt), react["createElement"]("div", { style: { padding: "3px", textAlign: "center" } }, yearselection()), this.state.datatableopen ? react["createElement"](components_datatable, { specifications: this.datatableparms.tableparms, onRequestClose: this.onReqestCloseDataTable }) : null);\n    }\n}\n/* harmony default export */ var explorercell = (explorercell_ExplorerCell);\n// CONCATENATED MODULE: ./ts/addons/explorer/components/explorernode.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorerportal.tsx\n/*\n    TODO: include output checkbox per node for printing prep\n    - with clean start, switching to second tab causes \'jump\' to top of page\n       ... but not clicking first tab after selecting second\n*/\n\n\n\nvar { Component: explorernode_Component } = react;\n\n\n\nlet { StyleRoot } = radium_es;\nconst animations = {\n    fadeIn: {\n        animation: \'x .7s\',\n        animationName: keyframes["a" /* default */](react_animations_lib["fadeIn"], \'fadeIn\')\n    }\n};\n\n\n\nclass explorernode_ExplorerNode extends explorernode_Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            nodeCells: [],\n            animation: animations.fadeIn\n        };\n        this.waitafteraction = 0;\n        // for BudgetNode instance...\n        this.getState = () => this.state;\n        this.getProps = () => this.props;\n        this.urlparms = null;\n        this.story = null;\n        this.oldDataGenerationCounter = null;\n        /*\n            return false for redundant updates\n            this reduces updates by about half, therefore\n            reducing update delay caused by cascading events\n        */\n        this.lastactiongeneration = 0;\n        // state change manager\n        this._respondToGlobalStateChange = () => {\n            let previousControlData = this._previousControlData;\n            let currentControlData = this.props.declarationData;\n            let { lastAction } = currentControlData;\n            let returnvalue = true;\n            if (!explorer_actions["q" /* nodeTypes */][lastAction.type]) {\n                return false;\n            }\n            // only process once\n            if (previousControlData && currentControlData.generation == previousControlData.generation) {\n                return false;\n            }\n            let { budgetNode } = this.props;\n            let nodeDeclaration = this.props.declarationData.nodesById[budgetNode.uid];\n            switch (lastAction.type) {\n                case explorer_actions["q" /* nodeTypes */].NORMALIZE_CELL_YEAR_DEPENDENCIES:\n                    {\n                        let currentYearSelections = currentControlData.nodesById[budgetNode.uid].yearSelections;\n                        let previousYearSelections = previousControlData.nodesById[budgetNode.uid].yearSelections;\n                        if (currentYearSelections.leftYear !== previousYearSelections.leftYear || currentYearSelections.rightYear !== previousYearSelections.rightYear) {\n                            budgetNode.switchYearSelections(Object.assign({}, currentYearSelections));\n                            this.forceUpdate();\n                        }\n                        break;\n                    }\n                case explorer_actions["q" /* nodeTypes */].UPDATE_NODE_YEAR_SELECTIONS:\n                    {\n                        budgetNode.switchYearSelections(currentControlData.nodesById[budgetNode.uid].yearSelections);\n                        break;\n                    }\n            }\n            this._previousControlData = currentControlData;\n        };\n        this.updateCellsFromDeclarations = props => {\n            let { budgetNode } = props; // this.props\n            if (budgetNode.updated) {\n                this.setState({\n                    nodeCells: [...budgetNode.newCells]\n                });\n                budgetNode.newCells = null;\n                budgetNode.updated = false;\n            }\n        };\n        this.harmonizecount = null;\n        // harmonize branch nodes; add pending node objects, and process state changes\n        this._harmonizeCellsToState = props => {\n            let returnvalue = false;\n            let { budgetNode, declarationData } = props;\n            let cells = budgetNode.cells;\n            let { cellList } = declarationData.nodesById[budgetNode.uid];\n            // remove any deleted cells\n            let { cellsById } = declarationData;\n            let newCells = cells.filter(cell => {\n                return !!cellsById[cell.uid];\n            });\n            if (newCells.length != cells.length) {\n                this.setState({\n                    nodeCells: newCells\n                });\n                cells = budgetNode.cells;\n            }\n            // harmonization required if there is a mismatch between cells and cellList\n            if (cells.length != cellList.length && this.harmonizecount == null) {\n                // console.log(\'harmonizing cells for\',budgetNode.uid)\n                this.harmonizecount = cellList.length - cells.length;\n                let cellParms = [];\n                let { cellsById } = declarationData;\n                for (let cellid of cellList) {\n                    cellParms.push(cellsById[cellid]);\n                }\n                let newcells = budgetNode.setCells(cellParms);\n                if (newcells.length == cellList.length) {\n                    this.harmonizecount = null;\n                }\n                returnvalue = true;\n                this.setState({\n                    nodeCells: newcells\n                });\n            }\n            return returnvalue;\n        };\n        this._normalizeCellDeclarations = props => {\n            let { budgetNode } = props;\n            let nodeDeclaration = props.declarationData.nodesById[budgetNode.uid];\n            let cellList = nodeDeclaration.cellList;\n            let yearsRange = budgetNode.viewpointConfigPack.datasetConfig.YearsRange;\n            this._stateActions.normalizeCellYearDependencies(budgetNode.uid, cellList, yearsRange);\n        };\n        this.onChangeTab = tabref => {\n            this.props.globalStateActions.changeTab(this.props.budgetNode.uid, tabref);\n        };\n        this._chartrefs = [];\n        this.getChartTabs = () => {\n            // generate array of chart tabs\n            let { callbackid, budgetNode } = this.props;\n            let budgetCells = budgetNode.cells;\n            let portalSettings = budgetNode.portalConfig;\n            // let { chartConfigs } = portalSettings \n            let cellTabs = budgetCells.map((budgetCell, cellIndex) => {\n                let { cellTitle } = budgetCell;\n                return react["createElement"](Tabs["Tab"], { style: {\n                        fontSize: "12px"\n                    }, label: cellTitle, value: cellIndex, key: cellIndex }, react["createElement"](explorercell, { declarationData: this.props.declarationData, callbackid: cellIndex, budgetCell: budgetCell, globalStateActions: {\n                        updateCellTimeScope: this.props.globalStateActions.updateCellTimeScope,\n                        updateCellChartCode: this.props.globalStateActions.updateCellChartCode,\n                        updateCellYearSelections: this.props.globalStateActions.updateCellYearSelections\n                    }, showControls: this.props.showControls, callbacks: this.props.callbacks, urlparms: this.urlparms, onCallAnalystNotes: this.props.onCallAnalystNotes }));\n            });\n            return cellTabs;\n        };\n        this.getTabObject = chartTabs => {\n            // this deals with the edge case where switching aspects causes current tail\n            // chart to change from 2 charts to one by adding a value attr to tabs component\n            let nodeDeclaration = this.props.declarationData.nodesById[this.props.budgetNode.uid];\n            let tabSelection = nodeDeclaration.cellIndex;\n            if (chartTabs.length == 0) {\n                return react["createElement"]("div", { style: {\n                        height: "400px",\n                        textAlign: "center",\n                        verticalAlign: "middle",\n                        lineHeight: "400px"\n                    } }, "Waiting for data...");\n            }\n            return react["createElement"](Tabs["Tabs"], { value: tabSelection, onChange: tabref => {\n                    this.onChangeTab(tabref);\n                } }, chartTabs);\n        };\n    }\n    componentWillMount() {\n        let { budgetNode, declarationData, urlparms, story } = this.props;\n        // console.log(\'componentWillMount for\',budgetNode)\n        // console.log(\'componentWillMount story\',story)\n        if (story) {\n            this.story = story;\n        }\n        if (urlparms) {\n            this.urlparms = urlparms;\n        }\n        this._stateActions = Object.assign({}, this.props.globalStateActions);\n        budgetNode.getState = this.getState;\n        budgetNode.getProps = this.getProps;\n        budgetNode.setState = this.setState.bind(this);\n        budgetNode.actions = this._stateActions;\n        let nodeDeclaration = declarationData.nodesById[budgetNode.uid];\n        if (nodeDeclaration.cellList == null) {\n            // get controlData for cellList\n            // TODO: cloning with JSON is required here to avoid cross linking chartType - shoud be traced\n            let cellDeclarationParms = JSON.parse(JSON.stringify(budgetNode.getCellDeclarationParms()));\n            if (story) {\n                // console.log(\'node cellDeclarationParms for story\',cellDeclarationParms,budgetNode.nodeIndex,story)\n                if (story.charts === true || budgetNode.nodeIndex == story.path.length && story.leafchart) {\n                    let cellparms = cellDeclarationParms[story.tab];\n                    if (!cellparms) {\n                        console.error(\'error:cellparms failed\', story, cellDeclarationParms, budgetNode);\n                    }\n                    let chartspecs = story.leafchart.split(\':\');\n                    cellparms.yearScope = chartspecs[0];\n                    cellparms.chartConfigs[cellparms.yearScope].explorerChartCode = chartspecs[1];\n                }\n                // set chartSelection value for drilldown cell if required\n                let { nodeIndex } = budgetNode;\n                let { path } = story;\n                // console.log(\'cellparms\',nodeIndex,cellIndex,cellparms)\n                if (nodeIndex < path.length) {\n                    let code = path[nodeIndex];\n                    let { datasetConfig } = budgetNode.viewpointConfigPack;\n                    let { Dataseries } = datasetConfig;\n                    let drilldownindex = null;\n                    for (let itemindex in Dataseries) {\n                        let item = Dataseries[itemindex];\n                        if (item.Type == \'Components\') {\n                            drilldownindex = parseInt(itemindex);\n                            break;\n                        }\n                    }\n                    if (drilldownindex !== null) {\n                        let drilldownparms = cellDeclarationParms[drilldownindex];\n                        let nodeDataList = budgetNode.treeNodeData.SortedComponents;\n                        let chartSelection = null;\n                        for (let index in nodeDataList) {\n                            let item = nodeDataList[index];\n                            if (item.Code == code) {\n                                chartSelection = parseInt(index);\n                                break;\n                            }\n                        }\n                        if (chartSelection !== null) {\n                            drilldownparms.chartSelection = chartSelection;\n                        }\n                    }\n                }\n                this.story = null;\n                this.props.clearStory(budgetNode.nodeIndex);\n            }\n            if (urlparms) {\n                // apply imported parms\n                let cellurlparms = urlparms.settingsdata[budgetNode.nodeIndex];\n                let cellIndex = cellurlparms.ci;\n                let cellparms = cellDeclarationParms[cellIndex];\n                cellparms.yearScope = cellurlparms.c.ys;\n                cellparms.chartConfigs[cellparms.yearScope].explorerChartCode = cellurlparms.c.ct;\n                // set chartSelection value for drilldown cell if required\n                let { nodeIndex } = budgetNode;\n                // console.log(\'cellparms\',nodeIndex,cellIndex,cellparms)\n                if (nodeIndex < urlparms.branchdata.pa.length) {\n                    let code = urlparms.branchdata.pa[nodeIndex];\n                    let { datasetConfig } = budgetNode.viewpointConfigPack;\n                    let { Dataseries } = datasetConfig;\n                    let drilldownindex = null;\n                    for (let itemindex in Dataseries) {\n                        let item = Dataseries[itemindex];\n                        if (item.Type == \'Components\') {\n                            drilldownindex = parseInt(itemindex);\n                            break;\n                        }\n                    }\n                    if (drilldownindex !== null) {\n                        let drilldownparms = cellDeclarationParms[drilldownindex];\n                        let nodeDataList = budgetNode.treeNodeData.SortedComponents;\n                        let chartSelection = null;\n                        for (let index in nodeDataList) {\n                            let item = nodeDataList[index];\n                            if (item.Code == code) {\n                                chartSelection = parseInt(index);\n                                break;\n                            }\n                        }\n                        if (chartSelection !== null) {\n                            drilldownparms.chartSelection = chartSelection;\n                        }\n                    }\n                }\n                this.urlparms = null;\n                this.props.clearUrlParms(budgetNode.nodeIndex);\n            }\n            this._stateActions.addCellDeclarations(budgetNode.uid, cellDeclarationParms);\n        } else {\n            this._stateActions.updateNode(budgetNode.uid); // trigger update -> render\n        }\n    }\n    // remove obsolete cell objects; update cell list if needed\n    componentWillReceiveProps(nextProps) {\n        let { dataGenerationCounter, budgetNode } = nextProps;\n        let { oldDataGenerationCounter } = this;\n        let lastAction = nextProps.declarationData.lastAction;\n        if (oldDataGenerationCounter === null || dataGenerationCounter > oldDataGenerationCounter) {\n            this.oldDataGenerationCounter = dataGenerationCounter;\n            // normalize cell settings to year dependency constraints\n            this._normalizeCellDeclarations(nextProps);\n        } else {\n            this.updateCellsFromDeclarations(nextProps);\n            this._harmonizeCellsToState(nextProps);\n            if (budgetNode.new) {\n                budgetNode.new = false;\n            }\n        }\n    }\n    shouldComponentUpdate(nextProps) {\n        let nodeComponent = this;\n        return filterActionsForUpdate(nextProps, nodeComponent);\n    }\n    componentDidUpdate() {\n        let budgetNode = this;\n        budgetNode._respondToGlobalStateChange();\n    }\n    render() {\n        let nodeDeclaration = this.props.declarationData.nodesById[this.props.budgetNode.uid];\n        // console.log(\'nodeDeclaration\', nodeDeclaration)\n        let chartTabs = this.getChartTabs();\n        let tabobject = this.getTabObject(chartTabs);\n        let { portalConfig: portalSettings } = this.props.budgetNode;\n        return react["createElement"](StyleRoot, { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: [{\n                position: "relative",\n                display: "inline-block",\n                padding: "10px",\n                backgroundColor: "Beige",\n                verticalAlign: "top",\n                width: "400px",\n                borderRight: "1px solid silver"\n            }, this.state.animation] }, react["createElement"]("div", { style: {\n                position: "absolute",\n                top: 0,\n                left: "10px",\n                padding: "3px 20px 3px 20px",\n                borderRadius: "6px",\n                border: "1px solid silver",\n                fontSize: "12px",\n                color: "lightgreen",\n                fontWeight: "bold",\n                display: "inline-block",\n                backgroundColor: "#00bcd4"\n            } }, "#" + (this.props.budgetNode.nodeIndex + 1) + ". " + portalSettings.portalName), tabobject));\n    }\n}\n\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/databaseapi/setviewpointdata.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// setviewpointamounts.tsx\n// starts with hash of components, \n// recursively descends to BASELINE baselineItems, then leaves \n// summaries by year, and CommonDimension by year on ascent\nconst setViewpointData = parms => {\n    // let viewpointname = parms.viewpointname,\n    let { datasetName, viewpointDataTemplate, datasetData, lookups, inflationAdjusted } = parms;\n    let datasetMeta = datasetData.MetaData;\n    let baselineLookupIndex = datasetMeta.Dimensions[0].toLowerCase(); // use for system lookups\n    let commonDimensionLookupIndex = datasetMeta.CommonDimension;\n    if (commonDimensionLookupIndex) {\n        commonDimensionLookupIndex = commonDimensionLookupIndex.toLowerCase();\n    }\n    let baselinelookups = lookups[baselineLookupIndex];\n    let commonDimensionLookups = commonDimensionLookupIndex ? lookups[commonDimensionLookupIndex] : null;\n    let taxonomylookups = viewpointDataTemplate.Meta.Lookups.Taxonomy;\n    let lookupset = {\n        baselinelookups,\n        commonDimensionLookups,\n        taxonomylookups\n    };\n    let baselineItems = datasetData.Data;\n    let isInflationAdjustable = !!datasetMeta.InflationAdjustable;\n    if (isInflationAdjustable) {\n        if (inflationAdjusted) {\n            baselineItems = baselineItems.Adjusted;\n        } else {\n            baselineItems = baselineItems.Nominal;\n        }\n    }\n    baselineItems = JSON.parse(JSON.stringify(baselineItems));\n    // set years, and CommonDimension by years\n    try {\n        let node = viewpointDataTemplate;\n        let sorted = getIndexSortedComponentItems(node.Components, lookupset);\n        node.SortedComponents = sorted;\n        // initiates recursion\n        let nodeSummaries = getNodeSummaries(node, baselineItems, lookupset);\n        node.ComponentsDrilldown = nodeSummaries.Drilldown;\n        setNodeSummaries(node, nodeSummaries, lookupset);\n    } catch (e) {\n        console.log(\'error in setComponentAggregates\', e);\n    }\n    // record state\n    viewpointDataTemplate.Meta.currentDataset = datasetName;\n    viewpointDataTemplate.Meta.isInflationAdjusted = inflationAdjusted;\n};\n// this is recursive, with absence of Components property at leaf\n// special treatment for \'BASELINE\' baselineItems -- fetches data from data series baselineItems\n// sets years and CommonDimension for each node\nconst getNodeSummaries = (node, baselineItems, lookups) => {\n    let components = node.Components;\n    // cumulate summaries for this level\n    let aggregator = {\n        // years: {},\n        // CommonDimension: {},\n    };\n    let count = 0;\n    let subcomponentscount = 0;\n    let commondimensioncount = 0;\n    // for every component at this level\n    for (let componentname in components) {\n        count++;\n        // isolate the node...\n        let node = components[componentname];\n        let nodeSummaries = null;\n        // remove any previous aggregations...\n        if (node.years) {\n            delete node.years;\n        }\n        if (node.CommonDimension) {\n            delete node.CommonDimension;\n            delete node.SortedCommonDimension;\n        }\n        // for non-baseline baselineItems, recurse to collect aggregations\n        if (!node.Baseline) {\n            // if no components found, loop\n            if (node.Components) {\n                subcomponentscount++;\n                let sorted = getIndexSortedComponentItems(node.Components, lookups);\n                node.SortedComponents = sorted;\n                // get child node summaries recursively\n                nodeSummaries = getNodeSummaries(node, baselineItems, lookups);\n                if (nodeSummaries.CommonDimension) {\n                    commondimensioncount++;\n                }\n                node.ComponentsDrilldown = nodeSummaries.Drilldown;\n                setNodeSummaries(node, nodeSummaries, lookups);\n            }\n            // for baseline baselineItems, fetch the baseline amounts from the dataseries itemlist\n        } else {\n            // fetch the data from the dataseries itemlist\n            let importitem = baselineItems[componentname];\n            if (!importitem) {\n                console.log(\'failed to find dataset item to match viewpoint baseline:\', componentname);\n                nodeSummaries = null;\n            } else {\n                nodeSummaries = {\n                    years: importitem.years,\n                    CommonDimension: importitem.CommonDimension\n                };\n            }\n            // capture data for chart-making\n            if (node.Components) {\n                delete node.SortedComponents;\n                delete node.Components;\n            }\n            if (importitem) {\n                // there is data; transfer it to the viewpoint node\n                if (importitem.years) {\n                    node.years = importitem.years;\n                }\n                if (importitem.CommonDimension) {\n                    commondimensioncount++;\n                    node.CommonDimension = importitem.CommonDimension;\n                }\n                if (importitem.SortedCommonDimension) {\n                    node.SortedCommonDimension = importitem.SortedCommonDimension;\n                }\n                if (importitem.Components) {\n                    subcomponentscount++;\n                    node.Components = importitem.Components;\n                }\n                if (importitem.SortedComponents) {\n                    node.SortedComponents = importitem.SortedComponents;\n                }\n                if (importitem.ComponentsDrilldown) {\n                    node.ComponentsDrilldown = importitem.ComponentsDrilldown;\n                }\n                if (importitem.CommonDimensionDrilldown) {\n                    node.CommonDimensionDrilldown = importitem.CommonDimensionDrilldown;\n                }\n            }\n            if (node.Components && !node.SortedComponents) {\n                let sorted = getNameSortedComponentItems(node.Components, lookups);\n                node.SortedComponents = sorted;\n            }\n            if (node.CommonDimension && !node.SortedCommonDimension) {\n                let sorted = getNameSortedComponentItems(node.CommonDimension, lookups);\n                node.SortedCommonDimension = sorted;\n            }\n        }\n        // aggregate the collected summaries for the caller\n        if (nodeSummaries) {\n            incrementAggregator(aggregator, nodeSummaries);\n        }\n    }\n    let drilldown;\n    if (subcomponentscount == 0 && commondimensioncount == 0) {\n        drilldown = \'None\';\n    } else if (subcomponentscount == count || commondimensioncount == count) {\n        drilldown = \'All\';\n    } else {\n        drilldown = \'Some\';\n    }\n    aggregator.Drilldown = drilldown;\n    return aggregator;\n};\nconst setNodeSummaries = (node, nodeSummaries, lookups) => {\n    // capture data for chart-making\n    if (nodeSummaries.years) {\n        node.years = nodeSummaries.years;\n    }\n    if (nodeSummaries.CommonDimension) {\n        node.CommonDimension = nodeSummaries.CommonDimension;\n        if (node.CommonDimension) {\n            let sorted = getNameSortedComponentItems(node.CommonDimension, lookups);\n            node.SortedCommonDimension = sorted;\n        }\n    }\n};\n// -----------------------[ RETURN SORTED COMPONENT LIST ]------------------------\nconst getIndexSortedComponentItems = (components, lookups) => {\n    let sorted = [];\n    let taxonomylookups = lookups.taxonomylookups;\n    for (let componentcode in components) {\n        let component = components[componentcode];\n        let baseline = !!component.Baseline; // config = component.NamingConfigRef\n        let name = baseline // (config == \'BASELINE\')\n        ? lookups.baselinelookups[componentcode] : taxonomylookups[componentcode];\n        let item = {\n            Code: componentcode,\n            Index: component.Index,\n            Name: name || componentcode // \'unknown name\'\n        };\n        component.Name = name || componentcode; // \'unknown name\'\n        sorted.push(item);\n    }\n    sorted.sort((a, b) => {\n        let value;\n        if (a.Index < b.Index) value = -1;else if (a.Index > b.Index) value = 1;else value = 0;\n        return value;\n    });\n    return sorted;\n};\nconst getNameSortedComponentItems = (components, lookups) => {\n    let sorted = [];\n    let complookups = lookups.commonDimensionLookups;\n    for (let componentname in components) {\n        let component = components[componentname];\n        // let config = component.NamingConfigRef\n        let name = complookups[componentname];\n        let item = {\n            Code: componentname,\n            Name: name || \'unknown name\'\n        };\n        component.Name = name || \'unknown name\';\n        sorted.push(item);\n    }\n    sorted.sort((a, b) => {\n        let value;\n        if (a.Name < b.Name) value = -1;else if (a.Name > b.Name) value = 1;else value = 0;\n        return value;\n    });\n    return sorted;\n};\n// -----------------------[ SUMMARIZE COMPONENT DATA ]-----------------------\n// summarize the componentSummaries into the (parent) aggregator\nconst incrementAggregator = (aggregator, componentSummaries) => {\n    // if years have been collected, add them to the total\n    if (componentSummaries.years) {\n        let years = componentSummaries.years;\n        // for each year...\n        for (let yearname in years) {\n            let yearvalue = years[yearname];\n            if (!aggregator.years) {\n                aggregator.years = {};\n            }\n            // accumulate the value...\n            if (aggregator.years[yearname]) aggregator.years[yearname] += yearvalue;else aggregator.years[yearname] = yearvalue;\n        }\n    }\n    // if CommonDimension have been collected, add them to the totals\n    if (componentSummaries.CommonDimension) {\n        let CommonDimension = componentSummaries.CommonDimension;\n        if (!aggregator.CommonDimension) {\n            aggregator.CommonDimension = {};\n        }\n        // for each aggreate...\n        for (let commonDimensionName in CommonDimension) {\n            let commonDimension = CommonDimension[commonDimensionName];\n            // for each category year...\n            // collect year values for the CommonDimension if they exist\n            if (commonDimension.years) {\n                let years = commonDimension.years;\n                for (let yearname in years) {\n                    // accumulate the year value...\n                    let yearvalue = years[yearname];\n                    let cumulatingCommonDimension = aggregator.CommonDimension[commonDimensionName] || { years: {} };\n                    if (cumulatingCommonDimension.years[yearname]) {\n                        cumulatingCommonDimension.years[yearname] += yearvalue;\n                    } else {\n                        cumulatingCommonDimension.years[yearname] = yearvalue;\n                    }\n                    // re-assemble\n                    aggregator.CommonDimension[commonDimensionName] = cumulatingCommonDimension;\n                }\n            }\n        }\n    }\n};\n/* harmony default export */ var setviewpointdata = (setViewpointData);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/databaseapi.tsx\n// databaseapi.tsx\n// TEMPORARY DATA SOURCES\n// data sources\n// deepclone = JSON.parse(JSON.stringify(obj)) // but this destroys dates, undefined, and functions\n/*\n    TODO:\n        add spinner for progress\n        add cache for all fetch elements\n*/\n\n// -----------------------[ collect the data ]------------------------------\nconst delay = ms => // for testing!\nnew Promise(resolve => setTimeout(resolve, ms));\n// =====================================[ CLASS DECLARATION ]==================================\nclass databaseapi_Database {\n    constructor() {\n        this.dbroot = \'/db/repositories/\';\n        this.datasetsubpath = \'json/\';\n        this.lookupssubpath = \'lookups/\';\n    }\n    getProrataData(parms) {\n        let { repository, prorataseries } = parms;\n        let promise = new Promise((resolve, error) => {\n            let spec = this.dbroot + repository.toLowerCase() + \'/dataseries/\' + prorataseries.toLowerCase() + \'.json\';\n            // console.log(\'fetching\', spec)\n            fetch(spec).then(prorataseries => {\n                return prorataseries.json();\n            }).then(prorataseries => {\n                // console.log(\'prorataseries returned\', prorataseries)\n                resolve(prorataseries);\n            }).catch(reason => {\n                console.log(\'get prorataseries error\', reason);\n                error(reason);\n            });\n            // resolve(series)\n        });\n        return promise;\n    }\n    // getViewpointData returns a promise.\n    getViewpointData(parms) {\n        // console.log(\'getViewpointData parms\',parms)\n        this.viewpointDataParms = parms;\n        let { viewpointName, versionName, datasetName, inflationAdjusted } = parms;\n        let viewpointDataTemplatePromise = this.getViewpointTemplatePromise(viewpointName),\n            datasetDataPromise = this.getDatasetPromise(versionName, datasetName),\n            lookupsPromise = this.getLookupsPromise(versionName),\n            datasetConfigPromise = this.getDatasetConfigPromise(versionName, datasetName);\n        let promise = new Promise((resolve, error) => {\n            Promise.all([viewpointDataTemplatePromise, datasetDataPromise, lookupsPromise, datasetConfigPromise]).then(values => {\n                let viewpointDataTemplate;\n                let datasetData;\n                let lookups;\n                let datasetConfig;\n                // calculate all compatible data together, cached\n                [viewpointDataTemplate, datasetData, lookups, datasetConfig] = values;\n                viewpointDataTemplate.Meta.datasetConfig = datasetConfig; // TODO try to avoid this\n                let setparms = {\n                    datasetName,\n                    inflationAdjusted,\n                    viewpointDataTemplate,\n                    datasetData,\n                    lookups\n                };\n                this.calculateViewpointData(setparms);\n                viewpointDataTemplate = setparms.viewpointDataTemplate;\n                resolve(viewpointDataTemplate);\n            }).catch(reason => {\n                console.log(reason);\n                // error(reason)\n            });\n        });\n        return promise;\n    }\n    // TODO: use local cache\n    calculateViewpointData(parms) {\n        setviewpointdata(parms);\n    }\n    // -------------------------[ promises to collect data ]---------------------\n    getViewpointTemplatePromise(viewpoint) {\n        let promise = new Promise((resolve, error) => {\n            let path = this.dbroot + this.viewpointDataParms.repository.toLowerCase() + \'/viewpoints/\' + viewpoint.toLowerCase() + \'.json\';\n            fetch(path).then(viewpoint => {\n                return viewpoint.json();\n            }).then(viewpointdata => {\n                resolve(viewpointdata);\n            }).catch(reason => {\n                console.log(\'get viewpoint template error\', reason);\n                error(reason);\n            });\n        });\n        return promise;\n    }\n    // internal promise for dataset config\n    // TODO: get this from meta subdir\n    getDatasetConfigPromise(versionName, datasetName) {\n        let datasetpromise = this.getDatasetPromise(versionName, datasetName);\n        let promise = new Promise(resolve => {\n            datasetpromise.then(datasetdata => {\n                let metaData = datasetdata.MetaData;\n                let { Headers, Notes, Allocations, Messages } = datasetdata;\n                let Sources = {\n                    Headers,\n                    Notes,\n                    Allocations,\n                    Messages\n                };\n                let { DatasetName, YearsRange, DatasetTitle, Dataseries, DimensionNames, CellTitles, Units, UnitsAlias, UnitRatio, CommonDimension, InflationAdjustable, InflationReferenceYear } = metaData;\n                let config = {\n                    DatasetName,\n                    YearsRange,\n                    DatasetTitle,\n                    Dataseries,\n                    DimensionNames,\n                    CellTitles,\n                    Units,\n                    UnitsAlias,\n                    UnitRatio,\n                    CommonDimension,\n                    InflationAdjustable,\n                    InflationReferenceYear,\n                    Sources\n                };\n                resolve(config);\n            });\n        });\n        return promise;\n    }\n    getDatasetPromise(versionName, datasetName) {\n        let promise = new Promise((resolve, error) => {\n            let path = this.dbroot + this.viewpointDataParms.repository.toLowerCase() + \'/datasets/\' + versionName.toLowerCase() + \'/\' + this.datasetsubpath + datasetName.toLowerCase() + \'.json\';\n            fetch(path).then(dataset => {\n                return dataset.json();\n            }).then(dataset => {\n                resolve(dataset);\n            }).catch(reason => {\n                console.log(\'get dataset error\', reason);\n                // error(reason)\n            });\n        });\n        return promise;\n    }\n    getLookupsPromise(version = undefined) {\n        let promise = new Promise((resolve, error) => {\n            let path = this.dbroot + this.viewpointDataParms.repository.toLowerCase() + \'/datasets/\' + version.toLowerCase() + \'/\' + this.lookupssubpath + \'lookups.json\';\n            fetch(path).then(lookups => {\n                return lookups.json();\n            }).then(lookups => {\n                resolve(lookups);\n            }).catch(reason => {\n                console.log(\'get lookups error\', reason);\n                // error(reason)\n            });\n        });\n        return promise;\n    }\n}\nconst database = new databaseapi_Database();\n/* harmony default export */ var databaseapi = (database);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/cell.class.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// budgetcell.tsx\n/*\n\nTitle components:\n- Node meta category\n- Node cagegory\n- YearsRange\n- Total (for one year charts)\n- Inflation adjustment\n\nVertical axis:\n- Metric (qualifier)\n\nHorizontal access:\n- Dimension\n\n*/\n\n\n\nvar cell_class_format = __webpack_require__(1139);\nclass cell_class_BudgetCell {\n    constructor(specs) {\n        this.chartSelection = null; // interpreted by explorer; the logical row of the selection (per Sorted... lists)\n        // ========================[ METHODS ]==========================\n        // reset the visible element selection (if any) on the current chart\n        // google charts clear the selection on blur, must be re-instated after each\n        // operation\n        // called after animation, on mount, and after update\n        this.refreshSelection = () => {\n            let budgetCell = this;\n            // console.log(\'budgetCell.chartSelection\',budgetCell.chartSelection, budgetCell)\n            if (budgetCell.chartSelection !== null) {\n                if (budgetCell.chart && budgetCell.chart.getSelection().length == 0) {\n                    let selectionObj = { row: null, column: null };\n                    let chartSelection = [selectionObj];\n                    // console.log(\'chartSelection\',chartSelection)\n                    switch (budgetCell.googleChartType) {\n                        case "PieChart":\n                            selectionObj.row = budgetCell.chartSelection;\n                            break;\n                        case "ColumnChart":\n                            if (budgetCell.explorerChartCode == "DiffColumnChart") {\n                                selectionObj.row = Math.round(budgetCell.chartSelection * 2 + 1);\n                                selectionObj.column = 2;\n                                // console.log(\'set diffcolumnchart selection\',selectionObj)\n                            } else {\n                                selectionObj.row = budgetCell.chartSelection;\n                                selectionObj.column = 1; // ?\n                            }\n                            break;\n                        case "LineChart":\n                        case "AreaChart":\n                            selectionObj.column = budgetCell.chartSelection + 1;\n                            break;\n                        default:\n                            console.log(\'ERROR: default invoked in refreshSelection\');\n                            break;\n                    }\n                    budgetCell.chart.setSelection(chartSelection);\n                }\n            }\n        };\n        this.switchChartCode = () => {\n            this.setChartParms();\n        };\n        this.switchYearScope = () => {\n            this.setChartParms();\n        };\n        // ----------------------[ setChartParms ]-------------------------\n        this.prorataControls = {\n            prorataindex: null,\n            yearsselector: null,\n            isprorata: null,\n            proratastring: null\n        };\n        // creates formal input parameters for google charts, through Chart Component\n        // dataset is a data tree fetched from database\n        // dataseries is a list of data rows attached to a node\n        this.setChartParms = () => {\n            let budgetCell = this;\n            // --------------[ Unpack data bundles ]-------------\n            let { viewpointNamingConfigs, datasetConfig, isInflationAdjusted, prorata } = budgetCell.viewpointConfigPack;\n            let { treeNodeData, yearsRange } = budgetCell.nodeDataPack;\n            // ---------------------[ get data node components ]------------------\n            // collect chart node and its components as data sources for the graph\n            if (!treeNodeData) {\n                console.error(\'System Error: node not found in setChartParms\', budgetCell);\n                throw Error(\'node not found\');\n            }\n            let { prorataControls } = budgetCell;\n            prorataControls.prorataindex = prorata;\n            if (prorata == \'OFF\') {\n                prorataControls.isprorata = false;\n                prorataControls.yearsselector = \'years\';\n                prorataControls.proratastring = null;\n            } else {\n                prorataControls.isprorata = true;\n                prorataControls.yearsselector = \'calcyears\';\n                let thestring;\n                switch (prorata) {\n                    case "PERPERSON":\n                        thestring = \'per resident\';\n                        break;\n                    case "PER100000PERSONS":\n                        thestring = \'per 100,000 people\';\n                        break;\n                    case "PERHOUSEHOLD":\n                        thestring = \'per household\';\n                        break;\n                    case "PER40000HOUSEHOLDS":\n                        thestring = \'per 40,000 households\';\n                        break;\n                    case "PERWARD":\n                        thestring = \'per ward (average)\';\n                        break;\n                    case "PERNEIGHBOURHOOD":\n                        thestring = \'per neighbourhood (average)\';\n                        break;\n                    default:\n                        console.error(\'unknown prorataindex in _doProRataCalc\', prorata);\n                        return;\n                }\n                prorataControls.proratastring = thestring;\n            }\n            // ====================[ COLLECT CHART PARMS ]======================\n            // ------------------\n            // 1. chart type:\n            // ------------------\n            let chartType = budgetCell.googleChartType;\n            // ------------------\n            // 2. chart options:\n            // ------------------\n            let options = budgetCell._chartParmsOptions(treeNodeData, viewpointNamingConfigs, datasetConfig, yearsRange);\n            // ------------------\n            // 3. chart events:\n            // ------------------\n            let events = budgetCell._chartParmsEvents();\n            // ------------------\n            // 4. chart columns:\n            // ------------------\n            let columns = null; // = budgetCell._chartParmsColumns(yearsRange, treeNodeData)\n            // ------------------\n            // 5. chart rows:\n            // ------------------\n            let { nodeDataseriesName } = budgetCell;\n            let sortedlistName = \'Sorted\' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            let explorerChartCode = this.explorerChartCode;\n            let rows = null;\n            let diffdata = null;\n            switch (explorerChartCode) {\n                // ------------------\n                // 5. diff data:\n                // ------------------\n                case "DiffColumnChart":\n                case "DiffPieChart":\n                    {\n                        // console.log(\'processing chart code\',explorerChartCode)\n                        let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n                        let leftcolumns = budgetCell._columns_diffChart(yearsRange, leftYear);\n                        let rightcolumns = budgetCell._columns_diffChart(yearsRange, rightYear);\n                        diffdata = this._chartParmsDiffData(treeNodeData, yearsRange);\n                        diffdata.old.splice(0, 0, leftcolumns);\n                        diffdata.new.splice(0, 0, rightcolumns);\n                        if (explorerChartCode == "DiffPieChart") {\n                            options.diff = {\n                                innerCircle: { radiusFactor: 0.5 }\n                            };\n                            options.pieSliceText = \'percentage\';\n                            options.pieHole = null;\n                        }\n                        // console.log( \'diffdata\', diffdata, options)\n                        break;\n                    }\n                default:\n                    {\n                        columns = budgetCell._chartParmsColumns(yearsRange, treeNodeData);\n                        // code...\n                        if (sortedDataseries) {\n                            rows = budgetCell._chartParmsRows(treeNodeData, yearsRange);\n                        } else {\n                            // fires on last chart\n                            console.error(\'System Error: no sortedDataSeries\', sortedlistName, sortedDataseries, treeNodeData);\n                            return;\n                        }\n                    }\n            }\n            // --------------------[ ASSEMBLE PARMS PACK ]----------------\n            let chartParms = {\n                chartType,\n                options,\n                events,\n                columns,\n                rows,\n                diffdata\n            };\n            this.chartParmsObject = chartParms;\n            // console.log(\'chartParms\',chartParms)\n            // save it\n            this.setState({\n                chartParms\n            });\n        };\n        // ===========================================================================\n        // 2. chart options:\n        // ===========================================================================\n        this._chartParmsOptions = (treeNodeData, viewpointNamingConfigs, datasetConfig, yearsRange) => {\n            // ----------------------[ assemble support variables ]-------------------\n            let budgetCell = this;\n            let { aspectName, nodeDataseriesName } = budgetCell;\n            let datasetName = constants["a" /* AspectNameToDatasetName */][aspectName];\n            let units = datasetConfig.Units;\n            // --------------------[ assemble vertical label value ]--------------------\n            let calcAlias;\n            if (budgetCell.prorataControls.isprorata) {\n                calcAlias = datasetConfig.CalcUnitsAlias;\n            }\n            let verticalLabel = calcAlias || datasetConfig.UnitsAlias || datasetConfig.Units;\n            verticalLabel = datasetConfig.DatasetName + \' (\' + verticalLabel + \')\';\n            // -------------------[ assemble horizontal label value ]--------------------\n            let horizontalLabel = null;\n            if (treeNodeData.NamingConfigRef && nodeDataseriesName != \'CommonDimension\') {\n                let titleref = viewpointNamingConfigs[treeNodeData.NamingConfigRef];\n                horizontalLabel = titleref.Contents.Alias || titleref.Contents.Name;\n            } else {\n                if (nodeDataseriesName == \'CommonDimension\') {\n                    let contentdimensionname = datasetConfig.CommonDimension;\n                    let names = datasetConfig.DimensionNames;\n                    horizontalLabel = names[contentdimensionname].Collection;\n                } else {\n                    let contentdimensionname = treeNodeData.ComponentsDimensionName;\n                    let names = datasetConfig.DimensionNames;\n                    horizontalLabel = names[contentdimensionname].Collection;\n                }\n            }\n            // ----------------------[ assemble chart title ]----------------------\n            // TODO: report reason for \'unknown category\'\n            // set basic title\n            let nodename = null;\n            if (treeNodeData.Name) {\n                nodename = treeNodeData.Name;\n            } else {\n                nodename = datasetConfig.DatasetTitle;\n            }\n            // add category name\n            let configindex = treeNodeData.NamingConfigRef;\n            let catname = null;\n            if (configindex) {\n                // viewpoint node\n                let names = viewpointNamingConfigs[configindex];\n                let instancenames = names.Instance;\n                catname = instancenames.Alias || instancenames.Name;\n            } else {\n                // sub-baseline dataset node\n                let { nodeDataPack } = this;\n                if (nodeDataPack.parentBudgetNode && nodeDataPack.parentBudgetNode.treeNodeData) {\n                    let { parentBudgetNode } = nodeDataPack;\n                    let parentconfigindex = parentBudgetNode.treeNodeData.NamingConfigRef;\n                    // first level below depends in parentconfigindex\n                    if (parentconfigindex) {\n                        let names = viewpointNamingConfigs[parentconfigindex];\n                        if (names && names.Contents && names.Contents.DefaultInstance) {\n                            catname = names.Contents.DefaultInstance.Name;\n                            if (!catname) {\n                                console.log(\'category name not found in names.Contents.DefaultInstance.Name\', parentconfigindex, viewpointNamingConfigs);\n                            }\n                        }\n                        // lower levels depend on dimension category names.\n                    } else {\n                        let nameindex = nodeDataseriesName;\n                        if (nameindex == \'Components\') {\n                            nameindex += \'DimensionName\';\n                        } else if (nameindex == \'CommonDimension\') {\n                            nameindex += \'Name\';\n                        } else {\n                            console.error(\'nodeDataseriesName not found for \', this);\n                        }\n                        let dimensionname = parentBudgetNode.treeNodeData[nameindex];\n                        catname = datasetConfig.DimensionNames[dimensionname].Instance;\n                        if (!catname) {\n                            console.log(\'category name not found in datasetConfig.DimensionNames[dimensionname].Instance\', datasetConfig);\n                        }\n                    }\n                }\n                if (!catname) {\n                    catname = \'(** Unknown Category **)\';\n                }\n            }\n            let title = catname + \': \' + nodename;\n            // add yearspan to title\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { yearScope } = cellDeclaration;\n            let timeSuffix = null;\n            if (yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear]) {\n                timeSuffix = rightYear.toString();\n            } else {\n                let separator;\n                if (yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].TwoYears]) {\n                    separator = \':\';\n                } else {\n                    // must be AllYears\n                    separator = \' - \';\n                }\n                timeSuffix = leftYear + separator + rightYear;\n            }\n            timeSuffix = \', \' + timeSuffix;\n            title += timeSuffix;\n            // add title amount\n            if (yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear]) {\n                let titleamount = null;\n                // utility functions for number formatting\n                let dollarformat = cell_class_format({ prefix: "$" });\n                let rounded = cell_class_format({ round: 0, integerSeparator: \'\' });\n                let simpleroundedone = cell_class_format({ round: 1, integerSeparator: \',\' });\n                let yearsselector = budgetCell.prorataControls.yearsselector;\n                if (treeNodeData[yearsselector]) {\n                    titleamount = treeNodeData[yearsselector][rightYear];\n                    if (units == \'DOLLAR\') {\n                        titleamount = dollarformat(titleamount);\n                    } else {\n                        titleamount = simpleroundedone(titleamount);\n                    }\n                    if (!titleamount) titleamount = \'nil\';\n                    title += \' (Total: \' + titleamount + \')\';\n                }\n            }\n            // add inflation adjustment indicator if appropriate\n            if (datasetConfig.InflationAdjustable) {\n                if (!(yearScope == constants["d" /* TimeScope */][constants["d" /* TimeScope */].OneYear] && datasetConfig.InflationReferenceYear <= rightYear)) {\n                    let isInflationAdjusted = this.viewpointConfigPack.isInflationAdjusted;\n                    let fragment;\n                    if (!isInflationAdjusted) {\n                        fragment = \' -- nominal $\';\n                    } else {\n                        fragment = ` -- inflation adjusted to ${datasetConfig.InflationReferenceYear} $`;\n                    }\n                    title += fragment;\n                }\n            }\n            if (budgetCell.prorataControls.isprorata) {\n                title += \'; \' + budgetCell.prorataControls.proratastring;\n            }\n            // ------------------------------[ assemble options ]--------------------------------\n            let options = {\n                animation: {\n                    startup: true,\n                    duration: 500,\n                    easing: \'out\'\n                },\n                title,\n                vAxis: {\n                    title: verticalLabel,\n                    minValue: 0,\n                    textStyle: {\n                        fontSize: 8\n                    }\n                },\n                hAxis: {\n                    title: horizontalLabel,\n                    textStyle: {\n                        fontSize: 10\n                    }\n                },\n                bar: {\n                    groupWidth: "95%"\n                },\n                // width: children.length * 120,// 120 per column\n                height: "400px",\n                width: "400px",\n                diff: null,\n                pieHole: null,\n                pieSliceText: null\n            };\n            let options_extension = budgetCell._chartTypeOptions(budgetCell.googleChartType, treeNodeData);\n            options = Object.assign(options, options_extension);\n            return options;\n        };\n        this._chartTypeOptions = (googleChartType, treeNodeData) => {\n            let options;\n            switch (googleChartType) {\n                case "ColumnChart":\n                    options = {\n                        legend: \'none\',\n                        chartArea: {\n                            height: \'50%\',\n                            top: \'15%\',\n                            left: \'25%\',\n                            width: \'70%\'\n                        }\n                    };\n                    break;\n                case "PieChart":\n                    {\n                        options = this._pieChartOptions(treeNodeData);\n                        break;\n                    }\n                case "AreaChart":\n                    {\n                        options = {\n                            isStacked: true\n                        };\n                        if (this.explorerChartCode == "Proportional") {\n                            options.isStacked = \'percent\';\n                        }\n                    }\n                case "LineChart":\n                    {\n                        if (!options) options = {};\n                        options.legend = {\n                            position: "top",\n                            textStyle: {\n                                fontSize: 9\n                            },\n                            maxLines: 4\n                        };\n                        options.chartArea = {\n                            height: \'55%\',\n                            top: \'30%\',\n                            left: \'auto\',\n                            width: \'auto\'\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        options = {};\n                    }\n            }\n            return options;\n        };\n        this._pieChartOptions = treeNodeData => {\n            let budgetCell = this;\n            // let cellDeclaration = this.cellDeclaration\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { nodeDataseriesName } = budgetCell;\n            let nodeDataseries = treeNodeData[nodeDataseriesName];\n            let sortedlistName = \'Sorted\' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            if (!sortedDataseries) {\n                console.error({\n                    errorMessage: \'sorted list "\' + sortedlistName + \'" not available\'\n                });\n                throw Error(\'sorted list "\' + sortedlistName + \'" not available\');\n            }\n            let sliceslist = sortedDataseries.map(sortedItem => {\n                let componentItem = nodeDataseries[sortedItem.Code];\n                if (!componentItem) {\n                    console.error(\'System Error: component not found for (node, sortedlistName, nodeDataseries, item, item.Code) \', treeNodeData, sortedlistName, nodeDataseries, sortedItem.Code, sortedItem);\n                    throw Error(\'componentItem not found\');\n                }\n                let offset = !(componentItem.Components || componentItem.CommonDimension) ? 0.2 : 0;\n                return offset;\n            });\n            let slices = {};\n            for (let index in sliceslist) {\n                slices[index] = { offset: sliceslist[index] };\n                if (slices[index].offset != 0) {\n                    slices[index].color = ColorBrightness(constants["c" /* GoogleChartColors */][index], 120);\n                    slices[index].offset = 0; // I changed my mind about having an offset; now just a proxy for no drilldown\n                }\n            }\n            let options = {\n                slices,\n                pieHole: 0.4,\n                // is3D: true,\n                legend: {\n                    position: "top",\n                    textStyle: {\n                        fontSize: 9\n                    },\n                    maxLines: 4\n                },\n                chartArea: {\n                    height: \'55%\',\n                    top: \'30%\',\n                    left: \'auto\',\n                    width: \'auto\'\n                }\n            };\n            return options;\n        };\n        // ===========================================================================\n        // 3. chart events:\n        // ===========================================================================\n        this._chartParmsEvents = () => {\n            let budgetCell = this;\n            return [{\n                eventName: \'select\',\n                callback: (Chart, err) => {\n                    let chart = Chart.chart;\n                    let selection = chart.getSelection();\n                    let chartSelectionData = {\n                        selection,\n                        err\n                    };\n                    budgetCell.selectionCallback(chartSelectionData);\n                }\n            }, {\n                eventName: \'animationfinish\',\n                callback: (cell => Chart => {\n                    let selection = Chart.chart.getSelection();\n                    if (selection.length == 0 && cell.chartSelection !== null) {\n                        if (cell.chart) {\n                            cell.refreshSelection();\n                        }\n                    }\n                })(budgetCell)\n            }];\n        };\n        // ===========================================================================\n        // 4. chart columns:\n        // ===========================================================================\n        this._chartParmsColumns = (yearsRange, treeNodeData) => {\n            let budgetCell = this;\n            let { googleChartType } = budgetCell;\n            switch (googleChartType) {\n                case "ColumnChart":\n                    return this._columns_ColumnChart(yearsRange);\n                case "PieChart":\n                    return this._columns_PieChart(yearsRange);\n                case \'LineChart\':\n                case \'AreaChart\':\n                    return this._columns_LineChart(treeNodeData);\n                default:\n                    return null;\n            }\n        };\n        this._columns_LineChart = treeNodeData => {\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let budgetCell = this;\n            let columns = [\n            // type is required, else throws silent error\n            { type: \'string\', label: \'Year\' }];\n            let chartDimensionType = this.nodeDataseriesName;\n            let listName = \'Sorted\' + chartDimensionType;\n            let list = treeNodeData[listName];\n            for (let listindex in list) {\n                columns.push({ type: \'number\', label: list[listindex].Name });\n            }\n            return columns;\n        };\n        this._columns_ColumnChart = yearsRange => {\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let budgetCell = this;\n            let categorylabel = \'Component\'; // placeholder\n            let columns = [\n            // type is required, else throws silent error\n            { type: \'string\', label: categorylabel }, { type: \'number\', label: rightYear.toString() }, { type: \'string\', role: \'style\' }];\n            return columns;\n        };\n        this._columns_diffChart = (yearsRange, year) => {\n            let cellDeclaration = this.cellDeclaration;\n            // let { rightYear, leftYear} = this.nodeDataPack.yearSelections\n            let budgetCell = this;\n            let categorylabel = \'Component\'; // placeholder\n            let columns = [\n            // type is required, else throws silent error\n            { type: \'string\', label: categorylabel }, { type: \'number\', label: year.toString() }];\n            return columns;\n        };\n        this._columns_PieChart = yearsRange => {\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let budgetCell = this;\n            let categorylabel = \'Component\'; // placeholder\n            let columns = [\n            // type is required, else throws silent error\n            { type: \'string\', label: categorylabel }, { type: \'number\', label: rightYear.toString() }];\n            return columns;\n        };\n        // ===========================================================================\n        // 5. chart rows:\n        // ===========================================================================\n        this._chartParmsRows = (treeNodeData, yearsRange) => {\n            let budgetCell = this;\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { nodeDataseriesName } = budgetCell;\n            let nodeDataseries = treeNodeData[nodeDataseriesName];\n            let sortedlistName = \'Sorted\' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            if (!sortedDataseries) {\n                console.error({\n                    errorMessage: \'sorted list "\' + sortedlistName + \'" not available\'\n                });\n                throw Error(\'sorted list "\' + sortedlistName + \'" not available\');\n            }\n            switch (budgetCell.googleChartType) {\n                case "PieChart":\n                case "ColumnChart":\n                    {\n                        let { googleChartType: chartType } = budgetCell;\n                        let rows = this._getYearRows(sortedDataseries, nodeDataseries, rightYear, chartType);\n                        return rows;\n                    }\n                case "LineChart":\n                case "AreaChart":\n                    return this._LineChartRows(treeNodeData, sortedDataseries, yearsRange);\n            }\n        };\n        this._chartParmsDiffData = (treeNodeData, yearsRange) => {\n            let budgetCell = this;\n            let diffdata = {\n                old: null,\n                new: null\n            };\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { nodeDataseriesName } = budgetCell;\n            let nodeDataseries = treeNodeData[nodeDataseriesName];\n            let sortedlistName = \'Sorted\' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            if (!sortedDataseries) {\n                console.error({\n                    errorMessage: \'sorted list "\' + sortedlistName + \'" not available\'\n                });\n                throw Error(\'sorted list "\' + sortedlistName + \'" not available\');\n            }\n            let chartType = this.explorerChartCode;\n            let rows;\n            diffdata.new = this._getYearRows(sortedDataseries, nodeDataseries, rightYear, chartType);\n            diffdata.old = this._getYearRows(sortedDataseries, nodeDataseries, leftYear, chartType);\n            return diffdata;\n        };\n        this._getYearRows = (sortedDataseries, nodeDataseries, year, chartType) => {\n            let budgetCell = this;\n            let rows = sortedDataseries.map(sortedItem => {\n                let componentItem = nodeDataseries[sortedItem.Code];\n                if (!componentItem) {\n                    console.error(\'System Error: component not found for (node, sortedlistName, nodeDataseries, item, item.Code) \', nodeDataseries, sortedItem.Code, sortedItem);\n                    throw Error(\'componentItem not found\');\n                }\n                let yearsselector = budgetCell.prorataControls.yearsselector;\n                let amount;\n                // amount cannot be null or undefined; causes diff charts to fail\n                if (componentItem[yearsselector]) {\n                    amount = componentItem[yearsselector][year];\n                    if (amount === undefined) amount = 0;\n                } else {\n                    amount = 0;\n                }\n                let row = [sortedItem.Name, amount];\n                // enhance row\n                switch (chartType) {\n                    case "ColumnChart":\n                        row = budgetCell._rows_ColumnCharts_row(row, componentItem);\n                        break;\n                }\n                return row;\n            });\n            return rows;\n        };\n        this._LineChartRows = (treeNodeData, sortedDataSeries, yearsRange) => {\n            let rows = [];\n            let budgetCell = this;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let yearsselector = budgetCell.prorataControls.yearsselector;\n            for (let year = leftYear; year <= rightYear; year++) {\n                let items = sortedDataSeries.map(sortedItem => {\n                    let amount = null;\n                    let years = treeNodeData[this.nodeDataseriesName][sortedItem.Code][yearsselector];\n                    if (years && years[year] !== undefined) {\n                        amount = years[year];\n                    }\n                    return amount;\n                });\n                let row = [year.toString(), ...items];\n                rows.push(row);\n            }\n            return rows;\n        };\n        this._rows_ColumnCharts_row = (row, componentItem) => {\n            let style = \'\';\n            if (componentItem.Baseline) {\n                style = \'stroke-color: Gold; stroke-width: 3;\';\n            }\n            if (!(componentItem.Components || componentItem.CommonDimension)) {\n                style += \'fill-color: #3366CC;fill-opacity:0.5;\';\n            }\n            row.push(style);\n            return row;\n        };\n        this.getDataTable = () => {\n            // console.log(\'chartParms\',this.chartParmsObject)\n            let { chartType, columns, rows, diffdata, options } = this.chartParmsObject;\n            let { hAxis, vAxis, title } = options;\n            let chartCode = this.explorerChartCode;\n            let tableparms = {\n                chartCode,\n                chartType,\n                chartdata: {\n                    rows,\n                    diffdata,\n                    columns,\n                    hAxis,\n                    vAxis\n                },\n                title\n            };\n            let outputparms = this._preProcessTableData(tableparms);\n            // console.log(\'outputparms\',outputparms)\n            return outputparms;\n        };\n        this._preProcessTableData = tableparms => {\n            let { chartCode, chartType } = tableparms;\n            let outputparms = {\n                chartCode,\n                chartType,\n                data: null,\n                columns: null,\n                title: null,\n                footer: null\n            };\n            // \'DonutChart\':\'PieChart\',\n            // \'ColumnChart\':\'ColumnChart\',\n            // \'DiffPieChart\':\'PieChart\',\n            // \'DiffColumnChart\':\'ColumnChart\',\n            // \'TimeLine\':\'LineChart\',\n            // \'StackedArea\':\'AreaChart\', // isStacked:\'absolute\'\n            // \'Proportional\':\'AreaChart\', // isStacked:\'percent\'\n            switch (chartCode) {\n                case "ColumnChart":\n                    outputparms = this.prepareColumnChartData(tableparms, outputparms);\n                    break;\n                case "DonutChart":\n                    outputparms = this.prepareDonutChartData(tableparms, outputparms);\n                    break;\n                case "DiffColumnChart":\n                    outputparms = this.prepareDiffColumnChartData(tableparms, outputparms);\n                    break;\n                case "DiffPieChart":\n                    outputparms = this.prepareDiffPieChartData(tableparms, outputparms);\n                    break;\n                case "TimeLine":\n                    outputparms = this.prepareTimelineData(tableparms, outputparms);\n                    break;\n                case "StackedArea":\n                    outputparms = this.prepareStackedAreaData(tableparms, outputparms);\n                    break;\n                case "Proportional":\n                    outputparms = this.prepareProportionalData(tableparms, outputparms);\n                    break;\n                default:\n                    throw \'Unknown chart type in cell.class._processTableData: \' + chartCode;\n            }\n            return outputparms;\n        };\n        // ----------- one year --------------\n        this.prepareColumnChartData = (tableparms, outputparms) => {\n            let rows = this._getOutputRows(tableparms.chartdata.rows, 2);\n            let footer = this._getOutputFooter(rows, 2);\n            let columns = [];\n            for (let n = 0; n < 2; n++) {\n                columns.push({ Header: tableparms.chartdata.columns[n].label, type: \'number\' });\n            }\n            // replace placeholder...\n            columns[0].Header = tableparms.chartdata.hAxis.title;\n            columns[0].type = \'label\';\n            let title = tableparms.title + \'. Data: \' + tableparms.chartdata.vAxis.title;\n            outputparms.data = rows;\n            outputparms.columns = columns;\n            outputparms.footer = footer;\n            outputparms.title = title;\n            return outputparms;\n        };\n        this._getOutputRows = (rows, colcount) => {\n            let newrows = [];\n            for (let row of rows) {\n                let newrow = [];\n                for (let n = 0; n < colcount; n++) {\n                    newrow.push(row[n]);\n                }\n                newrows.push(newrow);\n            }\n            return newrows;\n        };\n        this._getOutputFooter = (rows, itemcount) => {\n            let footer = [\'Total\'];\n            for (let n = 1; n < itemcount; n++) {\n                let totalamount = rows.reduce((accumulator, currentvalue) => {\n                    return currentvalue[n] ? accumulator + currentvalue[n] : accumulator;\n                }, 0);\n                footer.push(totalamount);\n            }\n            return footer;\n        };\n        this.prepareDonutChartData = (tableparms, outputparms) => {\n            outputparms = this.prepareColumnChartData(tableparms, outputparms); // same input\n            outputparms.columns.push({ Header: \'Ratio\', type: \'ratio\' });\n            let total = outputparms.footer[1];\n            if (total) outputparms.footer.push(1);else outputparms.footer.push(null);\n            for (let n = 0; n < outputparms.data.length; n++) {\n                let numerator = outputparms.data[n][1];\n                if (numerator && total) {\n                    outputparms.data[n].push(numerator / total);\n                } else {\n                    outputparms.data[n].push(null);\n                }\n            }\n            return outputparms;\n        };\n        // ----------- two yeara --------------\n        this.prepareDiffColumnChartData = (tableparms, outputparms) => {\n            let { old: olddata, new: newdata } = tableparms.chartdata.diffdata;\n            let oldrows = olddata.slice(1);\n            let oldcolumns = olddata.slice(0, 1)[0];\n            oldrows = this._getOutputRows(oldrows, 2);\n            let oldfooter = this._getOutputFooter(oldrows, 2);\n            let newrows = newdata.slice(1);\n            let newcolumns = newdata.slice(0, 1)[0];\n            newrows = this._getOutputRows(newrows, 2);\n            let newfooter = this._getOutputFooter(newrows, 2);\n            // console.log(\'oldrows, oldcolumns, newrows, newcolumns\',oldrows,oldcolumns,newrows,newcolumns)\n            let outputrows = oldrows;\n            for (let n = 0; n < newrows.length; n++) {\n                outputrows[n].push(newrows[n][1]);\n            }\n            for (let n = 0; n < outputrows.length; n++) {\n                let current = outputrows[n][2];\n                let previous = outputrows[n][1];\n                let change = null;\n                if (!isNaN(current) && !isNaN(previous)) {\n                    change = current - previous;\n                }\n                outputrows[n].push(change);\n            }\n            let footer = oldfooter;\n            footer.push(newfooter[1]);\n            let current = footer[2]; // any required to overcome ts evaluation as string type\n            let previous = footer[1];\n            let change = null;\n            if (!isNaN(current) && !isNaN(previous)) {\n                change = current - previous;\n            }\n            footer.push(change);\n            // console.log(\'outputrows\',outputrows)\n            let columns = [{ Header: tableparms.chartdata.hAxis.title, type: \'label\' }, { Header: oldcolumns[1].label, type: \'number\' }, { Header: newcolumns[1].label, type: \'number\' }, { Header: \'Change\', type: \'number\' }];\n            let title = tableparms.title + \'. Data: \' + tableparms.chartdata.vAxis.title;\n            outputparms.data = outputrows;\n            outputparms.columns = columns;\n            outputparms.footer = footer;\n            outputparms.title = title;\n            return outputparms;\n        };\n        this.prepareDiffPieChartData = (tableparms, outputparms) => {\n            outputparms = this.prepareDiffColumnChartData(tableparms, outputparms); // same input\n            let columns = outputparms.columns;\n            columns.splice(2, 0, { Header: columns[1].Header + \' Ratio\', type: \'ratio\' });\n            columns.splice(4, 0, { Header: columns[3].Header + \' Ratio\', type: \'ratio\' });\n            columns.push({ Header: \'Ratio of Change to Previous\', type: \'ratio\' }, { Header: \'Ratio of Change to Current\', type: \'ratio\' });\n            let footer = outputparms.footer;\n            let previoustotal = footer[1];\n            let currenttotal = footer[2];\n            let totalchange = footer[3];\n            footer.splice(2, 0, 1);\n            footer.splice(4, 0, 1);\n            let changetoprevious = null;\n            let changetocurrent = null;\n            if (!isNaN(totalchange)) {\n                if (!isNaN(previoustotal) && previoustotal) {\n                    changetoprevious = totalchange / previoustotal;\n                }\n                if (!isNaN(currenttotal) && currenttotal) {\n                    changetocurrent = totalchange / currenttotal;\n                }\n            }\n            footer.push(changetoprevious, changetocurrent);\n            let data = outputparms.data;\n            for (let n = 0; n < data.length; n++) {\n                let row = data[n];\n                let previousvalue = row[1];\n                let currentvalue = row[2];\n                let change = row[3];\n                let previousratio = null;\n                let currentratio = null;\n                let changetoprevious = null;\n                let changetocurrent = null;\n                if (!isNaN(previoustotal) && !isNaN(previousvalue) && previousvalue && previoustotal) {\n                    previousratio = previousvalue / previoustotal;\n                }\n                if (!isNaN(currenttotal) && !isNaN(currentvalue) && currentvalue && currenttotal) {\n                    currentratio = currentvalue / currenttotal;\n                }\n                if (!isNaN(change)) {\n                    if (!isNaN(previousvalue) && previousvalue) {\n                        changetoprevious = change / previousvalue;\n                    }\n                    if (!isNaN(currentvalue) && currentvalue) {\n                        changetocurrent = change / currentvalue;\n                    }\n                }\n                row.splice(2, 0, previousratio);\n                row.splice(4, 0, currentratio);\n                row.push(changetoprevious, changetocurrent);\n            }\n            return outputparms;\n        };\n        // ----------- all years --------------\n        this.prepareTimelineData = (tableparms, outputparms) => {\n            let title = tableparms.title + \'. Data: \' + tableparms.chartdata.vAxis.title;\n            let data = [];\n            for (let n = 0; n < tableparms.chartdata.columns.length - 1; n++) {\n                data.push([]);\n            }\n            // console.log(\'data\',data)\n            let rows = tableparms.chartdata.rows;\n            let newrows = [];\n            let columns = [];\n            for (let n = 0; n < rows.length; n++) {\n                let row = rows[n];\n                let type = \'number\';\n                columns.push({ Header: row[0], type });\n                for (let x = 1; x < row.length; x++) {\n                    data[x - 1][n] = row[x];\n                }\n            }\n            let sourcecolumns = tableparms.chartdata.columns;\n            for (let n = 1; n < sourcecolumns.length; n++) {\n                data[n - 1].splice(0, 0, sourcecolumns[n].label);\n            }\n            columns.splice(0, 0, { Header: tableparms.chartdata.hAxis.title, type: \'label\' });\n            let footer = this._getOutputFooter(data, columns.length);\n            outputparms.data = data;\n            outputparms.columns = columns;\n            outputparms.title = title;\n            outputparms.footer = footer;\n            return outputparms;\n        };\n        this.prepareStackedAreaData = (tableparms, outputparms) => {\n            outputparms = this.prepareTimelineData(tableparms, outputparms); // same data\n            return outputparms;\n        };\n        this.prepareProportionalData = (tableparms, outputparms) => {\n            outputparms = this.prepareTimelineData(tableparms, outputparms); // same input\n            let columns = outputparms.columns;\n            for (let n = columns.length; n > 1; n--) {\n                columns.splice(n, 0, { Header: columns[n - 1].Header + \' Ratio\', type: \'ratio\' });\n            }\n            let { footer, data } = outputparms;\n            for (let n = footer.length; n > 1; n--) {\n                for (let rownum = 0; rownum < data.length; rownum++) {\n                    let row = data[rownum];\n                    let numerator = row[n - 1];\n                    let denominator = footer[n - 1];\n                    let ratio = null;\n                    if (!isNaN(numerator) && !isNaN(denominator) && denominator) {\n                        ratio = numerator / denominator;\n                    }\n                    row.splice(n, 0, ratio);\n                }\n                footer.splice(n, 0, 1);\n            }\n            return outputparms;\n        };\n        let { nodeDataseriesName, chartSelection, uid } = specs;\n        this.nodeDataseriesName = nodeDataseriesName;\n        this.chartSelection = chartSelection;\n        this.uid = uid;\n    }\n    get state() {\n        return this.getState();\n    }\n    // =======================[ PROPERTIES ]============================\n    // -------------[ primary control properties, set on creation ]---------------\n    get explorerChartCode() {\n        let cellDeclaration = this.getProps().declarationData.cellsById[this.uid];\n        let settings = cellDeclaration.chartConfigs[cellDeclaration.yearScope];\n        return settings.explorerChartCode;\n    }\n    // ------------[ derivative control properties ]-------------------\n    // map from internal code to googleChartType\n    get googleChartType() {\n        return constants["b" /* ChartCodeToGoogleChartType */][this.explorerChartCode];\n    }\n    get cellDeclaration() {\n        return this.getProps().declarationData.cellsById[this.uid];\n    }\n    // current chart (can change) taken from chartComponent...\n    get chart() {\n        if (this.chartComponent) return this.chartComponent.chart; // up to date version\n        else return null;\n    }\n    // readonly; set by setChartParms()\n    // the formal parameters required by Chart Component for google chart creation\n    // private _chartParms: ChartParms\n    get chartParms() {\n        return this.getState().chartParms;\n    }\n}\n/* harmony default export */ var cell_class = (cell_class_BudgetCell);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/node.class.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// budgetnode.tsx\n\n\nclass node_class_BudgetNode {\n    constructor(parms, uid, node, parentBudgetNode = null) {\n        // let portalcharts = parms.datasetSpecs\n        this.new = true;\n        this.updated = false;\n        this.newCells = null;\n        this.parentBudgetNode = null;\n        this.updateAspect = (aspect, treeNodeData) => {\n            this.aspectName = aspect;\n            this.updateDataNode(treeNodeData);\n        };\n        this.updateDataNode = treeNodeData => {\n            this._nodeData = treeNodeData;\n            this.updated = true;\n        };\n        this.oldNodeState = {\n            hasChildren: null\n        };\n        // ====================================================================\n        // ---------------------[ PRIVATE ]------------------------------------\n        this.getCellDeclarationParms = () => {\n            let budgetNode = this;\n            let parmsList = [];\n            let datasetName = constants["a" /* AspectNameToDatasetName */][budgetNode.aspectName];\n            let chartSpecs = budgetNode.viewpointConfigPack.datasetConfig.Dataseries;\n            let node = budgetNode.treeNodeData;\n            let cellDeclarationData;\n            if (budgetNode.parentBudgetNode) {\n                let parent = this.parentBudgetNode;\n                if (parent.priorCellSettings) {\n                    cellDeclarationData = parent.priorCellSettings;\n                    parent.priorCellSettings = null;\n                } else {\n                    let parentNodeDeclaration = budgetNode.props.declarationData.nodesById[parent.uid];\n                    let cellIndex = parentNodeDeclaration.cellIndex;\n                    let parentCell = parent.cells[cellIndex];\n                    if (parentCell) {\n                        // could fail with race condition of multiple concurrent node declarations from urlparms\n                        // console.log(\'getCellDeclarationParms budgetNode\',budgetNode)\n                        let callingCellDeclaration = budgetNode.props.declarationData.cellsById[parentCell.uid];\n                        let chartConfigs = Object.assign({}, callingCellDeclaration.chartConfigs);\n                        cellDeclarationData = {\n                            yearScope: callingCellDeclaration.yearScope,\n                            chartConfigs\n                        };\n                    } else {\n                        cellDeclarationData = this.props.declarationData.defaults.cell;\n                    }\n                }\n            } else {\n                cellDeclarationData = this.props.declarationData.defaults.cell;\n            }\n            for (let chartSpec of chartSpecs) {\n                let cellDeclaration = Object.assign({}, cellDeclarationData);\n                // not only must the dataseries be mandated, but also present...\n                if (node[chartSpec.Type]) {\n                    cellDeclaration.nodeDataseriesName = chartSpec.Type;\n                    parmsList.push(cellDeclaration);\n                }\n            }\n            return parmsList;\n        };\n        this._updateCell = (cell, cellIndex) => {\n            let budgetNode = this;\n            let { viewpointConfigPack, treeNodeData, yearsRange, yearSelections, parentBudgetNode, nodeIndex } = budgetNode;\n            let nodeDataPack = {\n                treeNodeData,\n                yearsRange,\n                yearSelections,\n                parentBudgetNode,\n                budgetNode\n            };\n            cell.viewpointConfigPack = viewpointConfigPack;\n            cell.nodeDataPack = nodeDataPack;\n            cell.aspectName = budgetNode.branchSettings.aspect, budgetNode._setCellSelectionCallback(cell, cellIndex);\n            budgetNode._setCellTitle(cell);\n        };\n        this._setCellTitle = budgetCell => {\n            let portaltitles = budgetCell.viewpointConfigPack.datasetConfig.CellTitles;\n            let chartblocktitle = null;\n            if (budgetCell.nodeDataseriesName == \'CommonDimension\') {\n                chartblocktitle = portaltitles.CommonDimension;\n            } else {\n                chartblocktitle = portaltitles.Components;\n            }\n            budgetCell.cellTitle = chartblocktitle;\n        };\n        this._setCellSelectionCallback = (cell, cellIndex) => {\n            let budgetNode = this;\n            let selectfn = this.onChartComponentSelection;\n            let fcurrent = selectfn(budgetNode.nodeIndex)(cellIndex);\n            cell.selectionCallback = fcurrent;\n        };\n        this.viewpointName = parms.viewpointName;\n        this.aspectName = parms.aspectName;\n        this.dataPath = parms.dataPath;\n        this.nodeIndex = parms.nodeIndex;\n        this.yearsRange = parms.yearsRange;\n        this.yearSelections = parms.yearSelections;\n        this._nodeData = node;\n        this.uid = uid;\n        if (parentBudgetNode) this.parentBudgetNode = parentBudgetNode;\n    }\n    get treeNodeData() {\n        return this._nodeData;\n    }\n    get state() {\n        return this.getState();\n    }\n    get props() {\n        return this.getProps();\n    }\n    // treeNodeMetaDataFromParentSortedList: any = null // includes parentNode for now\n    // parentNode: any = null\n    get nodeDeclaration() {\n        return this.props.declarationData.nodesById[this.uid];\n    }\n    get cells() {\n        return [...this.state.nodeCells];\n    }\n    setCells(cellDeclarations) {\n        let cells = [];\n        // // TODO: should be default for each chart...\n        // build cells array\n        for (let cellIndex in cellDeclarations) {\n            let cellDeclaration = cellDeclarations[cellIndex];\n            // TODO: this should use cellIndex not celluid of cellDeclaration!!\n            let { nodeDataseriesName, celluid, chartSelection } = cellDeclaration;\n            if (chartSelection === undefined) chartSelection = null;\n            let cell = new cell_class({\n                nodeDataseriesName,\n                chartSelection,\n                uid: celluid\n            });\n            this._updateCell(cell, cellIndex);\n            cells.push(cell);\n        }\n        return cells;\n    }\n    resetCells() {\n        let budgetNode = this;\n        let cells = budgetNode.cells;\n        for (let cellIndex in cells) {\n            let cell = cells[cellIndex];\n            budgetNode._updateCell(cell, cellIndex);\n            cell.setChartParms();\n        }\n        this.newCells = cells;\n        this.updated = true;\n    }\n    switchYearSelections(yearSelections) {\n        let budgetNode = this;\n        this.yearSelections = yearSelections;\n        let cells = budgetNode.cells;\n        for (let cellIndex in cells) {\n            let cell = cells[cellIndex];\n            budgetNode._updateCell(cell, cellIndex);\n            cell.setChartParms();\n        }\n        this.newCells = cells;\n        this.updated = true;\n    }\n    get cellDeclarationList() {\n        let list = this.getProps().declarationData.nodesById[this.uid].cellList;\n        if (list == null) return list;else return [...list];\n    }\n}\n/* harmony default export */ var node_class = (node_class_BudgetNode);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/branch.class.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// budgetbranch.tsx\n/*\n\nTODO: fix addnode to pass along cell settings for new child\n\n*/\n\n\n\n\nclass branch_class_BudgetBranch {\n    constructor(parms) {\n        // this generates a trigger to create a budget node object\n        this.getInitialBranchNodeParms = () => {\n            let defaults = this.getProps().declarationData.defaults.node;\n            let branchSettings = this.branchDeclaration;\n            let viewpointData = this.state.viewpointData;\n            let budgetBranch = this;\n            let datapath = [];\n            let { viewpoint: viewpointName, aspect: aspectName } = branchSettings;\n            let budgetNodeParms = {\n                viewpointName,\n                aspectName,\n                yearsRange: {\n                    firstYear: null,\n                    lastYear: null\n                },\n                yearSelections: Object.assign({}, defaults.yearSelections),\n                dataPath: [],\n                nodeIndex: 0,\n                cellIndex: 0\n            };\n            budgetNodeParms = Object.assign(defaults, budgetNodeParms);\n            return budgetNodeParms;\n        };\n        // this is a response to the addNode action\n        this.addNode = (budgetNodeUid, nodeIndex, budgetNodeParms) => {\n            let budgetBranch = this;\n            let { dataPath } = budgetNodeParms;\n            let branchSettings = budgetBranch.branchDeclaration;\n            let branchNode = budgetBranch;\n            let viewpointData = budgetBranch.state.viewpointData;\n            if (!viewpointData) return;\n            let treeNodeData = getbudgetnode(viewpointData, dataPath);\n            if (!treeNodeData) {\n                console.error(\'failure to find treenode data\', dataPath, viewpointData);\n            }\n            let branchNodes = budgetBranch.nodes;\n            let parentNode = nodeIndex === 0 ? null : branchNodes[branchNodes.length - 1];\n            // TODO: obtain and pass cell configurations - yearScope and chartConfigs\n            let budgetNode = new node_class(budgetNodeParms, budgetNodeUid, treeNodeData, parentNode);\n            branchNodes[nodeIndex] = budgetNode;\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        this.saveNodeStates = () => {\n            let budgetBranch = this;\n            let nodes = budgetBranch.nodes;\n            let node;\n            for (node of nodes) {\n                // console.log(\'node in saveNodeStates\',node)\n                node.oldNodeState.hasChildren = !!node.treeNodeData.Components;\n            }\n        };\n        this.toggleInflationAdjusted = () => {\n            let budgetBranch = this;\n            let nodeIndex;\n            let branchuid = budgetBranch.uid;\n            let branchSettings = budgetBranch.branchDeclaration;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let branchNodes = budgetBranch.nodes;\n            for (nodeIndex in branchNodes) {\n                let budgetNode = branchNodes[nodeIndex];\n                let dataNode = getbudgetnode(viewpointData, budgetNode.dataPath);\n                budgetNode.updateDataNode(dataNode);\n                budgetNode.resetCells();\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        this.harmonizeCells = () => {\n            let budgetBranch = this;\n            let nodeIndex;\n            let branchNodes = budgetBranch.nodes;\n            for (nodeIndex in branchNodes) {\n                let budgetNode = branchNodes[nodeIndex];\n                let nodeDeclaration = budgetNode.props.declarationData.nodesById[budgetNode.uid];\n                budgetNode.switchYearSelections(nodeDeclaration.yearSelections);\n                budgetNode.resetCells();\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        // this resets the branch in response to the change aspect user request\n        this.switchAspect = () => {\n            let budgetBranch = this;\n            let { actions, nodeCallbacks: callbacks } = budgetBranch;\n            let switchResults = {\n                deeperdata: false,\n                shallowerdata: false,\n                mismatch: false,\n                message: null\n            };\n            let branchSettings = budgetBranch.branchDeclaration;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let branchNodes = budgetBranch.nodes;\n            let budgetNode = null;\n            let parentBudgetNode;\n            let nodeIndex;\n            let isError = false;\n            let chartParmsObj = null;\n            let branchuid = budgetBranch.uid;\n            for (nodeIndex in branchNodes) {\n                parentBudgetNode = budgetNode;\n                budgetNode = branchNodes[nodeIndex];\n                let dataNode = getbudgetnode(viewpointData, budgetNode.dataPath);\n                if (dataNode) {\n                    // check previous cell configuration against previous node\n                    // TODO: THIS IS A PROXY THAT NEEDS TO BE REPLACED\n                    // there is only one chart where there should be 2\n                    let deeperdata = !!dataNode.Components && !budgetNode.oldNodeState.hasChildren;\n                    // there are two charts where there should be 1\n                    let shallowerdata = !dataNode.Components && budgetNode.oldNodeState.hasChildren;\n                    // now set budgetNode with new data node\n                    let parentDataNode = null;\n                    if (nodeIndex > 0) {\n                        parentDataNode = branchNodes[nodeIndex - 1].treeNodeData;\n                    }\n                    if (deeperdata || shallowerdata) {\n                        switchResults.deeperdata = deeperdata;\n                        switchResults.shallowerdata = shallowerdata;\n                        // replace budgetNode\n                        isError = true;\n                        let prevBudgetNode = branchNodes[nodeIndex - 1];\n                        let removed = branchNodes.splice(nodeIndex);\n                        let removedids = removed.map(item => {\n                            return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n                        });\n                        actions.removeNodeDeclarations(removedids);\n                        setTimeout(() => {\n                            let prevBudgetCell = prevBudgetNode.cells[0];\n                            // TODO: pass prior cell and node settings\n                            let childprops = {\n                                selectionrow: prevBudgetCell.chartSelection,\n                                nodeIndex: prevBudgetNode.nodeIndex,\n                                cellIndex: 0,\n                                priorCellSettings: null,\n                                priorNodeSettings: null\n                            };\n                            // let fcurrent = fn(nodeIndex)(0)\n                            // let budgetBranch = this\n                            budgetBranch.createChildNodeDeclaration(childprops);\n                        });\n                        budgetNode = null; // branchNodes[nodeIndex] // created by createChildNodeDeclaration as side effect\n                    } else {\n                        budgetNode.updateAspect(branchSettings.aspect, dataNode\n                        // parentDataNode\n                        );\n                        budgetNode.resetCells();\n                        // budgetNode.newCells = newCells\n                    }\n                } else {\n                    let removed = branchNodes.splice(nodeIndex);\n                    let removedids = removed.map(item => {\n                        return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n                    });\n                    actions.removeNodeDeclarations(removedids);\n                    switchResults.mismatch = true;\n                    switchResults.message = \'The new aspect does not have a matching chart for \' + budgetNode.treeNodeData.Name;\n                    let cells = parentBudgetNode.cells;\n                    for (let cell of cells) {\n                        let theCell = cell;\n                        if (theCell.chartSelection !== null) {\n                            theCell.chartSelection = null;\n                        }\n                    }\n                }\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n            return switchResults;\n        };\n        this.calculateProRata = viewpointdata => {\n            let { branchDeclaration } = this;\n            let { repository, prorata: prorataindex } = branchDeclaration;\n            let prorataseries;\n            switch (prorataindex) {\n                case "OFF":\n                    {\n                        prorataseries = \'none\';\n                        break;\n                    }\n                case "PERPERSON":\n                case "PER100000PERSONS":\n                    prorataseries = \'population\';\n                    break;\n                case "PERHOUSEHOLD":\n                case "PER40000HOUSEHOLDS":\n                    prorataseries = \'households\';\n                    break;\n                case "PERWARD":\n                case "PERNEIGHBOURHOOD":\n                    prorataseries = \'none\';\n                    break;\n                default:\n                    console.error(\'unknown prorataindex\', prorataindex);\n                    return;\n            }\n            let promise = new Promise((resolve, error) => {\n                if (prorataindex == \'OFF\') {\n                    resolve(true);\n                } else {\n                    if (prorataseries == \'none\') {\n                        let { YearsRange } = viewpointdata.Meta.datasetConfig;\n                        let { start, end } = YearsRange;\n                        let proratadata = {\n                            years: {}\n                        };\n                        for (let year = start; year <= end; year++) {\n                            proratadata.years[year] = null;\n                        }\n                        let budgetBranch = this;\n                        budgetBranch._doProRataCalc(viewpointdata, proratadata);\n                        resolve(true);\n                    } else {\n                        let _promise = databaseapi.getProrataData({\n                            repository,\n                            prorataseries\n                        });\n                        _promise.then(proratadata => {\n                            // console.log(\'returned proratadata\',proratadata)\n                            let budgetBranch = this;\n                            budgetBranch._doProRataCalc(viewpointdata, proratadata);\n                            resolve(true);\n                        }).catch(reason => {\n                            console.error(reason);\n                            error(reason);\n                        });\n                    }\n                }\n            });\n            return promise;\n        };\n        this._doProRataCalc = (viewpointdata, proratadata) => {\n            // console.log(\'viewpointdata,proratadata\',viewpointdata,proratadata)\n            let proratayearlist = Object.assign({}, proratadata.years);\n            let { branchDeclaration } = this;\n            let { prorata: prorataindex } = branchDeclaration;\n            let { datasetConfig } = viewpointdata.Meta;\n            let unitratio = datasetConfig.UnitRatio;\n            let denominator,\n                multiplier,\n                precision = 5,\n                threshhold = 10000;\n            let proratatype = \'yearly\';\n            switch (prorataindex) {\n                case "PERPERSON":\n                    denominator = 1;\n                    multiplier = unitratio;\n                    break;\n                case "PER100000PERSONS":\n                    denominator = 100000;\n                    multiplier = 1;\n                    break;\n                case "PERHOUSEHOLD":\n                    denominator = 1;\n                    multiplier = unitratio;\n                    break;\n                case "PER40000HOUSEHOLDS":\n                    denominator = 40000;\n                    multiplier = 1;\n                    break;\n                case "PERWARD":\n                    denominator = 44;\n                    multiplier = 1;\n                    proratatype = \'fixed\';\n                    break;\n                case "PERNEIGHBOURHOOD":\n                    denominator = 4 * 44;\n                    multiplier = 1;\n                    proratatype = \'fixed\';\n                    break;\n                default:\n                    console.error(\'unknown prorataindex in _doProRataCalc\', prorataindex);\n                    return;\n            }\n            if (multiplier != 1) {\n                datasetConfig.CalcUnitRatio = 1;\n                datasetConfig.CalcUnitsAlias = "dollars";\n            } else {\n                datasetConfig.CalcUnitRatio = datasetConfig.UnitRatio;\n                datasetConfig.CalcUnitsAlias = datasetConfig.UnitsAlias;\n            }\n            if (proratatype == \'fixed\') {\n                for (let yearindex in proratayearlist) {\n                    proratayearlist[yearindex] = denominator;\n                }\n            } else {\n                for (let yearindex in proratayearlist) {\n                    let amount = proratayearlist[yearindex];\n                    proratayearlist[yearindex] = amount / denominator / multiplier;\n                }\n            }\n            this._doCalcYears(viewpointdata, proratayearlist, threshhold, precision);\n            // console.log(\'_doProRataCalc\', viewpointdata, proratayearlist, threshhold, precision)\n        };\n        this._doCalcYears = (node, proratayearlist, threshhold, precision) => {\n            let calcyears = {};\n            let years = node.years;\n            if (years) {\n                for (let yearindex in years) {\n                    if (proratayearlist[yearindex]) {\n                        let amount = years[yearindex] / proratayearlist[yearindex];\n                        if (amount < threshhold) {\n                            amount = Number(amount.toPrecision(precision));\n                        } else {\n                            amount = Number(amount.toFixed(0));\n                        }\n                        calcyears[yearindex] = amount;\n                    }\n                }\n                node.calcyears = calcyears;\n            }\n            if (node.Components) {\n                for (let index in node.Components) {\n                    let subnode = node.Components[index];\n                    this._doCalcYears(subnode, proratayearlist, threshhold, precision);\n                }\n            }\n            if (node.CommonDimension) {\n                for (let index in node.CommonDimension) {\n                    let subnode = node.CommonDimension[index];\n                    this._doCalcYears(subnode, proratayearlist, threshhold, precision);\n                }\n            }\n        };\n        this.updateProrata = () => {\n            let budgetBranch = this;\n            let nodeIndex;\n            let branchuid = budgetBranch.uid;\n            let branchSettings = budgetBranch.branchDeclaration;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let branchNodes = budgetBranch.nodes;\n            for (nodeIndex in branchNodes) {\n                let budgetNode = branchNodes[nodeIndex];\n                let dataNode = getbudgetnode(viewpointData, budgetNode.dataPath);\n                budgetNode.updateDataNode(dataNode);\n                budgetNode.resetCells();\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        // TODO: generate action to show progress\n        this.getViewpointData = () => {\n            let branchSettings = this.branchDeclaration;\n            let { viewpoint: viewpointName, aspect: aspectName, inflationAdjusted, version: versionName, repository } = branchSettings;\n            // console.log(\'aspectName, AspectNameToDatasetName\',aspectName, AspectNameToDatasetName)\n            let datasetName = constants["a" /* AspectNameToDatasetName */][aspectName];\n            let _promise = databaseapi.getViewpointData({\n                repository,\n                viewpointName,\n                versionName,\n                datasetName,\n                inflationAdjusted\n            });\n            let promise = new Promise((resolve, error) => {\n                _promise.then(viewpointdata => {\n                    let budgetBranch = this;\n                    this.calculateProRata(viewpointdata).then(() => {\n                        budgetBranch.setState({\n                            viewpointData: viewpointdata\n                        });\n                        resolve(true);\n                    }).catch(reason => {\n                        console.error(reason);\n                        throw Error(reason);\n                    });\n                }).catch(reason => {\n                    console.error(reason);\n                    error(reason);\n                });\n            });\n            return promise;\n        };\n        // called only by user chart row selection\n        // therefore metadata is always component\n        this.createChildNodeDeclaration = props => {\n            let budgetBranch = this;\n            let { selectionrow, nodeIndex, cellIndex, priorCellSettings, priorNodeSettings } = props;\n            let { nodes: branchNodes, nodeCallbacks: callbacks, actions, branchDeclaration: branchSettings } = budgetBranch;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let budgetNode = branchNodes[nodeIndex];\n            // a hack to pass prior settings to child\n            if (priorCellSettings) {\n                budgetNode.priorCellSettings = priorCellSettings;\n            }\n            let { aspectName, viewpointName } = budgetNode;\n            let { onPortalCreation } = callbacks;\n            // ----------------------------------------------------\n            // ----------------[ create child ]--------------------\n            // copy path\n            let childdatapath = budgetNode.dataPath.slice();\n            let treeNodeData = budgetNode.treeNodeData;\n            if (!treeNodeData.Components) {\n                return;\n            }\n            let components = treeNodeData.Components;\n            let code = null;\n            if (treeNodeData && treeNodeData.SortedComponents && treeNodeData.SortedComponents[selectionrow]) {\n                let componentMetaDataFromSortedList = treeNodeData.SortedComponents[selectionrow];\n                code = componentMetaDataFromSortedList.Code;\n            }\n            if (code) childdatapath.push(code);else {\n                return;\n            }\n            let newnode = treeNodeData.Components[code];\n            if (!newnode.Components && !newnode.CommonDimension) {\n                return;\n            }\n            let newrange = Object.assign({}, budgetNode.yearsRange);\n            let newselections;\n            let newCellIndex = cellIndex;\n            if (priorNodeSettings) {\n                newselections = priorNodeSettings.yearSelections;\n                newCellIndex = priorNodeSettings.cellIndex;\n            } else {\n                newselections = Object.assign({}, budgetNode.yearSelections);\n            }\n            let newdatanode = getbudgetnode(viewpointData, childdatapath);\n            let newnodeconfigparms = {\n                viewpointName,\n                aspectName,\n                dataPath: childdatapath,\n                nodeIndex: nodeIndex + 1,\n                yearsRange: newrange,\n                yearSelections: newselections,\n                cellIndex: newCellIndex\n            };\n            actions.addNodeDeclaration(newnodeconfigparms);\n            setTimeout(() => {\n                onPortalCreation();\n            });\n        };\n        this.uid = parms.uid;\n    }\n    get nodes() {\n        let copy = [...this.state.branchNodes];\n        return copy; // new copy\n    }\n    get state() {\n        return this.getState();\n    }\n    get props() {\n        return this.getProps();\n    }\n    get branchDeclaration() {\n        return this.props.declarationData.branchesById[this.uid];\n    }\n}\n/* harmony default export */ var branch_class = (branch_class_BudgetBranch);\n// CONCATENATED MODULE: ./ts/addons/explorer/components/explorerbranch.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorerbranch.tsx\n/*\n    TODO:\n    - implement scrolldown to new clone\n    - implement inheritance of settings to new clone\n    - add input fields to title, explorer header, and branch rightmost box\n      to allow textual explanations of pages\n    - add control to explorer header to toggle show/hide controls of charts\n    - have per unit and performance views\n    - include document source version (eg. summary vs fpars)\n    - prevent resetting branch when viewpoint selected is same as previous\n*/\n\n// -------------------[ libraries ]---------------------\n\n\nvar { Component: explorerbranch_Component } = react;\n\n\n\n\n\n\n\n\n\n\n\n\nlet { StyleRoot: explorerbranch_StyleRoot } = radium_es;\nconst explorerbranch_animations = {\n    fadeIn: {\n        animation: \'x .5s\',\n        animationName: keyframes["a" /* default */](react_animations_lib["fadeIn"], \'fadeIn\')\n    },\n    fadeOut: {\n        animation: \'x .5s\',\n        animationName: keyframes["a" /* default */](react_animations_lib["fadeOut"], \'fadeOut\')\n    }\n};\nlet jsonpack = __webpack_require__(1144);\nlet validurl = __webpack_require__(536);\nlet ReactGA = __webpack_require__(533);\n// ------------------------[ modules ]-----------------------------\n\n\n\n\n\n\n// ------------------------[ class ]-----------------------------\nclass explorerbranch_ExplorerBranch extends explorerbranch_Component {\n    constructor() {\n        // ---------------------[ initialization ]------------------------\n        super(...arguments);\n        this.state = {\n            branchNodes: [],\n            viewpointData: null,\n            snackbar: { open: false, message: \'empty\' },\n            comparatorselection: \'Off\',\n            techDialogOpen: false,\n            noticeDialogOpen: false,\n            selectionsDialogOpen: false,\n            animations: {\n                buttons: null,\n                controls: null\n            }\n        };\n        this.waitafteraction = 0;\n        /*\n            getState() and getProps() for budgetBranch object:\n            return fresh copy of state object; changes after being set\n            used by budgetBranch instance\n        */\n        this.getState = () => this.state;\n        this.getProps = () => this.props;\n        // provide for curried versions\n        this.addNodeDeclaration = branchUid => settings => this.props.globalStateActions.addNodeDeclaration(branchUid, settings);\n        this.addNodeDeclarations = branchUid => settingslist => this.props.globalStateActions.addNodeDeclarations(branchUid, settingslist);\n        this.removeNodeDeclarations = branchUid => nodeItems => this.props.globalStateActions.removeNodeDeclarations(branchUid, nodeItems);\n        this.urlparms = null;\n        this.urlparmscleared = [];\n        this.clearUrlParms = nodeIndex => {\n            if (!this.urlparms) {\n                console.error(\'call to remove expired urlparms\', nodeIndex);\n            }\n            this.urlparmscleared.push(nodeIndex);\n            if (this.urlparmscleared.length == this.urlparms.settingsdata.length) {\n                this.urlparms = null;\n                this.urlparmscleared = [];\n            }\n            setTimeout(() => {\n                this.onPortalCreation();\n            }, 1000);\n        };\n        this.logEvent = parms => {\n            if (window.location.hostname == \'budgetpedia.ca\') {\n                ReactGA.event(parms);\n            }\n        };\n        //----------------------------[ stories ]--------------------------------\n        // these are sets of branches; this section is for this branch\'s story section\n        this.story = null;\n        this.storiescleared = [];\n        this.storysettings = [];\n        this.clearStory = nodeIndex => {\n            if (!this.story) {\n                console.error(\'call to remove expired story\', nodeIndex);\n            }\n            this.storiescleared.push(nodeIndex);\n            if (this.storiescleared.length == this.storysettings.length) {\n                this.story = null;\n                this.storiescleared = [];\n                setTimeout(() => {\n                    this.onPortalCreation();\n                }, 1000);\n            }\n        };\n        this._createStoryNodes = (story, viewpointdata) => {\n            let path = this._getStoryPath(story);\n            // console.log(\'story path\',story.code,path)\n            this.props.clearStories(branch_class);\n            story.path = path;\n            let settingslist = this._getStorySettingsList(story, viewpointdata);\n            this.storysettings = settingslist;\n            // console.log(\'settingslist\',settingslist)\n            let explorerbranch = this;\n            explorerbranch._stateActions.addNodeDeclarations(settingslist);\n        };\n        this._getStoryPath = story => {\n            let path = [];\n            let viewpoint = this.state.viewpointData;\n            // console.log(\'story viewpoint data\',viewpoint)\n            if (viewpoint.Components && story.code) {\n                this._getPath(path, story.code, viewpoint.Components);\n            }\n            return path;\n        };\n        this._getStorySettingsList = (story, viewpointdata) => {\n            let settingslist = [];\n            let path = story.path;\n            let nodeCount = path.length + 1;\n            for (let n = 0; n < nodeCount; n++) {\n                let nodeDefaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.node));\n                let nodeSettings = {\n                    aspectName: story.aspect,\n                    cellIndex: n == nodeCount - 1 ? story.tab : 0,\n                    cellList: null,\n                    dataPath: path.slice(0, n),\n                    nodeIndex: n,\n                    viewpointName: story.viewpoint,\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                let settings = Object.assign(nodeDefaultSettings, nodeSettings);\n                settingslist.push({\n                    settings\n                });\n            }\n            return settingslist;\n        };\n        // -------------------------[ utilities ]----------------------\n        this._getPath = (path, targetcode, components) => {\n            for (let code in components) {\n                if (code == targetcode) {\n                    let subcomponents = components[code].Components;\n                    if (!subcomponents) {\n                        subcomponents = components[code].CommonDimension;\n                    }\n                    if (subcomponents) {\n                        path.push(code);\n                    }\n                    return true;\n                }\n                let subcomponents = components[code].Components;\n                if (subcomponents) {\n                    path.push(code);\n                    if (this._getPath(path, targetcode, subcomponents)) {\n                        return true;\n                    } else {\n                        path.pop();\n                    }\n                }\n            }\n            return false;\n        };\n        this._createUrlNodes = urlparms => {\n            this.urlparms = urlparms;\n            this.props.clearUrlParms();\n            try {\n                let path = urlparms.branchdata.pa;\n                // TODO: validate data path\n                let dataNode = getbudgetnode(this.state.viewpointData, path);\n                // let dataNode = null\n                if (dataNode) {\n                    let settingslist = this._geturlsettingslist(urlparms);\n                    this._stateActions.addNodeDeclarations(settingslist);\n                    return true;\n                } else {\n                    this.props.setToast(\'error\', \'unable to locate data requested by url parameter. Using defaults...\');\n                }\n            } catch (e) {\n                console.log(\'urlparms failure\', urlparms);\n                this.urlparms = null;\n            }\n            return false;\n        };\n        this._geturlsettingslist = urlparms => {\n            let nodesettings = urlparms.settingsdata;\n            let branch = urlparms.branchdata;\n            let settingslist = [];\n            for (let nodeindex in nodesettings) {\n                let node = nodesettings[nodeindex];\n                let settings = {\n                    aspectName: branch.as,\n                    cellIndex: node.ci,\n                    cellList: null,\n                    dataPath: branch.pa.slice(0, parseInt(nodeindex)),\n                    nodeIndex: parseInt(nodeindex),\n                    viewpointName: branch.vi,\n                    yearSelections: {\n                        leftYear: node.ys.ly,\n                        rightYear: node.ys.ry\n                    },\n                    yearsRange: {\n                        firstYear: null,\n                        lastYear: null\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n            }\n            return settingslist;\n        };\n        this._initialize = () => {\n            let branch = this;\n            let { budgetBranch, globalStateActions: actions, declarationData } = branch.props;\n            // create global actions bundle for children\n            branch._stateActions = Object.assign({}, actions);\n            // replace originals with curried versions\n            branch._stateActions.addNodeDeclaration = branch.addNodeDeclaration(budgetBranch.uid);\n            branch._stateActions.addNodeDeclarations = branch.addNodeDeclarations(budgetBranch.uid);\n            branch._stateActions.removeNodeDeclarations = branch.removeNodeDeclarations(budgetBranch.uid);\n            let { onPortalCreation } = branch;\n            // create display callbacks bundle for children\n            branch._nodeDisplayCallbacks = {\n                onPortalCreation\n            };\n            // complete initialization of budgetBranch class instance\n            // assign helpful getters and setters to budgetBranch\n            budgetBranch.getProps = branch.getProps;\n            budgetBranch.getState = branch.getState;\n            budgetBranch.setState = branch.setState.bind(branch);\n            // assign callbacks to budgetBranch\n            budgetBranch.actions = branch._stateActions;\n            budgetBranch.nodeCallbacks = branch._nodeDisplayCallbacks;\n            branch._previousControlData = declarationData; // initialize\n        };\n        this._getLeafPath = (code, viewpointdata) => {\n            // console.log(\'code, viewpointdata\',code, viewpointdata)\n            let path = [];\n            let selections = [];\n            // let code = parms.code\n            let result = this._searchComponents(code, path, selections, viewpointdata.Components, viewpointdata.SortedComponents);\n            if (!result) {\n                path = [];\n                // toastr.warning(parms.aspect + \' chart not available for that selection (\' + parms.name + \')\')\n            }\n            let isLeaf = !path.pop();\n            if (isLeaf) {\n                path.pop();\n                selections.pop();\n            }\n            this.pathSelections = selections;\n            // console.log(\'leafpath, selections\',path,selections)\n            return path;\n        };\n        this.lastactiongeneration = 0;\n        /*\n            harmonization means creating local nodes to match global declarations\n            acts as a sentinel; if count goes below zero, means that some\n            harmonization operation has failed, which is a system error\n        */\n        this.harmonizecount = null;\n        // harmonize branch nodes; add pending node objects, and process state changes\n        this.harmonizeNodesToState = (branchNodes, nodeList, nodesById, budgetBranch) => {\n            if (this.harmonizecount === null) {\n                // initialize harmonization count\n                this.harmonizecount = nodeList.length - branchNodes.length;\n            }\n            // let harmonizecount = (nodeList.length - branchNodes.length)\n            // first task is to harmonize declarationData nodeList list with local branchNode list\n            // this condition will keep adding nodes on each render cycle triggered by \n            // addBranchNode, until all nodes are drawn\n            if (this.harmonizecount > 0) {\n                // places sentinal in place in case addNode below fails\n                //   generating an infinite loop\n                this.harmonizecount--;\n                let nodeIndex = branchNodes.length;\n                let budgetNodeId = nodeList[nodeIndex];\n                // console.log(\'arguments for addNode\',nodeIndex,nodeList,budgetNodeId,nodesById,this.harmonizecount)\n                // TODO: investigate doing addNodes instead, and adding them to the nodes state in one operation\n                budgetBranch.addNode( // sets state to trigger a render, and re-visitation of this code\n                budgetNodeId, nodeIndex, nodesById[budgetNodeId] // declarations\n                );\n                return true;\n            } else {\n                // otherwise see if there are other cascading actions that have to be taken\n                this.harmonizecount = null; // reset\n                return false;\n            }\n        };\n        // state change machine\n        // TODO return value is ignored\n        this._respondToGlobalStateChange = () => {\n            let { budgetBranch } = this.props;\n            let previousControlData = this._previousControlData;\n            let currentControlData = this.props.declarationData;\n            let { lastTargetedAction } = currentControlData;\n            let lastAction = lastTargetedAction[budgetBranch.uid] || {};\n            let returnvalue = true;\n            if (!explorer_actions["g" /* branchTypes */][lastAction.type]) {\n                return false;\n            }\n            // the generation counter could be the same if render is being triggered\n            // solely by a local state change, which we want to ignore here\n            if (previousControlData && currentControlData.generation == previousControlData.generation) {\n                return false;\n            }\n            switch (lastAction.type) {\n                case explorer_actions["g" /* branchTypes */].CHANGE_VIEWPOINT:\n                    {\n                        this._processChangeViewpointSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].UPDATE_BRANCH:\n                    {\n                        this._processUpdateBranchStateChange(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].CHANGE_VERSION:\n                    {\n                        this._processChangeVersionSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].CHANGE_ASPECT:\n                    {\n                        this._processChangeAspectSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].TOGGLE_INFLATION_ADJUSTED:\n                    {\n                        this._processToggleInflationAdjustedSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].UPDATE_PRORATA:\n                    {\n                        this._processUpdateProrataSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].HARMONIZE_CELLS:\n                    {\n                        budgetBranch.harmonizeCells();\n                        break;\n                    }\n                default:\n                    returnvalue = false;\n            }\n            this._previousControlData = currentControlData;\n            return returnvalue;\n        };\n        this._processChangeViewpointSelection = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                let budgetNodeParms = budgetBranch.getInitialBranchNodeParms();\n                this._stateActions.addNodeDeclaration(budgetNodeParms);\n            }).catch(reason => {\n                console.error(\'error in data fetch, changeviewpoint\', reason);\n            });\n        };\n        this._processUpdateBranchStateChange = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                let settingslist = this._getFinderNodeSettingsList();\n                this._stateActions.addNodeDeclarations(settingslist);\n                let explorerbranch = this;\n                setTimeout(() => {\n                    explorerbranch._updateCellChartSelections();\n                });\n                setTimeout(() => {\n                    explorerbranch.onPortalCreation();\n                }, 1000);\n            }).catch(reason => {\n                console.error(\'error in data fetch, update branch\', reason);\n            });\n        };\n        this._updateCellChartSelections = () => {\n            let nodes = this.state.branchNodes;\n            let selections = this.pathSelections;\n            for (let index in selections) {\n                let node = nodes[index];\n                let cell = node.cells[0];\n                let selection = selections[index];\n                this._stateActions.updateCellChartSelection(node.uid)(cell.uid, selection);\n                cell.chartSelection = selection;\n                cell.refreshSelection();\n            }\n        };\n        // --------------------------[ finder (search) ]-----------------------------\n        this._getFinderNodeSettingsList = () => {\n            let viewpointdata = this.state.viewpointData;\n            let parms = this.finderParms;\n            let dictionary = this.findParmsToStateDictionary;\n            let settingslist = [];\n            // let defaults = this.props.declarationData.defaults.node\n            // console.log(\'viewpointdata\',viewpointdata)\n            // if this is a common dimension request, return first portal only\n            if (parms.source == \'detailedbudgets\' && [\'expense\', \'revenue\', \'permanence\'].indexOf(parms.level) > -1) {\n                // console.log(\'found common dimension\')\n                let settings = {\n                    aspectName: dictionary.aspect[parms.aspect],\n                    cellIndex: 1,\n                    cellList: null,\n                    dataPath: [],\n                    nodeIndex: 0,\n                    viewpointName: dictionary.viewpoint[parms.viewpoint],\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n                lib["toastr"].info(\'Find \' + dictionary.level[parms.level].toUpperCase() + \' tabs at any program drilldown level\');\n            } else {\n                let leafpath = this._getLeafPath(parms.code, viewpointdata);\n                let settings = {\n                    aspectName: dictionary.aspect[parms.aspect],\n                    cellIndex: 0,\n                    cellList: null,\n                    dataPath: [],\n                    nodeIndex: 0,\n                    viewpointName: dictionary.viewpoint[parms.viewpoint],\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n                for (let nodeindex in leafpath) {\n                    let settings = {\n                        aspectName: dictionary.aspect[parms.aspect],\n                        cellIndex: 0,\n                        cellList: null,\n                        dataPath: leafpath.slice(0, parseInt(nodeindex) + 1),\n                        nodeIndex: parseInt(nodeindex) + 1,\n                        viewpointName: dictionary.viewpoint[parms.viewpoint],\n                        yearSelections: {\n                            leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                            rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                        },\n                        yearsRange: {\n                            firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                            lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                        }\n                    };\n                    settingslist.push({\n                        settings\n                    });\n                }\n            }\n            // console.log(\'viewpointdata and parms in get node settings list\',viewpointdata, parms, settingslist)\n            return settingslist;\n        };\n        this._searchComponents = (code, path, selections, components, sortedcomponents) => {\n            for (let component_name in components) {\n                path.push(component_name);\n                if (component_name == code) {\n                    // leaf\n                    let depth = path.length;\n                    let selection;\n                    for (let index = 0; index < sortedcomponents.length; index++) {\n                        if (sortedcomponents[index].Code == component_name) {\n                            selection = index;\n                            break;\n                        }\n                    }\n                    selections[depth - 1] = selection;\n                    let node = components[component_name];\n                    if (node.Components || node.CommonDimension) {\n                        path.push(true);\n                    } else {\n                        path.push(false);\n                    }\n                    return true;\n                } else {\n                    let subcomponents = components[component_name].Components;\n                    let depth = path.length;\n                    if (subcomponents) {\n                        let sortedsubcomponents = components[component_name].SortedComponents;\n                        if (this._searchComponents(code, path, selections, subcomponents, sortedsubcomponents)) {\n                            // console.log(\'returning from depth\',depth,code,component_name,components,sortedcomponents)\n                            let selection;\n                            for (let index = 0; index < sortedcomponents.length; index++) {\n                                if (sortedcomponents[index].Code == component_name) {\n                                    selection = index;\n                                    break;\n                                }\n                            }\n                            selections[depth - 1] = selection;\n                            // TODO add selection\n                            return true;\n                        }\n                    }\n                }\n                path.pop();\n            }\n            return false;\n        };\n        // ---------------------------[ user requested state changes ]------------------\n        this._processChangeVersionSelection = budgetBranch => {\n            // console.log(\'previousVersionPath\',this.previousVersionPath)\n            budgetBranch.getViewpointData().then(() => {\n                let path = this.previousVersionPath;\n                if (path.length) {\n                    let code = path.pop();\n                    path = this._getLeafPath(code, this.state.viewpointData);\n                }\n                let settingslist = this._getTreeSelectionNodeSettingsList(path);\n                this._stateActions.addNodeDeclarations(settingslist);\n                let explorerbranch = this;\n                setTimeout(() => {\n                    explorerbranch._updateCellChartSelections();\n                }, 500);\n                setTimeout(() => {\n                    explorerbranch.onPortalCreation();\n                }, 1000);\n                // this._stateActions.incrementBranchDataVersion(budgetBranch.uid)\n                // let budgetNodeParms:BudgetNodeDeclarationParms = budgetBranch.getInitialBranchNodeParms()\n                // this._stateActions.addNodeDeclaration(budgetNodeParms)\n            }).catch(reason => {\n                console.error(\'error in data fetch, changeversion\', reason);\n            });\n        };\n        this._processToggleInflationAdjustedSelection = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                budgetBranch.toggleInflationAdjusted();\n            }).catch(reason => {\n                console.error(\'error in data fetch, toggle inflation adjustment\', reason);\n            });\n        };\n        this._processUpdateProrataSelection = budgetBranch => {\n            budgetBranch.calculateProRata(this.state.viewpointData).then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                budgetBranch.updateProrata();\n            }).catch(reason => {\n                console.error(\'error in data fetch, updata prorata\', reason);\n            });\n        };\n        this._processChangeAspectSelection = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                let switchResults = budgetBranch.switchAspect();\n                let { deeperdata, shallowerdata, mismatch } = switchResults;\n                if (mismatch) {\n                    let message = switchResults.message;\n                    let { snackbar } = this.state;\n                    snackbar = Object.assign({}, snackbar);\n                    snackbar.message = message;\n                    snackbar.open = true;\n                    this.setState({\n                        snackbar\n                    });\n                }\n                if (deeperdata || shallowerdata) {\n                    let message = null;\n                    if (deeperdata) {\n                        message = "More drilldown is available for current selection";\n                    } else {\n                        message = "Less drilldown is available for current selection";\n                    }\n                    let { snackbar } = this.state;\n                    snackbar = Object.assign({}, snackbar);\n                    snackbar.message = message;\n                    snackbar.open = true;\n                    this.setState({\n                        snackbar\n                    });\n                }\n            }).catch(reason => {\n                console.error(\'error in data fetch, changeaspect\', reason);\n            });\n        };\n        this.handleSnackbarRequestClose = () => {\n            // this.props.globalStateActions.resetLastAction()\n            this.setState({\n                snackbar: {\n                    open: false,\n                    message: \'empty\'\n                }\n            });\n        };\n        // ============================================================\n        // ---------------------[ *** BRANCH *** CONTROL RESPONSES ]------------------\n        // onPortalCreation animates scroll-in of new portal\n        this.branchScrollBlock = null;\n        this.onPortalCreation = () => {\n            let element = this.branchScrollBlock;\n            if (!element) {\n                console.error(\'System Error: expected branch element not found in onPortalCreation\');\n                return;\n            }\n            setTimeout(() => {\n                let scrollwidth = element.scrollWidth;\n                let scrollleft = element.scrollLeft;\n                let clientwidth = element.clientWidth;\n                let scrollright = scrollleft + clientwidth;\n                let targetright = scrollwidth - 500;\n                let adjustment = scrollright - targetright;\n                // console.log(\'scrollwidth,scrollleft,clientwidth,scrollright,targetright,adjustment\',scrollwidth,scrollleft,clientwidth,scrollright,targetright,adjustment)\n                if (adjustment > 0) {\n                    adjustment = Math.min(adjustment, scrollleft);\n                }\n                // console.log(\'final adjustment\',adjustment)\n                let frames = 60;\n                let t = 1 / frames;\n                let counter = 0;\n                let tick = () => {\n                    counter++;\n                    let factor = this.easeOutCubic(counter * t);\n                    let scrollinterval = adjustment * factor;\n                    element.scrollLeft = scrollleft - scrollinterval;\n                    if (counter < frames) {\n                        requestAnimationFrame(tick);\n                    }\n                };\n                requestAnimationFrame(tick);\n            }, 10);\n        };\n        // from https://github.com/DelvarWorld/easing-utils/blob/master/src/easing.js\n        this.easeOutCubic = t => {\n            const t1 = t - 1;\n            return t1 * t1 * t1 + 1;\n        };\n        // ---------------------[ user interactions ]---------------------------\n        this.selectViewpoint = viewpointname => {\n            let { budgetBranch } = this.props;\n            let { nodes: branchNodes } = budgetBranch;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = this._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            globalStateActions.changeViewpoint(budgetBranch.uid, viewpointname);\n        };\n        this.previousVersionPath = null;\n        this.selectVersion = versionName => {\n            let { budgetBranch } = this.props;\n            let { nodes: branchNodes } = budgetBranch;\n            let path = null;\n            for (let n = branchNodes.length - 1; n >= 0; n--) {\n                let node = branchNodes[n];\n                if (node.treeNodeData.Baseline) {\n                    path = node.dataPath;\n                }\n                if (!path) path = node.dataPath;\n            }\n            this.previousVersionPath = path;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = this._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            // now the viewpoint can be changed, triggering a change in viewpoint data\n            globalStateActions.changeVersion(budgetBranch.uid, versionName);\n        };\n        this.selectAspect = aspect => {\n            switch (aspect) {\n                case "Expenses":\n                case "Revenues":\n                case "Staffing":\n                    break;\n                default:\n                    return;\n            }\n            let { budgetBranch } = this.props;\n            budgetBranch.saveNodeStates();\n            this.props.globalStateActions.changeAspect(budgetBranch.uid, aspect);\n        };\n        this.switchComparator = comparatorindex => {\n            let { budgetBranch } = this.props;\n            this.props.globalStateActions.updateProrata(budgetBranch.uid, comparatorindex);\n        };\n        this.toggleInflationAdjustment = value => {\n            let { budgetBranch } = this.props;\n            this.props.globalStateActions.toggleInflationAdjusted(budgetBranch.uid, value);\n        };\n        this.toggleShowOptions = value => {\n            let anims = {\n                buttons: null,\n                controls: null\n            };\n            this.setState({\n                animations: anims\n            }, () => {\n                let a = value ? explorerbranch_animations.fadeIn : explorerbranch_animations.fadeOut;\n                let anims = {\n                    buttons: a,\n                    controls: a\n                };\n                this.setState({\n                    animations: anims\n                }, () => {\n                    let { budgetBranch } = this.props;\n                    this.props.globalStateActions.toggleShowOptions(budgetBranch.uid, value);\n                });\n            });\n        };\n        // ---------------------------[ search dialog response ]-------------------------\n        this.handleSearch = e => {\n            this.props.handleSearchDialogOpen(e, this.applySearchBranchSettings);\n        };\n        this.finderParms = null;\n        this.findParmsToStateDictionary = {\n            viewpoint: {\n                functionalbudget: \'FUNCTIONAL\',\n                structuralbudget: \'STRUCTURAL\',\n                actualexpenses: \'ACTUALEXPENSES\',\n                actualrevenues: \'ACTUALREVENUES\',\n                expenditures: \'EXPENDITURES\'\n            },\n            source: {\n                summarybudgets: \'SUMMARY\',\n                detailedbudgets: \'PBFT\',\n                auditedexpenses: \'ACTUALEXPENSES\',\n                auditedrevenues: \'ACTUALREVENUES\',\n                auditedexpenditures: \'EXPENDITURES\'\n            },\n            aspect: {\n                expenses: \'Expenses\',\n                revenues: \'Revenues\',\n                staffing: \'Staffing\',\n                expenditures: \'Expenditure\'\n            },\n            level: {\n                expense: \'Expenditures\',\n                revenue: \'Receipts\',\n                permanence: \'Permanence\'\n            }\n        };\n        this.applySearchBranchSettings = parms => {\n            let explorerbranch = this;\n            if (parms.viewpoint == \'expenditures\') {\n                parms.aspect = \'expenditures\';\n            }\n            explorerbranch.finderParms = parms;\n            let { budgetBranch } = explorerbranch.props;\n            let { nodes: branchNodes } = budgetBranch;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = explorerbranch._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            let settings = explorerbranch._getNewBranchSettings(parms);\n            globalStateActions.updateBranch(budgetBranch.uid, settings);\n        };\n        this._getNewBranchSettings = parms => {\n            let dictionary = this.findParmsToStateDictionary;\n            let settings = {\n                viewpoint: dictionary.viewpoint[parms.viewpoint],\n                aspect: dictionary.aspect[parms.aspect],\n                version: dictionary.source[parms.source]\n            };\n            return settings;\n        };\n        // ------------------------------[ workspace tree selection response ]------------------------\n        this.applytaxonomyselection = parms => {\n            let targetcode = parms.selectedleafnode ? parms.selectedleafnode : parms.selectedtreenode;\n            // console.log(\'applytaxonomyselection parms\',parms,targetcode)\n            let branchDeclaration = this.props.declarationData.branchesById[this.props.budgetBranch.uid];\n            let pathParms = {\n                code: targetcode,\n                aspect: branchDeclaration.aspect,\n                name: targetcode\n            };\n            let path = this._getLeafPath(pathParms.code, this.state.viewpointData);\n            // console.log(\'path\',path)\n            // remove previous branches\n            let { budgetBranch } = this.props;\n            let { nodes: branchNodes } = budgetBranch;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = this._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            // add new branches\n            let settingslist = this._getTreeSelectionNodeSettingsList(path);\n            this._stateActions.addNodeDeclarations(settingslist);\n            let explorerbranch = this;\n            setTimeout(() => {\n                explorerbranch._updateCellChartSelections();\n            }, 500);\n            setTimeout(() => {\n                explorerbranch.onPortalCreation();\n            }, 1000);\n        };\n        this._getTreeSelectionNodeSettingsList = path => {\n            let settingslist = [];\n            let viewpointdata = this.state.viewpointData;\n            let branchDeclaration = this.props.declarationData.branchesById[this.props.budgetBranch.uid];\n            let settings = {\n                aspectName: branchDeclaration.aspect,\n                cellIndex: 0,\n                cellList: null,\n                dataPath: [],\n                nodeIndex: 0,\n                viewpointName: branchDeclaration.viewpoint,\n                yearSelections: {\n                    leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                    rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                },\n                yearsRange: {\n                    firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                    lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                }\n            };\n            settingslist.push({\n                settings\n            });\n            for (let nodeindex in path) {\n                let settings = {\n                    aspectName: branchDeclaration.aspect,\n                    cellIndex: 0,\n                    cellList: null,\n                    dataPath: path.slice(0, parseInt(nodeindex) + 1),\n                    nodeIndex: parseInt(nodeindex) + 1,\n                    viewpointName: branchDeclaration.viewpoint,\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n            }\n            return settingslist;\n        };\n        // ---------------------------[ callbacks ]------------------------------\n        /*\n            harmonize:\n            node:\n            - tab selection cellIndex\n            - yearSelections selection yearSelections\n            cell:\n            - yearScope selection "OneYear" etc.\n            - chart selection [YearScope].ExplorerChartCode\n                 TODO: if the reference chart is an expenditure chart\n                then all other nodes should also show expenditure chart\n                -- so if the reference chart is in the leaf node\n        */\n        this.harmonizeCells = (nodeUid, cellUid) => {\n            let { budgetBranch } = this.props;\n            let nodeList = [];\n            let cellList = [];\n            let nodeProperties = { cellIndex: null, yearSelections: null };\n            let cellProperties = { yearScope: null, chartCode: null, nodeDataseriesName: null };\n            let declarationData = this.props.declarationData;\n            let refnode = declarationData.nodesById[nodeUid];\n            let refcell = declarationData.cellsById[cellUid];\n            // get defaults to apply\n            nodeProperties.cellIndex = refnode.cellIndex;\n            nodeProperties.yearSelections = Object.assign({}, refnode.yearSelections);\n            cellProperties.yearScope = refcell.yearScope;\n            cellProperties.chartCode = refcell.chartConfigs[refcell.yearScope].explorerChartCode;\n            cellProperties.nodeDataseriesName = refcell.nodeDataseriesName;\n            // collect node and cell lists\n            let nodeidlist = declarationData.branchesById[budgetBranch.uid].nodeList;\n            for (let nodeid of nodeidlist) {\n                // if (nodeid == nodeUid) continue\n                nodeList.push(nodeid);\n                let tempnode = declarationData.nodesById[nodeid];\n                let cellidlist = tempnode.cellList;\n                for (let cellid of cellidlist) {\n                    if (cellid == cellUid) continue;\n                    cellList.push(cellid);\n                }\n            }\n            if (nodeList.length > 0) {\n                this._stateActions.harmonizeCells(budgetBranch.uid, nodeProperties, cellProperties, nodeList, cellList);\n            }\n        };\n        // -----------------------------[ prepare for render ]---------------------------------\n        // get React components to render\n        this.getPortals = budgetNodes => {\n            let branch = this;\n            let { viewpointData } = branch.state;\n            if (!viewpointData) return [];\n            let datasetConfig = viewpointData.Meta.datasetConfig;\n            let portalSeriesName = datasetConfig.DatasetName;\n            if (datasetConfig.Units == \'DOLLAR\') {\n                portalSeriesName += \' (\' + datasetConfig.UnitsAlias + \')\';\n            }\n            let portals = budgetNodes.map((budgetNode, nodeindex) => {\n                let branchDeclaration = branch.props.declarationData.branchesById[branch.props.budgetBranch.uid];\n                let portalName = null;\n                let treeNodeData = budgetNode.treeNodeData;\n                if (treeNodeData.Name) {\n                    // .Name) // MetaDataFromParentSortedList) {\n                    portalName = budgetNode.treeNodeData.Name;\n                    portalName += \' \' + portalSeriesName;\n                } else {\n                    portalName = datasetConfig.DatasetTitle; //\'City Budget\'\n                }\n                let portalConfig = {\n                    portalName\n                };\n                budgetNode.portalConfig = portalConfig;\n                let viewpointdata = branch.state.viewpointData;\n                let { NamingConfigurations: viewpointNamingConfigs,\n                    // datasetConfig, declared previously\n                    isInflationAdjusted } = viewpointdata.Meta;\n                let viewpointConfigPack = {\n                    viewpointNamingConfigs,\n                    datasetConfig,\n                    isInflationAdjusted,\n                    prorata: branchDeclaration.prorata\n                };\n                budgetNode.viewpointConfigPack = viewpointConfigPack;\n                budgetNode.branchSettings = branch.props.budgetBranch.branchDeclaration;\n                budgetNode.onChartComponentSelection = onChartComponentSelection(branch.props.budgetBranch);\n                let actions = Object.assign({}, branch._stateActions);\n                actions.updateCellTimeScope = branch._stateActions.updateCellTimeScope(budgetNode.uid);\n                actions.updateCellChartSelection = branch._stateActions.updateCellChartSelection(budgetNode.uid);\n                actions.updateCellChartCode = branch._stateActions.updateCellChartCode(budgetNode.uid);\n                actions.updateCellYearSelections = branch._stateActions.updateCellYearSelections(budgetNode.uid);\n                return react["createElement"](explorernode_ExplorerNode, { key: budgetNode.uid, callbackid: nodeindex, budgetNode: budgetNode, declarationData: branch.props.declarationData, globalStateActions: actions, showControls: branchDeclaration.showOptions, dataGenerationCounter: branchDeclaration.branchDataGeneration, callbacks: { harmonizeCells: branch.harmonizeCells }, urlparms: this.urlparms, story: this.story, clearUrlParms: this.clearUrlParms, clearStory: this.clearStory, onCallAnalystNotes: this.props.onCallAnalystNotes });\n            });\n            return portals;\n        };\n        this._inputonfocus = () => {\n            this._inputfieldref.setSelectionRange(0, this._inputfieldref.value.length);\n        };\n        // ----------------------------[ response to share request ]--------------------------\n        this.shareBranch = () => {\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Share branch\'\n            });\n            let longurl = this._getShareUrl();\n            // console.log(\'long url\',longurl)\n            this._getBitlyUrl(longurl).then(json => {\n                // console.log(\'result\',json)\n                if (json.status_code != 200) {\n                    let errmessage = json.status_txt + \'(\' + json.status_code + \')\';\n                    console.log(\'error message\', errmessage);\n                    throw new Error(errmessage);\n                }\n                let url = json.data.url;\n                let toastrComponent = () => react["createElement"]("div", { style: { width: "300px" } }, react["createElement"]("p", { style: { width: "290px" } }, "To share the selected row of charts, copy the url below, and send it to a friend."), react["createElement"]("input", { ref: node => {\n                        this._inputfieldref = node;\n                    }, onFocus: this._inputonfocus, style: { width: "290px" }, value: url, readOnly: true }));\n                let toastrOptions = {\n                    icon: react["createElement"](FontIcon_default.a, { className: "material-icons" }, "share"),\n                    component: toastrComponent\n                };\n                lib["toastr"].message(\'Share charts\', toastrOptions);\n            }).catch(error => {\n                console.log(\'error getting bitly\', error);\n                lib["toastr"].error(\'Bitly error\', error.message);\n            });\n        };\n        // bitly token: bdf92b4b130fbc1d19871694f8fe957ccb775e12\n        this._getBitlyUrl = longurl => {\n            let token = \'bdf92b4b130fbc1d19871694f8fe957ccb775e12\';\n            return fetch(\'https://api-ssl.bitly.com/v3/shorten?access_token=\' + token + \'&longUrl=\' + encodeURIComponent(\'http://\' + longurl)).then(response => {\n                // let reply = response.\n                let json = response.json();\n                return json;\n            }).catch(error => {\n                console.error(\'error getting bitly url\', error);\n            });\n        };\n        this._getShareUrl = () => {\n            let branch = this;\n            let branchDeclaration = branch.props.declarationData.branchesById[branch.props.budgetBranch.uid];\n            let government = branchDeclaration.repository;\n            let viewpoint = branchDeclaration.viewpoint;\n            let version = branchDeclaration.version;\n            let aspect = branchDeclaration.aspect;\n            let prorata = branchDeclaration.prorata;\n            let adjusted = branchDeclaration.inflationAdjusted;\n            let path = this.state.branchNodes[this.state.branchNodes.length - 1].dataPath;\n            let query = {\n                g: government,\n                vi: viewpoint,\n                ve: version,\n                as: aspect,\n                pr: prorata,\n                ad: adjusted,\n                pa: path\n            };\n            let nodeDeclarations = [];\n            let node;\n            for (node of this.state.branchNodes) {\n                nodeDeclarations.push(node.nodeDeclaration);\n            }\n            let settings = [];\n            for (let nodeDeclaration of nodeDeclarations) {\n                let cellDeclarations = [];\n                for (let celluid of nodeDeclaration.cellList) {\n                    cellDeclarations.push(branch.props.declarationData.cellsById[celluid]);\n                }\n                let cellSettingsList = [];\n                // TODO: only process the cellDeclaration for current cellIndex\n                for (let cellDeclaration of cellDeclarations) {\n                    let cellSettings = {\n                        ys: cellDeclaration.yearScope,\n                        // cs:cellDeclaration.chartSelection,\n                        ct: cellDeclaration.chartConfigs[cellDeclaration.yearScope].explorerChartCode\n                    };\n                    cellSettingsList.push(cellSettings);\n                }\n                let nodesettings = {\n                    ci: nodeDeclaration.cellIndex,\n                    ys: {\n                        ly: nodeDeclaration.yearSelections.leftYear,\n                        ry: nodeDeclaration.yearSelections.rightYear\n                    },\n                    c: cellSettingsList[nodeDeclaration.cellIndex]\n                };\n                settings.push(nodesettings);\n            }\n            let branchstring = jsonpack.pack(query);\n            let bsencoded = encodeURIComponent(branchstring);\n            let settingsstring = jsonpack.pack(settings);\n            let ssencoded = encodeURIComponent(settingsstring);\n            let hashcode = hashCode(branchstring + settingsstring);\n            // console.log(\'query\',query, branchstring,branchstring.length,bsencoded,bsencoded.length)\n            // console.log(\'settings\',settings,settingsstring, settingsstring.length,ssencoded,ssencoded.length)\n            let url = location.hostname + \'/explorer?branch=\' + bsencoded + \'&settings=\' + ssencoded + \'&hash=\' + hashcode;\n            // console.log(\'url\',url,url.length)\n            return url;\n        };\n        // -------------------------------------[ handle dialog requests ]-----------------------\n        this.handleSelectionsDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Selections Dialog\'\n            });\n            this.setState({\n                selectionsDialogOpen: true\n            });\n        };\n        this.handleTechDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Show sources\'\n            });\n            this.setState({\n                techDialogOpen: true\n            });\n        };\n        this.handleNoticeDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Show notices\'\n            });\n            this.setState({\n                noticeDialogOpen: true\n            });\n        };\n        this.handleSelectionsDialogClose = () => {\n            this.setState({\n                selectionsDialogOpen: false\n            });\n        };\n        this.handleTechDialogClose = () => {\n            this.setState({\n                techDialogOpen: false\n            });\n        };\n        this.handleNoticeDialogClose = () => {\n            this.setState({\n                noticeDialogOpen: false\n            });\n        };\n        this.openwindow = url => {\n            open(url, \'_blank\');\n        };\n        this.getBranchDataMessages = () => {\n            if (!this.state.viewpointData) return null;\n            let { datasetConfig } = this.state.viewpointData.Meta;\n            let { DatasetTitle, Sources } = datasetConfig;\n            let { Messages } = Sources;\n            let messages = [];\n            for (let index in Messages) {\n                messages.push(react["createElement"]("div", { key: index }, Messages[index]));\n            }\n            // console.log(\'messages\',messages, Messages)\n            return messages.length > 0 ? react["createElement"]("div", { style: { padding: "3px", margin: "3px", backgroundColor: "LemonChiffon" } }, messages) : null;\n        };\n        this.getTechNotesDisplay = () => {\n            if (!this.state.viewpointData) return null;\n            let { datasetConfig } = this.state.viewpointData.Meta;\n            let { DatasetTitle, Sources } = datasetConfig;\n            let { Headers } = Sources;\n            // console.log(\'headers\',Headers)\n            let headerkeys = Object.keys(Headers);\n            let itemlist = headerkeys.map(headerkey => {\n                let item = Headers[headerkey];\n                let notes = item.NOTES_CONTENT;\n                let link = item.SOURCE_DOCUMENT_LINK_COPY;\n                let isvalidurl = validurl.isUri(link);\n                let doctitle = item.SOURCE_DOCUMENT_TITLE;\n                let tablelocation = item.SOURCE_DOCUMENT_TABLE_LOCATION;\n                let tabletitle = item.SOURCE_DOCUMENT_TABLE_TITLE;\n                // console.log(\'ListItem values\',notes, link, isvalidurl, doctitle, tablelocation,tabletitle)\n                return react["createElement"]("div", { key: headerkey, style: {\n                        marginBottom: "8px",\n                        border: "1px solid silver",\n                        borderRadius: "8px",\n                        padding: "3px"\n                    } }, react["createElement"](RaisedButton_default.a, { style: { marginLeft: "3px", float: "right" }, disabled: !isvalidurl, type: "button", label: "Source", onClick: () => {\n                        isvalidurl ? this.openwindow(link) : void 0;\n                    } }), react["createElement"]("div", { style: { fontWeight: "bold" } }, headerkey), react["createElement"]("div", { style: { whiteSpace: "normal" } }, react["createElement"]("div", null, "Document title: ", doctitle), !isvalidurl ? react["createElement"]("div", null, "Invalid link! no source available") : null, tabletitle ? react["createElement"]("div", null, "Table title: ", tabletitle) : null, tablelocation ? react["createElement"]("div", null, "Table location: ", tablelocation) : null, notes ? react["createElement"]("div", null, "Note: ", notes) : null));\n            });\n            return react["createElement"]("div", null, react["createElement"](Subheader_default.a, null, DatasetTitle), itemlist);\n        };\n        // handleSearchDialogOpen = (e) => {\n        //     this.props.handleSearchDialogOpen(e)\n        // }\n        this.taxonomychoices = {\n            FUNCTIONAL: "Programs by function",\n            STRUCTURAL: "Programs by org type",\n            ACTUALEXPENSES: "Expenses by function",\n            ACTUALREVENUES: "Revenues by type",\n            EXPENDITURES: "Expenses by type",\n            FINANCIALASSETS: "Financial assets",\n            TANGIBLEASSETS: "Tangible assets",\n            LIABILITIES: "Liabilities",\n            RESERVES: "Reserves"\n        };\n    }\n    // finish initialization of budgetBranch and branch explorer objects\n    componentWillMount() {\n        this._initialize();\n        let { budgetBranch, declarationData } = this.props;\n        let branchDeclarationData = declarationData.branchesById[budgetBranch.uid];\n        if (branchDeclarationData.story) {\n            this.story = branchDeclarationData.story;\n            this._stateActions.clearBranchStory(budgetBranch.uid);\n        }\n        budgetBranch.getViewpointData().then(() => {\n            // console.log(\'branch story var\',this.story)\n            this._stateActions.incrementBranchDataVersion(budgetBranch.uid); // change data generation counter for child compare\n            let story;\n            let explorerbranch = this;\n            if (this.story) {\n                story = explorerbranch.story;\n                explorerbranch._createStoryNodes(story, explorerbranch.state.viewpointData);\n                return; // should never fail as it is internal\n            } // else\n            if (branchDeclarationData.nodeList.length == 0) {\n                let { urlparms } = this.props;\n                if (urlparms) {\n                    if (this._createUrlNodes(urlparms)) return;\n                }\n                let budgetNodeParms = budgetBranch.getInitialBranchNodeParms();\n                // console.log(\'budgetNodeParms in branchWillMount\',budgetNodeParms)\n                this._stateActions.addNodeDeclaration(budgetNodeParms);\n            } else {\n                setTimeout(() => {\n                    this._stateActions.resetLastAction(); // trigger update -> render\n                });\n            }\n        }).catch(reason => {\n            console.error(\'error in data fetch, componentWillMount (branch)\', reason);\n        });\n    }\n    // ---------------------------[ lifecycle events ]--------------------------\n    // remove obsolete node objects\n    componentWillReceiveProps(nextProps) {\n        let { nodesById } = nextProps.declarationData;\n        let branchNodes = this.props.budgetBranch.nodes; // copy\n        let newBranchNodes = branchNodes.filter(node => {\n            return !!nodesById[node.uid];\n        });\n        if (newBranchNodes.length != branchNodes.length) {\n            // some nodes were deleted\n            this.setState({\n                branchNodes: newBranchNodes\n            });\n        }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        let show = false; // debug\n        // Exception: allow snackbar open through in any case\n        if (nextState.snackbar.open != this.state.snackbar.open) {\n            if (show) console.log(\'should update branch return true for snackbar\');\n            return true;\n        }\n        let branchComponent = this;\n        return filterActionsForUpdate(nextProps, branchComponent, show);\n    }\n    componentDidUpdate() {\n        // refresh branchnodes\n        let { budgetBranch, declarationData } = this.props;\n        let branchDeclarations = declarationData.branchesById[budgetBranch.uid];\n        let { nodeList } = branchDeclarations;\n        let { nodesById } = this.props.declarationData;\n        let branchNodes = this.props.budgetBranch.nodes; // copy\n        // harmonize is here for first setup; called from will mount for re-creation\n        if (!this.harmonizeNodesToState(branchNodes, nodeList, nodesById, budgetBranch)) {\n            this._respondToGlobalStateChange();\n        }\n        // console.log(\'nodes\', branchNodes)\n    }\n    // -------------------------------------[ render! ]---------------------------------\n    render() {\n        // ---------------------------------[ interactive controls ]--------------------------\n        let branch = this;\n        let drilldownrow = branch.props.budgetBranch.nodes;\n        // console.log(\'drilldownrow\',drilldownrow)\n        let drilldownportals = branch.getPortals(drilldownrow);\n        let branchDeclaration = this.props.declarationData.branchesById[this.props.budgetBranch.uid];\n        let viewpointselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'23px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Select dataset:")), react["createElement"](DropDownMenu_default.a, { value: branchDeclaration.viewpoint, onChange: (e, index, value) => {\n                branch.selectViewpoint(value);\n            } }, react["createElement"]("div", { style: { padding: "3px", fontStyle: \'italic\' } }, "Internal Budget"), react["createElement"](MenuItem_default.a, { value: \'FUNCTIONAL\', primaryText: this.taxonomychoices.FUNCTIONAL }), react["createElement"](MenuItem_default.a, { value: \'STRUCTURAL\', primaryText: this.taxonomychoices.STRUCTURAL }), react["createElement"]("div", { style: { padding: "3px", fontStyle: \'italic\' } }, "Audited Actual"), react["createElement"](MenuItem_default.a, { value: \'ACTUALEXPENSES\', primaryText: this.taxonomychoices.ACTUALEXPENSES }), react["createElement"](MenuItem_default.a, { value: \'ACTUALREVENUES\', primaryText: this.taxonomychoices.ACTUALREVENUES }), react["createElement"](MenuItem_default.a, { value: \'EXPENDITURES\', primaryText: this.taxonomychoices.EXPENDITURES }), react["createElement"](MenuItem_default.a, { value: \'FINANCIALASSETS\', primaryText: this.taxonomychoices.FINANCIALASSETS }), react["createElement"](MenuItem_default.a, { value: \'LIABILITIES\', primaryText: this.taxonomychoices.LIABILITIES }), react["createElement"](MenuItem_default.a, { value: \'NONFINANCIALASSETS\', primaryText: this.taxonomychoices.TANGIBLEASSETS }), react["createElement"](MenuItem_default.a, { value: \'RESERVES\', primaryText: this.taxonomychoices.RESERVES }))));\n        // <span style={{ fontStyle: "italic" }}>Government: </span>\n        let governmentselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "City:")), react["createElement"](DropDownMenu_default.a, { value: "Toronto", disabled: true }, react["createElement"](MenuItem_default.a, { value: \'Toronto\', primaryText: "Toronto, Ontario" })));\n        // TODO externalize this; make it metadata-driven\n        const versionchoices = () => {\n            switch (branchDeclaration.viewpoint) {\n                case "FUNCTIONAL":\n                case "STRUCTURAL":\n                    return [react["createElement"](MenuItem_default.a, { key: 1, value: \'SUMMARY\', primaryText: "Summary PDF reports 2003 - 2017" }, react["createElement"]("em", null, "This data is shallower, but goes back further:")), react["createElement"](MenuItem_default.a, { key: 2, value: \'PBFT\', primaryText: "Detail open data portal files 2011 - 2017" }, react["createElement"]("em", null, "This data drills down to Account Categories:")), react["createElement"](MenuItem_default.a, { key: 3, disabled: true, value: \'VARIANCE\', primaryText: "PDF Variance Reports" })];\n                case \'ACTUALEXPENSES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'ACTUALEXPENSES\', primaryText: "Audited statements 1998 - 2016" })];\n                case \'ACTUALREVENUES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'ACTUALREVENUES\', primaryText: "Audited statements 1998 - 2016" })];\n                case \'EXPENDITURES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'EXPENDITURES\', primaryText: "Audited statements 1998 - 2016" })];\n                case \'FINANCIALASSETS\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'FINANCIALASSETS\', primaryText: "Audited statements 2010 - 2016" })];\n                case \'NONFINANCIALASSETS\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'NONFINANCIALASSETS\', primaryText: "Audited statements 2010 - 2016" })];\n                case \'LIABILITIES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'LIABILITIES\', primaryText: "Audited statements 2010 - 2016" })];\n                case \'RESERVES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'RESERVES\', primaryText: "Audited statements 2010 - 2016" })];\n            }\n        };\n        // TODO: add contitional logic depending on viewpoint selection\n        let versionselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Data source:")), react["createElement"](DropDownMenu_default.a, { disabled: versionchoices().length < 2, value: branchDeclaration.version, onChange: (e, index, value) => {\n                branch.selectVersion(value);\n            } }, versionchoices()));\n        // TODO externalize this; make it metadata-driven\n        const aspectchoices = () => {\n            // console.log(\'branchdeclaration.viewpoint\',branchDeclaration.viewpoint)\n            switch (branchDeclaration.viewpoint) {\n                case "FUNCTIONAL":\n                case "STRUCTURAL":\n                    return [react["createElement"](MenuItem_default.a, { key: 1, value: \'Expenses\', primaryText: "Expenditures" }), react["createElement"](MenuItem_default.a, { key: 2, value: \'Revenues\', primaryText: "Receipts" }), react["createElement"](MenuItem_default.a, { key: 3, value: \'Staffing\', primaryText: "Staffing" })];\n                case \'ACTUALEXPENSES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Expenses\', primaryText: "Expenses" })];\n                case \'ACTUALREVENUES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Revenues\', primaryText: "Revenues" })];\n                case \'EXPENDITURES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Expenditure\', primaryText: "Expenses" })];\n                case \'FINANCIALASSETS\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Assets\', primaryText: "Assets" })];\n                case \'NONFINANCIALASSETS\':\n                    {\n                        return [react["createElement"](MenuItem_default.a, { key: 4, value: \'TangibleAssets\', primaryText: "Tangible Assets" })];\n                    }\n                case \'LIABILITIES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Liabilities\', primaryText: "Liabilities" })];\n                case \'RESERVES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Reserves\', primaryText: "Reserves" })];\n            }\n        };\n        // aspect = category\n        let aspectselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Category:")), react["createElement"](DropDownMenu_default.a, { disabled: aspectchoices().length < 2, value: branchDeclaration.aspect, onChange: (e, index, value) => {\n                branch.selectAspect(value);\n            } }, aspectchoices()));\n        let byunitselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Prorated:")), react["createElement"](DropDownMenu_default.a, { value: branchDeclaration.prorata, onChange: (e, index, value) => {\n                this.switchComparator(value);\n            } }, react["createElement"](MenuItem_default.a, { value: \'OFF\', primaryText: "Off" }), react["createElement"](MenuItem_default.a, { value: \'PERPERSON\', primaryText: "Per resident" }), react["createElement"](MenuItem_default.a, { value: \'PER100000PERSONS\', primaryText: "Per 100,000 people" }), react["createElement"](MenuItem_default.a, { value: \'PERHOUSEHOLD\', primaryText: "Per household" }), react["createElement"](MenuItem_default.a, { value: \'PER40000HOUSEHOLDS\', primaryText: "Per 40,000 households" }), react["createElement"](MenuItem_default.a, { value: \'PERWARD\', primaryText: "Per ward (x 44)" }), react["createElement"](MenuItem_default.a, { value: \'PERNEIGHBOURHOOD\', primaryText: "Per neighbourhood (x 4 x 44)" })));\n        let inflationadjustment = react["createElement"]("div", { style: {\n                display: \'inline-block\',\n                whiteSpace: "nowrap",\n                verticalAlign: "top",\n                marginRight: \'16px\'\n            } }, react["createElement"](Toggle_default.a, { label: \'Inflation adjusted:\', style: {\n                height: \'32px\',\n                marginTop: \'16px\',\n                display: \'inline-block\'\n            }, onToggle: (e, value) => {\n                this.toggleInflationAdjustment(value);\n            }, labelStyle: {\n                fontStyle: \'italic\'\n            }, defaultToggled: branchDeclaration.inflationAdjusted }));\n        let showcontrols = react["createElement"]("div", { style: {\n                display: \'inline-block\',\n                whiteSpace: "nowrap",\n                verticalAlign: "top"\n            } }, react["createElement"](Toggle_default.a, { label: \'Show chart controls:\', style: { height: \'32px\', marginTop: \'16px\' }, labelStyle: { fontStyle: \'italic\' }, defaultToggled: branchDeclaration.showOptions, onToggle: (e, value) => {\n                this.toggleShowOptions(value);\n            } }));\n        // dialogs\n        let selectionsdialog = branchDeclaration.showOptions ? react["createElement"](Dialog_default.a, { title: "Select dataset for this row of charts", modal: false, open: branch.state.selectionsDialogOpen, onRequestClose: branch.handleSelectionsDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: branch.handleSelectionsDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", null, react["createElement"]("div", null, governmentselection), react["createElement"]("div", null, viewpointselection), react["createElement"]("div", null, versionselection), react["createElement"]("div", null, aspectselection)), react["createElement"](RaisedButton_default.a, { label: "Done", style: { margin: \'3px 6px 0 0\', float: \'right\' }, onClick: branch.handleSelectionsDialogClose }), react["createElement"]("div", null)) : null;\n        let noticesdialog = branchDeclaration.showOptions ? react["createElement"](Dialog_default.a, { title: "Notices for this data", modal: false, open: branch.state.noticeDialogOpen, onRequestClose: branch.handleNoticeDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: branch.handleNoticeDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), branch.state.noticeDialogOpen ? branch.getBranchDataMessages() : null) : null;\n        let technotesdialog = branchDeclaration.showOptions ? react["createElement"](Dialog_default.a, { title: "Row Data Sources", modal: false, open: branch.state.techDialogOpen, onRequestClose: branch.handleTechDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: branch.handleTechDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", null, "Please report any problems to ", react["createElement"]("a", { target: "_blank", href: "mailto:mail@budgetpedia.ca" }, "mail@budgetpedia.ca"), " "), branch.state.techDialogOpen ? branch.getTechNotesDisplay() : null, react["createElement"]("div", null, "Note: some historical numbers have been allocated to contemporary categories for continuity -- to make the numbers more easily comparable. We plan to disclose continuity details here.")) : null;\n        // dialog calls\n        let technotes = react["createElement"](RaisedButton_default.a, { style: { margin: \'3px 6px 0 0\' }, type: "button", label: "Sources", onClick: branch.handleTechDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "cloud") });\n        let notices = react["createElement"](RaisedButton_default.a, { style: { margin: \'3px 6px 0 0\' }, type: "button", label: "Notices", onClick: branch.handleNoticeDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "priority_high") });\n        let makeselections = react["createElement"](RaisedButton_default.a, { label: "Select dataset", style: { margin: \'3px 6px 0 0\' }, type: "button", onClick: branch.handleSelectionsDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "settings_applications") });\n        let viewtaxonomy = react["createElement"](RaisedButton_default.a, { label: "Dataset tree", style: { margin: \'3px 6px 0 0\' }, type: "button", onClick: () => {\n                let viewpointselection = {\n                    viewpoint: branchDeclaration.viewpoint,\n                    name: this.taxonomychoices[branchDeclaration.viewpoint]\n                };\n                this.props.onCallViewTaxonomy(this.state.viewpointData, viewpointselection, this.applytaxonomyselection);\n            }, labelPosition: "before", icon: react["createElement"]("img", { style: { width: \'24px\' }, src: "./public/icons/org_chart.svg" }) });\n        let search = react["createElement"](RaisedButton_default.a, { label: "Search", style: { margin: \'3px 6px 0 0\' }, type: "button", onClick: this.handleSearch, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5)\' }, className: "material-icons" }, "search") });\n        let shareurl = react["createElement"](RaisedButton_default.a, { type: "button", style: { margin: \'3px 6px 0 0\' }, label: "Share", onClick: this.shareBranch, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5)\' }, className: "material-icons" }, "share") });\n        // assemble the page\n        // if (branchDeclaration.showOptions) {\n        //     // this.animations.controls = this.animations.buttons = animations.zoomInLeft\n        // } else {\n        //     this.animations.controls = this.animations.buttons = animations.zoomOutLeft\n        // }\n        let maxheight = branchDeclaration.showOptions ? \'130px\' : \'0\';\n        let height = branchDeclaration.showOptions ? \'52px\' : \'0\';\n        let maxwidth = branchDeclaration.showOptions ? \'600px\' : \'0\';\n        return react["createElement"](explorerbranch_StyleRoot, null, react["createElement"]("div", { style: { marginBottom: \'12px\' } }, " ", react["createElement"]("div", null, react["createElement"]("div", { style: { maxHeight: maxheight, transition: \'max-height .5s\', overflow: \'hidden\' } }, react["createElement"]("div", { style: [this.state.animations.buttons, { marginBottom: \'12px\' }] }, makeselections, viewtaxonomy, search, shareurl, technotes, notices), selectionsdialog, noticesdialog, technotesdialog), react["createElement"]("div", { style: [this.state.animations.controls, {\n                height,\n                maxWidth: maxwidth,\n                overflow: \'hidden\',\n                display: "inline-block",\n                transition: \'height .3s,max-width .3s\'\n            }] }, react["createElement"]("div", { style: { height: \'48px\',\n                whiteSpace: \'nowrap\',\n                display: "inline-block",\n                backgroundColor: "#ebfaf9",\n                border: "1px solid silver",\n                borderRadius: "8px",\n                marginRight: "6px",\n                paddingLeft: "6px"\n            } }, byunitselection, inflationadjustment)), showcontrols)), react["createElement"]("div", { style: { whiteSpace: "nowrap" } }, react["createElement"]("div", { ref: node => {\n                branch.branchScrollBlock = node;\n            }, style: { overflow: "scroll" } }, drilldownportals, react["createElement"]("div", { style: { display: "inline-block", width: "500px", height: "20px" } }))), react["createElement"](Snackbar_default.a, { open: this.state.snackbar.open, message: this.state.snackbar.message, autoHideDuration: 4000, onRequestClose: this.handleSnackbarRequestClose }));\n    }\n}\n/* harmony default export */ var components_explorerbranch = (explorerbranch_ExplorerBranch);\n// EXTERNAL MODULE: ./node_modules/material-ui/AutoComplete/index.js\nvar AutoComplete = __webpack_require__(1158);\nvar AutoComplete_default = /*#__PURE__*/__webpack_require__.n(AutoComplete);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/RadioButton/index.js\nvar RadioButton = __webpack_require__(1149);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/components/searchdialog.tsx\n// searchdialog.tsx\n/*\n    TODO: should cache lookup list in parent\n*/\n\n\n\nvar { Component: searchdialog_Component } = react;\n\n\n\n\n\n\n\n\nlet searchdialog_ReactGA = __webpack_require__(533);\nlet SearchDialog = class extends searchdialog_Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            dialogOpen: true,\n            searchDialogAspect: \'expenses\'\n        };\n        this.logEvent = parms => {\n            if (window.location.hostname == \'budgetpedia.ca\') {\n                searchdialog_ReactGA.event(parms);\n            }\n        };\n        this.findChartLookups = null;\n        this.finderLookupPromise = path => {\n            let root = \'./db/repositories/toronto/\';\n            let filespec = root + path;\n            let promise = new Promise((resolve, reject) => {\n                fetch(filespec).then(response => {\n                    if (response.ok) {\n                        // console.log(\'response for \' + path,response)\n                        try {\n                            let json = response.json().then(json => {\n                                resolve(json);\n                            }).catch(reason => {\n                                let msg = \'failure to resolve \' + path + \' \' + reason;\n                                console.log(msg);\n                                reject(msg);\n                            });\n                        } catch (e) {\n                            console.log(\'error \' + path, e.message);\n                            reject(\'failure to load \' + path);\n                        }\n                    } else {\n                        reject(\'could not load file \' + path);\n                    }\n                }).catch(reason => {\n                    reject(reason + \' \' + path);\n                });\n            });\n            return promise;\n        };\n        this.getAllFindLookups = () => {\n            let summaryPromise = this.finderLookupPromise(\'datasets/summary/lookups/lookups.json\');\n            let pbftPromise = this.finderLookupPromise(\'datasets/pbft/lookups/lookups.json\');\n            let actualExpensesPromise = this.finderLookupPromise(\'datasets/actualexpenses/lookups/lookups.json\');\n            let actualRevenuesPromise = this.finderLookupPromise(\'datasets/actualrevenues/lookups/lookups.json\');\n            let expensesByObjectPromise = this.finderLookupPromise(\'datasets/expenditures/lookups/lookups.json\');\n            let functionalViewpointPromise = this.finderLookupPromise(\'viewpoints/functional.json\');\n            let structuralViewpointPromise = this.finderLookupPromise(\'viewpoints/structural.json\');\n            let actualExpensesViewpointPromise = this.finderLookupPromise(\'viewpoints/actualexpenses.json\');\n            let actualRevenuesViewpointPromise = this.finderLookupPromise(\'viewpoints/actualrevenues.json\');\n            let expendituresViewpointPromise = this.finderLookupPromise(\'viewpoints/expenditures.json\');\n            let promise = new Promise((resolve, reject) => {\n                Promise.all([summaryPromise, pbftPromise, actualExpensesPromise, actualRevenuesPromise, expensesByObjectPromise, functionalViewpointPromise, structuralViewpointPromise, actualExpensesViewpointPromise, actualRevenuesViewpointPromise, expendituresViewpointPromise]).then(values => {\n                    // pick out viewpint lookups from viewpoint structures\n                    for (let i = 5; i < 10; i++) {\n                        values[i] = values[i][\'Meta\'].Lookups;\n                    }\n                    let lookups;\n                    lookups = {\n                        datasets: {\n                            summarybudgets: values[0],\n                            detailedbudgets: values[1],\n                            auditedexpenses: values[2],\n                            auditedrevenues: values[3],\n                            auditedexpenditures: values[4]\n                        },\n                        viewpoints: {\n                            functionalbudget: values[5],\n                            structuralbudget: values[6],\n                            actualexpenses: values[7],\n                            actualrevenues: values[8],\n                            expenditures: values[9]\n                        }\n                    };\n                    resolve(lookups);\n                }).catch(reason => {\n                    reject(reason);\n                });\n            });\n            return promise;\n        };\n        // coerce raw lookup data into form suitable for autofill field\n        /*\n            viewpoint\n            dataset\n            aspects:{}\n            dimension\n            code\n            name\n            value\n        */\n        // TODO: the values here should be taken from source; automatic update\n        this.findDictionary = {\n            // viewpoints\n            structuralbudget: \'Structural Budget\',\n            functionalbudget: \'Functional Budget\',\n            actualexpenses: \'Actual Expenses\',\n            actualrevenues: \'Actual Revenues\',\n            expenditures: \'Expenses by Object\',\n            // sources\n            auditedrevenues: \'Audited Statements\',\n            auditedexpenses: \'Audited Statements\',\n            auditedexpenditures: \'Audited Statements\',\n            detailedbudgets: \'Detailed Budgets\',\n            summarybudgets: \'Summary Budgets\',\n            // levels (collation)\n            Taxonomy: \'01-Taxonomy\',\n            auditedexpense: "07-Expenses",\n            auditedrevenue: "08-Revenues",\n            program: \'02-Programs\',\n            service: \'03-Services\',\n            activity: \'04-Activities\',\n            expense: \'06-Expenditures\',\n            revenue: \'05-Receipts\',\n            permanence: \'09-Permanence\',\n            expenditure: "10-Expenses"\n        };\n        this.processFindChartLookups = data => {\n            let collation = {\n                Taxonomy: \'01-taxonomy\',\n                auditedexpense: \'07-audited expense\',\n                auditedrevenue: \'08-audited revenue\',\n                program: \'02-program\',\n                service: \'03-service\',\n                activity: \'04-activity\',\n                expense: \'06-expense\',\n                revenue: \'05-revenue\',\n                permanence: \'09-permanence\',\n                expenditure: \'10-expenditure\'\n            };\n            let lookups = [];\n            let { viewpoints, datasets } = data;\n            // default viewpoints\n            let sourceviewpoints = {\n                auditedexpenses: \'actualexpenses\',\n                auditedrevenues: \'actualrevenues\',\n                auditedexpenditures: \'expenditures\',\n                detailedbudgets: \'functionalbudget\',\n                summarybudgets: \'functionalbudget\'\n            };\n            let alternatesourceviewpoints = {\n                detailedbudgets: \'structuralbudget\',\n                summarybudgets: \'structuralbudget\'\n            };\n            let sourceaspects = {\n                auditedexpenses: { expenses: true },\n                auditedrevenues: { revenues: true },\n                auditedexpenditures: { expenses: true },\n                detailedbudgets: { expenses: true, revenues: true, staffing: true },\n                summarybudgets: { expenses: true, revenues: true, staffing: true }\n            };\n            let dictionary = this.findDictionary;\n            for (let datasetname in datasets) {\n                let dataset = datasets[datasetname];\n                for (let dimensionname in dataset) {\n                    let dimension = dataset[dimensionname];\n                    if (datasetname == \'detailedbudgets\') {\n                        // console.log(\'processing detailed budgets for dimension\',dimensionname)\n                        switch (dimensionname) {\n                            case \'activity\':\n                                sourceaspects.detailedbudgets = { expenses: true, revenues: true, staffing: false };\n                                break;\n                            case \'expense\':\n                                sourceaspects.detailedbudgets = { expenses: true, revenues: false, staffing: false };\n                                break;\n                            case \'permanence\':\n                                sourceaspects.detailedbudgets = { expenses: false, revenues: false, staffing: true };\n                                break;\n                            case \'program\':\n                                sourceaspects.detailedbudgets = { expenses: true, revenues: true, staffing: true };\n                                break;\n                            case \'revenue\':\n                                sourceaspects.detailedbudgets = { expenses: false, revenues: true, staffing: false };\n                                break;\n                            case \'service\':\n                                sourceaspects.detailedbudgets = { expenses: true, revenues: true, staffing: false };\n                                break;\n                        }\n                    }\n                    let dimensionlookupname;\n                    if (datasetname == \'auditedrevenues\') {\n                        dimensionlookupname = \'auditedrevenue\';\n                    } else if (datasetname == \'auditedexpenses\') {\n                        dimensionlookupname = \'auditedexpense\';\n                    } else {\n                        dimensionlookupname = dimensionname;\n                    }\n                    for (let code in dimension) {\n                        let name = dimension[code];\n                        let sortname = \'(\' + collation[dimensionname] + \') \' + name;\n                        let selection = {\n                            viewpoint: sourceviewpoints[datasetname],\n                            datasource: datasetname,\n                            aspects: sourceaspects[datasetname],\n                            dimension: dimensionname,\n                            code,\n                            name,\n                            sortname,\n                            value: react["createElement"](MenuItem_default.a, { style: { whiteSpace: \'normal\', lineHeight: \'150%\' } }, react["createElement"]("div", null, react["createElement"]("span", { style: { fontWeight: "bold" } }, name)), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "dataset: ", dictionary[sourceviewpoints[datasetname]])), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "scope: ", dictionary[dimensionlookupname], " ")), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "data source: ", dictionary[datasetname])))\n                        };\n                        lookups.push(selection);\n                        // including structuralviewpoint for all relevant choices is annoying (duplicates)\n                        //  suppress for now\n                        if (datasetname == \'detailedbudgets\' || datasetname == \'summarybudgets\') {\n                            let sortname = \'(\' + collation[dimensionname] + \') \' + name;\n                            let selection = {\n                                viewpoint: alternatesourceviewpoints[datasetname],\n                                datasource: datasetname,\n                                aspects: sourceaspects[datasetname],\n                                dimension: dimensionname,\n                                code,\n                                name,\n                                sortname,\n                                value: react["createElement"](MenuItem_default.a, { style: { whiteSpace: \'normal\', lineHeight: \'150%\' } }, react["createElement"]("div", null, react["createElement"]("span", { style: { fontWeight: "bold" } }, name)), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "dataset: ", dictionary[alternatesourceviewpoints[datasetname]])), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "scope: ", dictionary[dimensionname], " ")), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "data source: ", dictionary[datasetname])))\n                            };\n                            lookups.push(selection);\n                        }\n                    }\n                }\n            }\n            // default viewpoint sources\n            let viewpointsources = {\n                actualexpenses: \'auditedexpenses\',\n                actualrevenues: \'auditedrevenues\',\n                expenditures: \'auditedexpenditures\',\n                functionalbudget: \'summarybudgets\',\n                structuralbudget: \'summarybudgets\'\n            };\n            let viewpointaspects = {\n                actualexpenses: { expenses: true },\n                actualrevenues: { revenues: true },\n                expenditures: { expenses: true },\n                functionalbudget: { expenses: true, revenues: true, staffing: true },\n                structuralbudget: { expenses: true, revenues: true, staffing: true }\n            };\n            for (let viewpointname in viewpoints) {\n                let viewpoint = viewpoints[viewpointname];\n                for (let dimensionname in viewpoint) {\n                    let dimension = viewpoint[dimensionname];\n                    for (let code in dimension) {\n                        let name = dimension[code];\n                        let sortname = \'(\' + collation[dimensionname] + \') \' + name;\n                        let selection = {\n                            viewpoint: viewpointname,\n                            datasource: viewpointsources[viewpointname],\n                            aspects: viewpointaspects[viewpointname],\n                            dimension: dimensionname,\n                            code,\n                            name,\n                            sortname,\n                            value: react["createElement"](MenuItem_default.a, { style: { whiteSpace: \'normal\', lineHeight: \'150%\' } }, react["createElement"]("div", null, react["createElement"]("span", { style: { fontWeight: "bold" } }, name)), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "dataset: ", dictionary[viewpointname])), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "scope: ", dictionary[dimensionname], " ")), react["createElement"]("div", { style: { display: \'inline-block\', whiteSpace: \'nowrap\', paddingRight: \'20px\' } }, react["createElement"]("span", { style: { fontStyle: "italic", color: "gray" } }, "data source: ", dictionary[viewpointsources[viewpointname]])))\n                        };\n                        lookups.push(selection);\n                    }\n                }\n            }\n            return lookups;\n        };\n        this.findOnNewRequest = (chosenRequest, index) => {\n            // console.log(\'findOnNewRequest\',this.findAspectChartLookups)\n            if (index == -1) {\n                this.resetSelectionParameters();\n            } else {\n                let item = this.findAspectChartLookups[index];\n                let dictionary = this.findDictionary;\n                // console.log(\'selected item\',item)\n                this.findSelection = {\n                    known: true,\n                    level: item.dimension,\n                    leveldisplay: dictionary[item.dimension],\n                    source: item.datasource,\n                    sourcedisplay: dictionary[item.datasource],\n                    viewpoint: item.viewpoint,\n                    viewpointdisplay: dictionary[item.viewpoint],\n                    code: item.code,\n                    name: item.name\n                };\n                this.forceUpdate();\n            }\n        };\n        this.findClearSearchText = () => {\n            let instance = this.refs[\'autocomplete\'];\n            instance.setState({ searchText: \'\' });\n            // instance.focus();\n        };\n        this.findSelection = {\n            known: false,\n            viewpoint: null,\n            viewpointdisplay: \'?\',\n            source: null,\n            sourcedisplay: \'?\',\n            level: null,\n            leveldisplay: \'?\',\n            code: null,\n            name: null\n        };\n        this.findOnUpdateInput = () => {\n            // console.log(\'findOnUpdateInput\',this.findAspectChartLookups,this.findSelection)\n            if (this.findSelection.known) {\n                this.resetSelectionParameters();\n                this.forceUpdate();\n            }\n        };\n        this.onChangeFindAspect = (e, value) => {\n            this.findAspectChartLookups = null;\n            this.findClearSearchText();\n            this.resetSelectionParameters();\n            this.setState({\n                searchDialogAspect: value\n            });\n        };\n        this.resetSelectionParameters = () => {\n            this.findSelection = {\n                known: false,\n                viewpoint: null,\n                viewpointdisplay: \'?\',\n                source: null,\n                sourcedisplay: \'?\',\n                level: null,\n                leveldisplay: \'?\',\n                code: null,\n                name: null\n            };\n        };\n        this.getFindAspectLookups = () => {\n            let self = this;\n            // console.log(\'in getFindAspectLookups\',self.state, self.findChartLookups)\n            if (!self.findChartLookups) {\n                self.findAspectChartLookups = null;\n                return;\n            }\n            let sourcelist = self.findChartLookups;\n            // console.log(\'sourcelist\',sourcelist)\n            let targetlist = [];\n            let aspect = self.state.searchDialogAspect;\n            for (let item of sourcelist) {\n                if (!(item.viewpoint == \'structuralbudget\') && !(item.datasource == \'detailedbudgets\' && item.sortname < \'(03\')) {\n                    if (item.aspects[aspect]) {\n                        targetlist.push(item);\n                    }\n                }\n            }\n            targetlist.sort((a, b) => {\n                if (a.sortname < b.sortname) return -1;\n                if (a.sortname > b.sortname) return 1;\n                return 0;\n            });\n            self.findAspectChartLookups = targetlist;\n        };\n        this.findAspectChartLookups = null;\n        this.findParameters = {\n            parms: null\n        };\n        this.findApplyChart = () => {\n            let explorer = this;\n            explorer.onRequestClose();\n            let selection = explorer.findSelection;\n            let parms = {\n                viewpoint: selection.viewpoint,\n                source: selection.source,\n                level: selection.level,\n                code: selection.code,\n                aspect: explorer.state.searchDialogAspect,\n                name: selection.name\n            };\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Find chart\',\n                label: parms.name\n            });\n            explorer.findParameters.parms = parms;\n            explorer.props.onConfirm(parms);\n        };\n        this.onRequestClose = () => {\n            this.props.onRequestClose();\n        };\n        this.searchDialog = () => {\n            // console.log(\'returning dialog\',this.findAspectChartLookups)\n            return react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Find a Chart"), modal: false, open: this.state.dialogOpen, onRequestClose: this.onRequestClose, autoScrollBodyContent: false, contentStyle: { maxWidth: \'600px\' }, autoDetectWindowHeight: false }, react["createElement"]("div", null, react["createElement"](AutoComplete_default.a, { ref: \'autocomplete\', floatingLabelText: "type in a key word, then select a list item (sorted by scope)", filter: AutoComplete_default.a.caseInsensitiveFilter, dataSource: this.findAspectChartLookups || [], dataSourceConfig: { text: \'name\', value: \'value\' }, fullWidth: true, openOnFocus: false, style: { width: \'100%\' }, menuStyle: { maxHeight: "300px", overflowY: \'auto\' }, maxSearchResults: 80, onNewRequest: this.findOnNewRequest, onUpdateInput: this.findOnUpdateInput, autoFocus: true }), react["createElement"](RadioButton["RadioButtonGroup"], { valueSelected: this.state.searchDialogAspect, name: "findchart", onChange: this.onChangeFindAspect }, react["createElement"](RadioButton["RadioButton"], { style: { display: \'inline-block\', width: \'auto\', marginRight: \'50px\' }, value: "expenses", label: "expenditures/expenses" }), react["createElement"](RadioButton["RadioButton"], { style: { display: \'inline-block\', width: \'auto\', marginRight: \'50px\' }, value: "revenues", label: "receipts/revenues" }), react["createElement"](RadioButton["RadioButton"], { style: { display: \'inline-block\', width: \'auto\', marginRight: \'50px\' }, value: "staffing", label: "staffing" }))), react["createElement"](IconButton_default.a, { style: {\n                    top: 0,\n                    right: 0,\n                    padding: 0,\n                    height: "36px",\n                    width: "36px",\n                    position: "absolute",\n                    zIndex: 2\n                }, onClick: this.onRequestClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", { style: { padding: "8px" } }, react["createElement"]("div", { style: { whiteSpace: \'nowrap\', display: \'inline-block\' } }, react["createElement"]("span", { style: { color: \'silver\', fontStyle: \'italic\' } }, "dataset: "), react["createElement"]("span", { style: { color: this.findSelection.known ? \'black\' : \'silver\', marginRight: \'50px\', fontStyle: \'italic\' } }, this.findSelection.viewpointdisplay)), react["createElement"]("div", { style: { whiteSpace: \'nowrap\', display: \'inline-block\' } }, react["createElement"]("span", { style: { color: \'silver\', fontStyle: \'italic\' } }, "scope: "), react["createElement"]("span", { style: { color: this.findSelection.known ? \'black\' : \'silver\', marginRight: \'50px\', fontStyle: \'italic\' } }, this.findSelection.leveldisplay)), react["createElement"]("div", { style: { whiteSpace: \'nowrap\', display: \'inline-block\' } }, react["createElement"]("span", { style: { color: \'silver\', fontStyle: \'italic\' } }, "data source: "), react["createElement"]("span", { style: { color: this.findSelection.known ? \'black\' : \'silver\', marginRight: \'50px\', fontStyle: \'italic\' } }, this.findSelection.sourcedisplay))), react["createElement"]("div", null, react["createElement"](RaisedButton_default.a, { disabled: !this.findSelection.known, onClick: this.findApplyChart, label: "Apply", primary: true, style: { marginRight: "50px" } }), react["createElement"](RaisedButton_default.a, { disabled: false, onClick: this.onRequestClose, label: "Cancel", secondary: true })), react["createElement"]("div", { style: { height: \'200px\' } }));\n        };\n    }\n    componentWillMount() {\n        this.getAllFindLookups().then(data => {\n            // console.log(\'sourcedata\', data)\n            this.findChartLookups = this.processFindChartLookups(data);\n            this.forceUpdate(); // inject data into autocomplete\n        }).catch(reason => {\n            lib["toastr"].error(\'Error loading finder lookups: \' + reason);\n        });\n    }\n    componentDidMount() {\n        // console.log(\'did mount\')\n        this.resetSelectionParameters();\n    }\n    render() {\n        if (this.state.dialogOpen && !this.findAspectChartLookups) {\n            this.getFindAspectLookups();\n        }\n        let dialog = this.searchDialog();\n        return dialog;\n    }\n};\n/* harmony default export */ var searchdialog = (SearchDialog);\n// EXTERNAL MODULE: ./ts/addons/explorer/reducers.tsx\nvar reducers = __webpack_require__(473);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/content/helpcontent.tsx\n// helpcontent.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorerbranch.tsx\n\n\n\n\nlet content = react["createElement"]("div", null, react["createElement"](Card["Card"], null, react["createElement"](Card["CardText"], null, "The best way to become familiar with the explorer is to ", react["createElement"]("span", { style: { fontStyle: \'italic\' } }, "play with it"), " (experiment). Once in a while, review the lists below. Click on any title below for details."), react["createElement"](Card["CardText"], null, "For some explanatory screencasts, see our ", react["createElement"]("a", { target: "_blank", href: "https://www.youtube.com/channel/UCatXKvLCA5qGkzj3jw8AQig" }, "YouTube channel"), ".")), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Dataset Options"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, "There are several dataset options available for charts:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Taxonomy")), react["createElement"]("dd", null, " a taxonomy is a classification scheme of a set of accounts."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Dataset")), react["createElement"]("dd", null, "alternate detailed datasets available for the selected Taxonomy (see the Budgetpedia project\'s ", react["createElement"]("a", { target: "_blank", href: "https://drive.google.com/drive/u/0/folders/0B208oCU9D8OuM2NmUk9XR1VCbEU" }, "research repository)")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Category")), react["createElement"]("dd", null, " particular aspects of the dataset, including Revenue, Expenses or Staffing"), react["createElement"]("dt", null, react["createElement"]("strong", null, "Prorated")), react["createElement"]("dd", null, " the beginnings of diagnostic analytics, using simple math to view the data compared with relevant related metrics, such as per person or per household"), react["createElement"]("dt", null, react["createElement"]("strong", null, "Inflation adjusted")), react["createElement"]("dd", null, " the datasets are updated annually to reflect the Bank of Canada\'s Inflation Calculator. This makes it possible to get historical perspectives that are meaningful in today\'s dollar terms.")), react["createElement"]("p", null, "Choices for the selections are interdependent. Toronto budgets have similar classifications for Revenue and Expenses for example, and therefore these can be viewed together. Financial statements on the other hand do not have similar classifications for Revenue and Expenses."), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Taxonomy")), " choices include:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Programs by function (budget)")), react["createElement"]("dd", null, "combines City of Toronto Agencies and Divisions into groups according to the nature of the services delivered (this is the default). The classification scheme above the Division/Agency level was developed by Budgetpedia project contributors."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Programs by org type (budget)")), react["createElement"]("dd", null, "more traditional: separates Agencies from Divisions, and generally by organizational structures. Groupings are closer to those found in City annual Budget Summaries."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses by function (actual), and Revenues by type (actual)")), react["createElement"]("dd", null, "These reporting structures are manadated by the province (and GAAP -- Generally Accepted Accounting Principles). They are comparable to other municipalities in the province. Summary groupings above the statment levels are added by the Budgetpedia project for easier access."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses by type (actual)")), react["createElement"]("dd", null, "Expenses by type is a restatement of expenses by object of expenditure, such as materials, or Wages & Salaries. These categories cross all Divisions and Agencies, and therefore provide a general picture of the ways that money is spent.")), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Dataset")), " choices depend on the Taxonomy that is chosen."), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("em", null, "For budget taxonomies (both functional and org type), Versions"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Summary PDF Reports 2003 - 2016")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Detailed open data files 2011 - 2016")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Variance Reports"), " ", react["createElement"]("em", null, "[deferred]")))), react["createElement"]("dd", null, "The detailed files are generated by ", react["createElement"]("em", null, "PBFT"), " which stands for ", react["createElement"]("em", null, "Public Budget Formulation Tool"), " which is part of the City\'s new FPARS (Financial Planning Analysis and Reporting System) system"), react["createElement"]("dt", { style: { marginTop: "20px" } }, react["createElement"]("em", null, "For Viewpoint = Audited Expenses or Revenues, Source"), " includes:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Audited Statements 1998 - 2015")), react["createElement"]("dt", null, react["createElement"]("strong", null, "to come: Financial Information Returns")))), react["createElement"]("dd", null, "FIR for MMAH = Financial Information Returns for the Ontario Ministry of Municipal Affairs and Housing.")), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "CAtegory")), " choices depend on the Taxonomy and Version that is chosen."), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("em", null, "For Taxonomy = Budget (both functional and structural), Version = Summary or Detailed, Categories"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Revenue")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Staffing")))), react["createElement"]("dd", null, " All of these are based on City documents which have similar line items across all catagories. This makes the figures from all sources comparable."), react["createElement"]("dt", { style: { marginTop: "20px" } }, react["createElement"]("em", null, "For Taxononmies based on actuals, any Version, Categories"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Revenue (actual), or")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses (actual)")))), react["createElement"]("dd", null, "The classification schemes for these are different for each, and therefore they cannot be combined."), react["createElement"]("dt", { style: { marginTop: "20px" } }, react["createElement"]("em", null, "For Taxonomy = Expenses by type, Dataset = Audited Statements, Categories"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses")))), react["createElement"]("dd", null, "These come from notes to the audited financial statements.")), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Prorated")), " choices are common for all other choices, and include:"), react["createElement"]("dl", null, react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Population: per resident")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Population: per 100,000 people")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per household")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per 40,000 households")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per Ward (x 44)"), " an average per ward"), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per Neighbourhood (x 4 x 44)"), " an average per neighbourhood, 4 per ward, about walking distance")))), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Inflation adjusted")), " is on by default, but can be turned off."), react["createElement"]("dl", null, react["createElement"]("dd", null, "This uses the Statistics Canada\'s estimated CPI for Toronto, to adjust historical figures in terms of recent currency valuations, for more meaningful trend analysis.")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Chart Options"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, " Chart options vary according to the time options selected. The time options available are:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "13", y: "13", width: "10", height: "10" })), " One year (default)"), react["createElement"]("dd", null, " Select a specific year to investigate."), react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "4", y: "13", width: "10", height: "10" }), react["createElement"]("rect", { x: "22", y: "13", width: "10", height: "10" })), " Two years"), react["createElement"]("dd", null, " Allows data for two years to be presented side by side for comparison."), react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("ellipse", { cx: "6", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "18", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "30", cy: "18", rx: "4", ry: "4" })), " All years (all available years)"), react["createElement"]("dd", null, " Shows all available years to investigate trends.")), react["createElement"]("p", null, "Specific years can be selected in the selection dropdowns under the charts."), react["createElement"]("hr", null), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "13", y: "13", width: "10", height: "10" })), " Chart options when one year is chosen include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "insert_chart"), " Column Chart"), react["createElement"]("dd", null, " This shows the basics of the components of the chart. Float the mouse over the column to see the number, or click on a column to drill down."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "donut_small"), " Donut Chart"), react["createElement"]("dd", null, " This shows the percentages of each number in relation to the whole.")))), react["createElement"]("hr", null), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "4", y: "13", width: "10", height: "10" }), react["createElement"]("rect", { x: "22", y: "13", width: "10", height: "10" })), " Chart options when two years is chosen include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "insert_chart"), " Column Chart"), react["createElement"]("dd", null, " This offers a difference chart. The light colored bars are background bars."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "donut_small"), " A piechart difference chart"), react["createElement"]("dd", null, " This shows the differences between the two years chosen.")))), react["createElement"]("hr", null), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("ellipse", { cx: "6", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "18", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "30", cy: "18", rx: "4", ry: "4" })), " Chart options when all years is chosen include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "timeline"), " Line Chart"), react["createElement"]("dd", null, " Basic time lines"), react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    } }, react["createElement"]("path", { d: "M20,6c0-0.587-0.257-1.167-0.75-1.562c-0.863-0.69-2.121-0.551-2.812,0.312l-2.789,3.486L11.2,6.4  c-0.864-0.648-2.087-0.493-2.762,0.351l-4,5C4.144,12.119,4,12.562,4,13v3h16V6z" }), react["createElement"]("path", { d: "M20,19H4c-0.552,0-1,0.447-1,1s0.448,1,1,1h16c0.552,0,1-0.447,1-1S20.552,19,20,19z" })), " Area Chart"), react["createElement"]("dd", null, " Same data as timelines, but stacked."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "view_stream"), " Proportional Chart "), react["createElement"]("dd", null, " All lines add to 100%; individual amounts are shown in proportion to the whole.")))))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Context Options"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, " Context options are offered to provide contextual information for the data being viewed, and to afford the reader the opportunity to contribute to the process surrounding the budget. These are the options offered, found under each chart:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "info_outline"), " The ", react["createElement"]("em", null, "information"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " invokes a dialog containing information related to the current data. This could be brief explanations, links to related information, or links to websites which specialize in the subject matter. The idea is to allow the reader to discover more context and detail about the subject matter at hand."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "note"), " The ", react["createElement"]("em", null, "notes"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " invokes detailed technical information about the data presented, including source documents, exceptions, errors, and any relevant notes about the way the data was processed. If there are errors or exceptions in place, the note icon changes colour to red or orange, depending on severity."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "share"), " The ", react["createElement"]("em", null, "share"), " icon "), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " provides access to relevant social media sites, to allow readers to read or contribute to discussion about the subject at hand."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "announcement"), " The ", react["createElement"]("em", null, "announcement"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " provides the user with lists of calls to actions or meetings related to the subject matter, or to contribute their own call to action or meetings."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "view_list"), " The ", react["createElement"]("em", null, "data"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " brings up the data underlying the currently viewed chart, with an option to download same."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "swap_horiz"), " The ", react["createElement"]("em", null, "harmonize"), " icon"), react["createElement"]("dd", null, " allows the user to impose the settings made in the current chart onto the other charts in the row (", react["createElement"]("em", null, "Exhibit"), ").")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Cloning Features"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, "The Budget Explorer organizes charts into horizontal drill-down sequences which we call ", react["createElement"]("em", null, "Exhibits"), ". We allow for cloning and re-ordering these exhibits to allow for comparison, exploration, and publication. This clone contains all the option controls of the original. The clone is independent of the original."), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "add_circle_outline"), " Add a clone of the current Exhibit"), react["createElement"]("dd", null, "This icon when invoked adds a clone of the current row of charts below the current row. ", react["createElement"]("em", null, "The clone reproduces all of the components and selections of the current row.")), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "remove_circle_outline"), " Remove the current Exhibit"), react["createElement"]("dd", null, "This icon when invoked removes the current row of charts (cannot currently be undone)."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "arrow_upward"), " Move the current Exhibit up one position"), react["createElement"]("dd", null, "When mulitple rows (", react["createElement"]("em", null, "Exhibits"), ") exist, they can be re-ordered. The up arrow icon (to the upper right of the row title) moves the row up one position."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "arrow_downward"), " Move the current Exhibit down one position"), react["createElement"]("dd", null, "When mulitple rows (", react["createElement"]("em", null, "Exhibits"), ") exist, they can be re-ordered. The down arrow icon (to the upper right of the row title) moves the row down one position.")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Actionable Features"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, "We\'ve provided a few actionable features to help you find and share charts with friends and associates."), react["createElement"]("dl", null, react["createElement"]("dt", null, "Find"), react["createElement"]("dd", null, "This lets you find a chart by the title of the City account, or classification, that it highlights. Enter a key word that is likely to be found in a name."), react["createElement"]("dt", null, "Share"), react["createElement"]("dd", null, "This gives you a bitly (short) url that you can share with friends. When they go to that url, it will reproduce the current row of charts for them. A good basis for discussion."), react["createElement"]("dt", null, "Sources"), react["createElement"]("dd", null, "This provides a list of the source reports used to collect the data for the current viewpoint."), react["createElement"]("dt", null, "Printing charts"), react["createElement"]("dd", null, "To print charts, turn off options on each row of charts to remove clutter, and then use a browser utility like Fireshot for Chrome to print the entire visible page.")))));\n/* harmony default export */ var helpcontent = (content);\n// CONCATENATED MODULE: ./ts/addons/explorer/explorer.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorer.tsx\n/*\n    BUG: in _getBranchCloneSettings unselect parent child creates \'data not availble in child branch\'\n    BUG: \'Working\' sign persists when click fails to drill down,\n        such as when staff aspect is selected and max depth is reached\n    BUG: navigating to dialog help box loses bar selection\n    TODO:\n    - change terms Expenditures and Receipts to Cost Elements and Revenue Elements\n    - scroll down to new branch after hitting + sign\n    - do systematic check for error handling requirements; protect against\n        unexpected data (extrenal)\n    - move state to central store\n    ? Classes:\n        Explorer\n        ExporerNode\n        BudgetData = budgetdata -- package of aspects, lookup, and viewpoint data\n        BudgetExplorer (set of BudgetNodes)\n        BudgetNode (derive from chartconfig) Node within Hierarchy\n        BedgetChart (derive from chartcomfig) - presentation of BudgetNode\n        BudgetInfo explanation of budget node\n        BudgetPath series of drilldown budgetnodes\n        BudgetMatrix complete set of budget paths for BudgetExplorer\n*/\n\n\n\nvar { Component: explorer_Component } = react;\n// doesn\'t require .d.ts...! (reference available in index.tsx)\n\n\n\n\n\n\n// import AutoComplete from \'material-ui/AutoComplete\'\n\n\n\n\n\n\n\n\nlet uuid = __webpack_require__(544); // use uuid.v4() for unique id\nlet explorer_jsonpack = __webpack_require__(1144);\nlet explorer_ReactGA = __webpack_require__(533);\nvar { Chart: explorer_Chart } = __webpack_require__(1137);\n\n\n// import * as Actions from \'../../core/actions/actions\'\n\n\n\n\n\nlet Explorer = class extends explorer_Component {\n    constructor() {\n        // ---------------------[ Initialize ]-------------------------\n        super(...arguments);\n        this.state = {\n            budgetBranches: [],\n            dialogOpen: false,\n            searchDialogOpen: false,\n            storyboardDialogOpen: false,\n            analystNotesDialogOpen: false,\n            viewTaxonomyDialogOpen: false,\n            selectStoryboard: \'SELECT\'\n        };\n        this.toastrmessages = {\n            error: null,\n            warning: null,\n            success: null,\n            info: null\n        };\n        // Value    Notes\n        // args.category    String. Required. A top level category for these events. \n        //     E.g. \'User\', \'Navigation\', \'App Editing\', etc.\n        // args.action    String. Required. A description of the behaviour. \n        //     E.g. \'Clicked Delete\', \'Added a component\', \'Deleted account\', etc.\n        // args.label    String. Optional. More precise labelling of the related action. \n        //     E.g. alongside the \'Added a component\' action, we could add the name of a component as the label. E.g. \'Survey\', \'Heading\', \'Button\', etc.\n        // args.value    Int. Optional. A means of recording a numerical value against an event. \n        //     E.g. a rating, a score, etc.\n        // args.nonInteraction    Boolean. Optional. If an event is not triggered by a user interaction, \n        //     but instead by our code \n        //     (e.g. on page load, \n        //         it should be flagged as a nonInteraction event to avoid skewing bounce rate data.\n        // args.transport    String. Optional. \n        //     This specifies the transport mechanism with which hits will be sent. \n        //     Valid values include \'beacon\', \'xhr\', or \'image\'.\n        this.logEvent = parms => {\n            if (window.location.hostname == \'budgetpedia.ca\') {\n                explorer_ReactGA.event(parms);\n            }\n        };\n        this.setToast = (version, message) => {\n            this.toastrmessages[version] = message;\n        };\n        // ----------------------------[ Lifecycle operations ]-------------------------------\n        this.urlparms = null;\n        this.clearUrlParms = () => {\n            this.urlparms = null;\n        };\n        this.stories = null;\n        this.storiescleared = [];\n        this.clearStories = branch => {\n            this.storiescleared.push(branch);\n            if (this.storiescleared.length == this.stories.length) {\n                this.stories = null;\n                this.storiescleared = [];\n                this.setState({\n                    storyboardDialogOpen: false\n                });\n            }\n        };\n        this.storyboardDialog = () => react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Your storyboard is being prepared"), modal: true, open: this.state.storyboardDialogOpen, autoScrollBodyContent: false, contentStyle: { maxWidth: \'600px\' }, autoDetectWindowHeight: false }, react["createElement"]("div", null, "please wait while the charts are rendered...", react["createElement"]("br", null), "Toggle any row\'s \\"Show chart controls\\" to experiment with settings for that row", react["createElement"](LinearProgress_default.a, { mode: "indeterminate" })));\n        this.getUrlParameter = name => {\n            name = name.replace(/[\\[]/, \'\\\\[\').replace(/[\\]]/, \'\\\\]\');\n            var regex = new RegExp(\'[\\\\?&]\' + name + \'=([^&#]*)\');\n            var results = regex.exec(location.search);\n            return results === null ? \'\' : decodeURIComponent(results[1].replace(/\\+/g, \' \'));\n        };\n        /*\n            harmonizeBranches creates branches to match branch declarations\n            called from componentWillMount for initialization of imported datasets\n            and from componentWillReceiveProps to modify branch list\n        */\n        this.harmonizeBranchesToState = (budgetBranches, branchList, branchesById) => {\n            // reset state branches if a change is made\n            let change = false;\n            // delete branches that are no longer required\n            let newBranches = budgetBranches.filter(branch => {\n                return !!branchesById[branch.uid];\n            });\n            if (newBranches.length != budgetBranches.length) {\n                change = true;\n            }\n            // add branches not yet created\n            // let length = newBranches.length\n            for (let i = 0; i < branchList.length; i++) {\n                let uid = branchList[i];\n                let foundbranch = newBranches.filter(branch => {\n                    if (branch.uid == uid) return branch;\n                });\n                if (foundbranch.length == 0) {\n                    // branch not found, so add it\n                    if (!change) change = true;\n                    let budgetBranch = new branch_class({ uid });\n                    newBranches.push(budgetBranch);\n                }\n            }\n            // sort branches into correct order, per state branchlist\n            let sortedBranches = [];\n            for (let i = 0; i < branchList.length; i++) {\n                let uid = branchList[i];\n                let foundbranch = newBranches.filter(branch => {\n                    if (branch.uid == uid) return branch;\n                });\n                if (!(foundbranch.length == 1)) {\n                    console.error(\'System error -- unexpected mismatch between state branch list and explorer branch list\', branchList, newBranches);\n                    throw Error(\'System error -- unexpected mismatch between state branch list and explorer branch list\');\n                }\n                sortedBranches.push(foundbranch[0]);\n            }\n            if (!change) {\n                for (let i = 0; i < budgetBranches.length; i++) {\n                    if (budgetBranches[i].uid != sortedBranches[i].uid) {\n                        change = true;\n                        break;\n                    }\n                }\n            }\n            if (change) {\n                this.setState({\n                    budgetBranches: sortedBranches\n                });\n            }\n        };\n        // ------------------------[ ancillary ui ]---------------------------\n        this.handleDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'Explorer\',\n                action: \'Show help\'\n            });\n            this.setState({\n                dialogOpen: true\n            });\n        };\n        this.handleDialogClose = () => {\n            this.setState({\n                dialogOpen: false\n            });\n        };\n        // ---------------[ create action calls versions for currying (branchid) ]---------------\n        // node consumer\n        this.updateNode = branchuid => nodeuid => this.props.updateNode(branchuid, nodeuid);\n        this.changeTab = branchuid => (nodeuid, tabvalue) => this.props.changeTab(branchuid, nodeuid, tabvalue);\n        this.addCellDeclarations = branchuid => (nodeuid, settingslist) => this.props.addCellDeclarations(branchuid, nodeuid, settingslist);\n        this.normalizeCellYearDependencies = branchuid => (nodeuid, cellList, yearsRange) => this.props.normalizeCellYearDependencies(branchuid, nodeuid, cellList, yearsRange);\n        // cell consumer\n        this.updateCellTimeScope = branchuid => nodeuid => (celluid, selection) => this.props.updateCellTimeScope(branchuid, nodeuid, celluid, selection);\n        this.updateCellChartSelection = branchuid => nodeuid => (celluid, selection) => this.props.updateCellChartSelection(branchuid, nodeuid, celluid, selection);\n        this.updateCellYearSelections = branchuid => nodeuid => (leftyear, rightyear) => this.props.updateCellYearSelections(branchuid, nodeuid, leftyear, rightyear);\n        this.updateCellChartCode = branchuid => nodeuid => (celluid, explorerChartCode) => this.props.updateCellChartCode(branchuid, nodeuid, celluid, explorerChartCode);\n        // ----------------------------[ ui responses ]------------------------------\n        this.onExpandChange = expanded => {\n            return;\n            // TODO: change background color of title if it is collapsed\n            // this.props.resetLastAction()\n        };\n        this.branchMoveUp = branchuid => {\n            this.props.branchMoveUp(branchuid);\n        };\n        this.branchMoveDown = branchuid => {\n            this.props.branchMoveDown(branchuid);\n        };\n        this._getBranchCloneSettings = refbranchid => {\n            let declarationData = this.props.declarationData;\n            let clones = {\n                branch: {},\n                nodes: {},\n                cells: {}\n            };\n            let uidmap = {};\n            // clone branch\n            uidmap[refbranchid] = uuid.v4();\n            clones.branch[refbranchid] = this._getClone(declarationData.branchesById[refbranchid]);\n            // console.log(\'clones\', clones)\n            // clone branch nodes\n            for (let nodeid of clones.branch[refbranchid].nodeList) {\n                let nodeobject = declarationData.nodesById[nodeid];\n                // console.log(\'nodeobject\', nodeobject)\n                clones.nodes[nodeid] = this._getClone(nodeobject);\n                uidmap[nodeid] = uuid.v4();\n            }\n            // clone node cells\n            for (let nodeid in clones.nodes) {\n                for (let cellid of clones.nodes[nodeid].cellList) {\n                    clones.cells[cellid] = this._getClone(declarationData.cellsById[cellid]);\n                    uidmap[cellid] = uuid.v4();\n                    clones.cells[cellid].celluid = uidmap[cellid]; // TODO: this reference shouldn\'t be in cell declaration!!\n                }\n            }\n            // console.log(\'cell clones\',clones.cells)\n            // map old uid\'s to new uid\'s\n            let newclones = {\n                newbranchid: uidmap[refbranchid],\n                branch: {},\n                nodes: {},\n                cells: {}\n            };\n            let newrefbranchid = uidmap[refbranchid];\n            newclones.branch[newrefbranchid] = clones.branch[refbranchid];\n            let oldlist = newclones.branch[newrefbranchid].nodeList;\n            let newlist = [];\n            for (let id of oldlist) {\n                newlist.push(uidmap[id]);\n            }\n            newclones.branch[newrefbranchid].nodeList = newlist;\n            for (let id in clones.nodes) {\n                let newid = uidmap[id];\n                let nodeclone = newclones.nodes[newid] = clones.nodes[id];\n                let oldlist = nodeclone.cellList;\n                let newlist = [];\n                for (let cellid of oldlist) {\n                    newlist.push(uidmap[cellid]);\n                }\n                nodeclone.cellList = newlist;\n            }\n            for (let oldid in clones.cells) {\n                newclones.cells[uidmap[oldid]] = clones.cells[oldid];\n            }\n            return newclones;\n        };\n        this._getClone = object => {\n            return JSON.parse(JSON.stringify(object));\n        };\n        this.addBranch = refbranchuid => {\n            let cloneSettings = this._getBranchCloneSettings(refbranchuid);\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Add branch\'\n            });\n            this.props.cloneBranchDeclaration(refbranchuid, cloneSettings);\n            this.onCloneCreation();\n        };\n        // crude scroll down on branch clone\n        this.onCloneCreation = () => {\n            setTimeout(() => {\n                let adjustment = 400;\n                let frames = 60;\n                let t = 1 / frames;\n                let counter = 0;\n                let base = 0;\n                let tick = () => {\n                    counter++;\n                    let factor = this.easeOutCubic(counter * t);\n                    let scrollinterval = adjustment * factor;\n                    window.scrollBy(0, scrollinterval - base);\n                    base = scrollinterval;\n                    if (counter < frames) {\n                        requestAnimationFrame(tick);\n                    }\n                };\n                requestAnimationFrame(tick);\n            }, 1000); // give charts some time to render and take up space\n        };\n        // TODO: should be in utilities\n        // from https://github.com/DelvarWorld/easing-utils/blob/master/src/easing.js\n        this.easeOutCubic = t => {\n            const t1 = t - 1;\n            return t1 * t1 * t1 + 1;\n        };\n        this.removeBranch = branchuid => {\n            this.props.removeBranchDeclaration(branchuid);\n        };\n        this.removeBranches = () => {\n            this.props.removeBranches();\n        };\n        this.findParameters = {\n            applySearchBranchSettings: null\n        };\n        // ==================[ FIND CHART ]=======================\n        this.handleSearchDialogOpen = (e, applySearchBranchSettings) => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.findParameters.applySearchBranchSettings = applySearchBranchSettings;\n            // this.resetSelectionParameters()\n            this.setState({\n                searchDialogOpen: true\n            });\n        };\n        this.handleSearchDialogClose = () => {\n            this.setState({\n                searchDialogOpen: false\n            });\n        };\n        // =======================[ Storyboard Creation ]=====================\n        this.storyBoards = null;\n        this.getStoryboardsPromise = () => {\n            let filespec = \'./db/repositories/toronto/storyboards/storyboards.json\';\n            let promise = new Promise((resolve, reject) => {\n                fetch(filespec).then(response => {\n                    if (response.ok) {\n                        // console.log(\'response for \' + path,response)\n                        try {\n                            let json = response.json().then(json => {\n                                resolve(json);\n                            }).catch(reason => {\n                                let msg = \'failure to resolve \' + filespec + \' \' + reason;\n                                console.log(msg);\n                                reject(msg);\n                            });\n                        } catch (e) {\n                            console.log(\'error \' + filespec, e.message);\n                            reject(\'failure to load \' + filespec);\n                        }\n                    } else {\n                        reject(\'could not load file \' + filespec);\n                    }\n                }).catch(reason => {\n                    reject(reason + \' \' + filespec);\n                });\n            });\n            return promise;\n        };\n        this.onSelectStoryboard = value => {\n            let showdialog = true;\n            if (value == \'SELECT\') {\n                showdialog = false;\n            }\n            this.logEvent({\n                category: \'Explorer\',\n                action: \'Select storyboard\',\n                label: value\n            });\n            this.setState({\n                selectStoryboard: value,\n                storyboardDialogOpen: showdialog\n            });\n            if (value == \'SELECT\') {\n                return;\n            }\n            this.processStoryboardSelection(value);\n        };\n        this.processStoryboardSelection = selection => {\n            // console.log(\'processing selection\',selection)\n            if (!this.storyBoards) {\n                let promise = this.getStoryboardsPromise();\n                promise.then(json => {\n                    this.storyBoards = json;\n                    if (!this._doProcessStoryboardSelection(selection)) {\n                        this.setState({\n                            selectStoryboard: \'SELECT\',\n                            storyboardDialogOpen: false\n                        });\n                        if (this.state.budgetBranches.length == 0) {\n                            this.resetBranches();\n                        }\n                    }\n                }).catch(reason => {\n                    console.error(\'error in processStoryboardSelection\', reason);\n                    this.setState({\n                        selectStoryboard: \'SELECT\',\n                        storyboardDialogOpen: false\n                    });\n                });\n            } else {\n                if (!this._doProcessStoryboardSelection(selection)) {\n                    this.setState({\n                        selectStoryboard: \'SELECT\',\n                        storyboardDialogOpen: false\n                    });\n                }\n            }\n        };\n        /*\n            each story consists of the following properties\n            {\n                viewpoint:"", FUNCTIONAL, STRUCTURAL, ACTUALEXPENSES, ACTUALREVENUES, EXPENDITURES\n                source:"",\n                    for FUNCTIONAL or STRUCTURAL:\n                        SUMMARY, PBFT, VARIANCE\n                    otherwise source = viewpoint\n                level:"",\n        \n                    for FUNCTIONAL or STRUCTURAL Expenses:\n                        Taxonomy, Program, Service, Activity, Expense\n        \n                    for FUNCTIONAL or STRUCTURAL Revenues:\n                        Taxonomy, Program, Service, Activity, Revenue\n        \n                    for FUNCTIONAL or STRUCTURAL Staffing:\n                        Taxonomy, Program, Permanence\n        \n                    for ACTUALEXPENSES Expenses\n                        Taxonomy, Expense\n        \n                    for ACTUALREVENUES Revenues\n                        Taxonomy, Revenue\n        \n                    for EXPENDITURES Expenditure\n                        Taxonomy, Expenditure\n                code:"",\n                aspect:"",\n                    for FUNCTIONAL or STRUCTURAL:\n                        Expenses, Revenues, Staffing\n                    for ACTUALEXPENSES,\n                        Expenses\n                    for ACTUALREVENUES:\n                        Revenues\n                    for EXPENDITURES:\n                        Expenditure\n                name:""\n            }\n        */\n        this._doProcessStoryboardSelection = selection => {\n            let storyboard = this.storyBoards.storyboards[selection];\n            if (!storyboard) {\n                lib["toastr"].error(\'storyboard not found for \' + selection);\n                return false;\n            }\n            // console.log(\'processing story board\',selection,storyboard)\n            let stories = storyboard.stories;\n            this.stories = stories;\n            if (!stories) {\n                lib["toastr"].error(\'stories not found for storyboard \' + selection);\n                return false;\n            }\n            // clear all branches\n            if (this.state.budgetBranches.length > 0) {\n                this.removeBranches();\n                this.setState({\n                    budgetBranches: []\n                });\n            }\n            let explorer = this;\n            setTimeout(() => {\n                for (let story of stories) {\n                    // create branch\n                    let defaultSettings = JSON.parse(JSON.stringify(explorer.props.declarationData.defaults.branch));\n                    let settings = Object.assign(defaultSettings, {\n                        viewpoint: story.viewpoint,\n                        version: story.source,\n                        aspect: story.aspect,\n                        story: story,\n                        showOptions: false\n                    });\n                    explorer.props.addBranchDeclaration(null, settings); // change state \n                }\n            });\n            return true;\n        };\n        this.resetBranches = () => {\n            let value = \'SELECT\';\n            this.setState({\n                selectStoryboard: value\n            });\n            this.removeBranches();\n            let defaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.branch));\n            this.props.addBranchDeclaration(null, defaultSettings); // change state        \n        };\n        this._inputonfocus = () => {\n            this._inputfieldref.setSelectionRange(0, this._inputfieldref.value.length);\n        };\n        this.shareStoryboard = () => {\n            let longurl = this._getShareUrl();\n            // console.log(\'long url\',longurl)\n            let toastrComponent = () => react["createElement"]("div", { style: { width: "300px" } }, react["createElement"]("p", { style: { width: "240px" } }, "To share this storyboard (not including any changes you may have made), copy the url below, and send it to a friend."), react["createElement"]("input", { ref: node => {\n                    this._inputfieldref = node;\n                }, onFocus: this._inputonfocus, style: { width: "310px", marginLeft: \'-60px\' }, value: longurl, readOnly: true }));\n            let toastrOptions = {\n                icon: react["createElement"](FontIcon_default.a, { className: "material-icons" }, "share"),\n                component: toastrComponent\n            };\n            lib["toastr"].message(\'Share\', toastrOptions);\n        };\n        this._getShareUrl = () => {\n            this.logEvent({\n                category: \'Explorer\',\n                action: \'Share storyboard\',\n                label: this.state.selectStoryboard\n            });\n            return \'http://\' + location.hostname + \'/explorer?storyboard=\' + this.state.selectStoryboard;\n        };\n        // =============================================================================\n        // ---------------------------[ View Taxonomy/dataset ]-----------------------\n        this.viewtaxonomydata = {\n            options: {\n                allowHtml: true,\n                allowCollapse: false\n            }\n        };\n        this.taxonomyleafnodeselection = null;\n        // TODO: should log event for google analytics\n        this.onCallViewTaxonomy = (viewpointdata, viewpointselection, applytaxonomyselection) => {\n            let self = this;\n            self.viewtaxonomydata.applytaxonomyselection = applytaxonomyselection;\n            self.taxonomyleafnodeselection = null;\n            window[\'taxonomyCall\'] = function (value) {\n                self.taxonomyleafnodeselection = value;\n                // console.log(\'set taxonomynodeselection\',value)\n            };\n            // console.log(\'viewpointdata,viewpointselection\',viewpointdata, viewpointselection)\n            this.viewtaxonomydata.viewpointdata = viewpointdata;\n            this.viewtaxonomydata.viewpointselection = viewpointselection;\n            this.setViewTaxonomyData();\n            this.setState({\n                viewTaxonomyDialogOpen: true\n            });\n        };\n        this.setViewTaxonomyData = () => {\n            let viewpointdata = this.viewtaxonomydata.viewpointdata;\n            let data = [];\n            data.push([\'Code\', \'Parent\', \'Tooltip\']);\n            let code = viewpointdata.NamingConfigRef;\n            data.push([{ v: code, f: viewpointdata.Meta.NamingConfigurations[code].Contents.Alias }, \'\', \'\']);\n            this.setViewTaxonomyRow(code, viewpointdata.Components, data);\n            this.viewtaxonomydata.data = data;\n        };\n        // recursive\n        this.setViewTaxonomyRow = (parentcode, components, data) => {\n            let baselines = { string: \'\' };\n            for (let code in components) {\n                let component = components[code];\n                if (component.Baseline) {\n                    // console.log(\'single baseline\',component)\n                    if (!baselines.code) {\n                        baselines.code = code;\n                    }\n                    baselines.string += \'<div style="border:2px solid gray;margin-bottom:3px;border-radius:6px;font-size:smaller" onClick="taxonomyCall(\\\'\' + code + \'\\\')">\' + component.Name + \'</div>\';\n                } else {\n                    data.push([{ v: code, f: component.Name }, parentcode, \'\']);\n                    this.setViewTaxonomyRow(code, component.Components, data);\n                }\n            }\n            // console.log(\'baselines\',baselines)\n            if (baselines.code) {\n                data.push([{ v: baselines.code, f: \'<div style="background-color:pink;height:100%">\' + baselines.string + \'</div>\' }, parentcode, \'\']);\n            }\n        };\n        this.setSelectionBranchNodes = selection => {\n            setTimeout(() => {\n                let selectedleafnode = null;\n                let selectedtreenode = null;\n                let selectednoderow = selection[0].row;\n                let datanode = this.viewtaxonomydata.data[selectednoderow + 1];\n                if (this.taxonomyleafnodeselection) {\n                    // an html injected div has been clicked\n                    selectedleafnode = this.taxonomyleafnodeselection;\n                    selectedtreenode = datanode[1]; // parent\n                } else {\n                    let substr = datanode[0].f.substring(0, 4);\n                    if (substr == \'<div\') {\n                        // a constructed node. get parent\n                        selectedtreenode = datanode[1]; // parent\n                    } else {\n                        // get current code\n                        selectedtreenode = datanode[0].v; // node code\n                    }\n                }\n                let parms = {\n                    selectedleafnode,\n                    selectedtreenode\n                };\n                this.viewtaxonomydata.applytaxonomyselection(parms);\n                // console.log(\'viewtaxonomydata.data\',this.viewtaxonomydata.data)\n                // console.log(\'selectedleafnode, selectedtreenode, chart selection, taxonomynodeselection\', selectedleafnode, selectedtreenode, selection, this.taxonomyleafnodeselection)\n            });\n        };\n        this.taxonomyevents = () => {\n            let self = this;\n            return [{\n                eventName: \'select\',\n                callback: (Chart, err) => {\n                    let chart = Chart.chart;\n                    let selection = chart.getSelection();\n                    self.setState({\n                        viewTaxonomyDialogOpen: false\n                    });\n                    if (selection.length) {\n                        self.setSelectionBranchNodes(selection);\n                    }\n                }\n            }];\n        };\n        this.taxonomychart = () => {\n            // console.log(\'viewtaxonomydata\',this.viewtaxonomydata)\n            return this.viewtaxonomydata.data ? react["createElement"](explorer_Chart, { chartType: \'OrgChart\', options: this.viewtaxonomydata.options, chartEvents: this.taxonomyevents(), data: this.viewtaxonomydata.data }) : null;\n        };\n        this.viewTaxonomyDialog = () => {\n            if (!this.viewtaxonomydata.viewpointdata) return null;\n            let taxonomyselection = this.viewtaxonomydata.viewpointselection.viewpoint;\n            return react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Chart view of selected dataset tree (", react["createElement"]("span", { style: { fontStyle: \'italic\' } }, this.viewtaxonomydata.viewpointselection.name), ")"), modal: false, onRequestClose: () => {\n                    this.setState({\n                        viewTaxonomyDialogOpen: false\n                    });\n                }, open: this.state.viewTaxonomyDialogOpen, contentStyle: { width: \'90%\', maxWidth: \'none\', height: \'90%\', maxHeight: \'none\' }, autoScrollBodyContent: true }, react["createElement"](IconButton_default.a, { style: {\n                    top: 0,\n                    right: 0,\n                    padding: 0,\n                    height: "36px",\n                    width: "36px",\n                    position: "absolute",\n                    zIndex: 2\n                }, onClick: () => {\n                    this.setState({\n                        viewTaxonomyDialogOpen: false\n                    });\n                } }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", { style: { height: window.innerHeight } }, react["createElement"]("div", { style: { fontStyle: \'italic\', fontSize: \'smaller\' } }, "click on a cell to view chart. ", react["createElement"]("div", { style: {\n                    display: \'inline-block\',\n                    height: \'9px\',\n                    width: \'9px\',\n                    backgroundColor: \'pink\',\n                    border: \'1px solid gray\'\n                } }), " = ", taxonomyselection == \'FUNCTIONAL\' || taxonomyselection == \'STRUCTURAL\' ? \'City Divisions and Agencies\' : \'Source document base categories\'), this.taxonomychart()));\n        };\n        // ===================================================================\n        // ---------------------------[ Analyst Notes ]-----------------------\n        this.analystNotesDialog = () => react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Budget Analyst Notes"), modal: false, onRequestClose: () => {\n                this.onSelectAnalystNotes(null, null);\n            }, open: this.state.analystNotesDialogOpen, autoScrollBodyContent: true }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: () => {\n                this.setState({\n                    analystNotesDialogOpen: false\n                });\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", null, this.getAnalystNotesDisplay()));\n        this.getAnalystNotesDisplay = () => {\n            let display = [];\n            display.push(this.getDisplayRoot());\n            return display;\n        };\n        this.getDisplayRoot = () => {\n            let display = this.analystnotes.displaylist;\n            let displayroot = display[0] || {};\n            return react["createElement"]("div", { key: "main" }, react["createElement"]("h3", null, displayroot.name), this.getDisplayTail(displayroot));\n        };\n        this.getDisplayTail = displayobj => {\n            if (displayobj.subset) {\n                return this.getDisplaySubset(displayobj.subset);\n            } else if (displayobj.notes) {\n                return this.getDisplayNotes(displayobj.notes);\n            } else {\n                return react["createElement"]("div", null, "no notes to display");\n            }\n        };\n        this.getDisplaySubset = subset => {\n            let elements = [];\n            for (let index in subset) {\n                let displayobj = subset[index];\n                elements.push(react["createElement"]("div", { key: index, style: {\n                        borderLeft: \'1px solid silver\',\n                        marginLeft: \'3px\',\n                        paddingLeft: \'3px\'\n                    } }, react["createElement"]("h4", { style: displayobj.notes ? { fontStyle: \'italic\' } : null }, displayobj.name), this.getDisplayTail(displayobj)));\n            }\n            return elements;\n        };\n        this.getDisplayNotes = notes => {\n            let elements = [];\n            for (let index in notes) {\n                let note = notes[index];\n                elements.push(react["createElement"]("div", { key: index }, "- ", react["createElement"]("a", { target: "_blank", href: note.link }, note.title)));\n            }\n            if (elements.length == 0) {\n                elements.push(react["createElement"]("div", { key: "none", style: { fontStyle: \'italic\' } }, "(no notes)"));\n            }\n            return elements;\n        };\n        // TODO: This needs to be hooked into event that opens analyst notes window!!\n        this.onSelectAnalystNotes = (code, index) => {\n            if (code !== null) {\n                this.logEvent({\n                    category: \'Explorer\',\n                    action: \'Select analyst notes\',\n                    label: code\n                });\n            }\n            this.setState({\n                analystNotesDialogOpen: false\n            });\n            // open window for analyst notes\n        };\n        this.analystnotes = {\n            nodepath: null,\n            taxonomies: {},\n            analystnoteslist: null,\n            displaylist: {}\n        };\n        // TODO: should log this for google analytics\n        this.onCallAnalystNotes = (taxonomycode, nodepath) => {\n            this.analystnotes.nodepath = nodepath;\n            // console.log(\'taxonomy code for call analyst notes\',taxonomycode, nodepath)\n            if (this.analystnotes.taxonomies[taxonomycode]) {\n                let json = this.analystnotes.taxonomies[taxonomycode];\n                this.processTaxonomyTree(json);\n            } else {\n                let taxonomyPromise = this.filePromise(\'viewpoints/\' + taxonomycode.toLowerCase() + \'.json\');\n                let explorer = this;\n                taxonomyPromise.then(json => {\n                    this.processTaxonomyTree(json);\n                }).catch(reason => {\n                    lib["toastr"].error(\'could not find analyst notes framework:\' + reason);\n                });\n            }\n        };\n        this.processTaxonomyTree = taxonomyTree => {\n            // console.log(\'taxonomy tree\', taxonomyTree)\n            if (this.analystnotes.analystnoteslist) {\n                this.displayAnalystChoices(taxonomyTree);\n            } else {\n                let listPromise = this.filePromise(\'resources/analystnotes.json\');\n                let explorer = this;\n                listPromise.then(json => {\n                    this.analystnotes.analystnoteslist = json;\n                    // console.log(\'analyst notes loaded\', json)\n                    this.displayAnalystChoices(taxonomyTree);\n                }).catch(reason => {\n                    lib["toastr"].error(\'could not find analyst notes list:\' + reason);\n                });\n            }\n        };\n        this.displayAnalystChoices = taxonomytree => {\n            let nodepath = this.analystnotes.nodepath;\n            let headnode = null;\n            let count = 0;\n            let tailbranch = taxonomytree;\n            while (true) {\n                if (count == nodepath.length) break;\n                if (!tailbranch.Components) break;\n                headnode = nodepath[count];\n                // console.log(\'headnode, tailbranch\', headnode, tailbranch)\n                if (tailbranch.Components[headnode]) {\n                    tailbranch = tailbranch.Components[headnode];\n                } else {\n                    tailbranch = null;\n                    break;\n                }\n                count++;\n                // console.log(\'count\',count)\n            }\n            if (!tailbranch) {\n                lib["toastr"].error(\'unable to find path in taxononmy\');\n                return;\n            }\n            // console.log(\'headnode, tailbranch\',headnode,tailbranch)\n            let displaylist = this.getDisplayList(headnode, tailbranch, taxonomytree);\n            // console.log(\'displaylist\',displaylist)\n            this.analystnotes.displaylist = displaylist;\n            this.setState({\n                analystNotesDialogOpen: true\n            });\n        };\n        this.getDisplayList = (headnode, tailbranch, taxonomytree) => {\n            let analystnotes = this.analystnotes.analystnoteslist;\n            let displaylist = [];\n            let displayset = this.getDisplaySet(headnode, tailbranch, taxonomytree, analystnotes);\n            displaylist.push(displayset);\n            return displaylist;\n        };\n        this.getDisplaySet = (headnode, tailbranch, taxonomytree, analystnotes) => {\n            let displayset = {};\n            try {\n                if (tailbranch.Baseline) {\n                    let noteset = analystnotes[headnode];\n                    displayset.code = headnode;\n                    if (!noteset) {\n                        displayset.name = headnode;\n                        displayset.notes = [];\n                    } else {\n                        displayset.name = noteset.name;\n                        displayset.notes = noteset.links;\n                    }\n                } else {\n                    let subset = [];\n                    for (let subcode in tailbranch.Components) {\n                        let displayset = this.getDisplaySet(subcode, tailbranch.Components[subcode], taxonomytree, analystnotes);\n                        subset.push(displayset);\n                    }\n                    displayset.code = headnode;\n                    if (!headnode) {\n                        let contents = taxonomytree.Meta.NamingConfigurations[taxonomytree.NamingConfigRef].Contents;\n                        displayset.name = contents.Alias || contents.Name;\n                    } else {\n                        displayset.name = taxonomytree.Meta.Lookups.Taxonomy[headnode];\n                    }\n                    displayset.subset = subset;\n                }\n            } catch (e) {\n                console.error(\'error!\', e);\n            }\n            return displayset;\n        };\n        this.filePromise = path => {\n            let root = \'./db/repositories/toronto/\';\n            let filespec = root + path;\n            let promise = new Promise((resolve, reject) => {\n                fetch(filespec).then(response => {\n                    if (response.ok) {\n                        // console.log(\'response for \' + path,response)\n                        try {\n                            let json = response.json().then(json => {\n                                resolve(json);\n                            }).catch(reason => {\n                                let msg = \'failure to resolve \' + path + \' \' + reason;\n                                console.log(msg);\n                                reject(msg);\n                            });\n                        } catch (e) {\n                            console.log(\'error \' + path, e.message);\n                            reject(\'failure to load \' + path);\n                        }\n                    } else {\n                        reject(\'could not load file \' + path);\n                    }\n                }).catch(reason => {\n                    reject(reason + \' \' + path);\n                });\n            });\n            return promise;\n        };\n    }\n    componentWillMount() {\n        // console.log(\'explorer props location.query\',this.props.location.query)\n        // console.log(\'window.location,state, props\',window.location, this.state, this.props)\n        // if (!this.props.declarationData.onetimenotification) {\n        //     this.toastrmessages.info = "Click or tap on any chart column to drill down (except as noted)."\n        //     this.props.onetimeNotification()\n        // }\n        let query = {\n            search: this.props.location.search,\n            branch: this.getUrlParameter(\'branch\'),\n            settings: this.getUrlParameter(\'settings\'),\n            hash: this.getUrlParameter(\'hash\'),\n            storyboard: this.getUrlParameter(\'storyboard\')\n        };\n        // console.log(\'query\',query)\n        let branchdata, settingsdata, hash;\n        if (query.branch && query.settings && query.hash) {\n            branchdata = explorer_jsonpack.unpack(query.branch);\n            settingsdata = explorer_jsonpack.unpack(query.settings);\n            let newhash = hashCode(query.branch + query.settings).toString();\n            if (newhash == query.hash) {\n                this.urlparms = {\n                    branchdata,\n                    settingsdata\n                };\n                let defaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.branch));\n                // console.log(\'branchdata, settingsdata,defaultSettings\',branchdata,settingsdata,defaultSettings)\n                let querysettings = {\n                    inflationAdjusted: branchdata.ad,\n                    aspect: branchdata.as,\n                    prorata: branchdata.pr,\n                    repository: branchdata.g,\n                    version: branchdata.ve,\n                    viewpoint: branchdata.vi,\n                    showOptions: true\n                };\n                let settings = Object.assign(defaultSettings, querysettings);\n                this.props.addBranchDeclaration(null, settings); // change state\n                return;\n            } else {\n                this.toastrmessages.error = \'the url parameters have apparently been damaged. Using defaults instead...\';\n                console.error(\'url hash no match\', lib["toastr"], query.hash, newhash);\n            }\n        }\n        if (query && query.storyboard) {\n            let value = query.storyboard;\n            this.setState({\n                selectStoryboard: value,\n                storyboardDialogOpen: true\n            });\n            this.processStoryboardSelection(value);\n            return;\n        }\n        let { branchList, branchesById } = this.props.declarationData;\n        if (branchList.length == 0) {\n            // initialize explorer with first branch\n            // this.freshstart = true\n            let defaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.branch));\n            this.props.addBranchDeclaration(null, defaultSettings); // change state\n        } else {\n            // harmonize branch instances to branch declarations\n            let { branchList, branchesById } = this.props.declarationData;\n            let budgetBranches = [...this.state.budgetBranches];\n            this.harmonizeBranchesToState(budgetBranches, branchList, branchesById);\n        }\n    }\n    // componentDidMount() {\n    //     let query = this.props.location\n    //     if (query && query.query && query.query.storyboard) {\n    //         setTimeout(()=>{\n    //             this.onSelectStoryboard(query.query.storyboard)\n    //         },5000)\n    //     }\n    // }\n    // start with open reminder to user that click on charts drills down\n    componentWillUnmount() {\n        this.props.resetLastAction(); // clear sentinals for unmount //TODO verify this!\n    }\n    componentDidUpdate() {\n        let { branchList, branchesById } = this.props.declarationData;\n        let budgetBranches = [...this.state.budgetBranches];\n        this.harmonizeBranchesToState(budgetBranches, branchList, branchesById);\n        let { toastrmessages } = this;\n        for (let version in toastrmessages) {\n            let msg = toastrmessages[version];\n            if (msg) {\n                toastrmessages[version] = null;\n                lib["toastr"][version](msg);\n            }\n        }\n    }\n    // ===================================================================\n    // ---------------------------[ Render ]------------------------------ \n    render() {\n        let showhelp = react["createElement"](RaisedButton_default.a, { label: "Help", style: { margin: \'3px 6px 0 6px\' }, type: "button", onClick: this.handleDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "help_outline") });\n        let showanalystnotes = react["createElement"](RaisedButton_default.a, { label: "Latest Analyst Notes", style: { margin: \'3px 6px 0 6px\' }, type: "button", onClick: () => {\n                this.onCallAnalystNotes(\'FUNCTIONAL\', []);\n            } });\n        let showvideos = react["createElement"](RaisedButton_default.a, { label: "Videos", style: { margin: \'3px 6px 0 6px\' }, type: "button", onClick: () => {\n                this.logEvent({\n                    category: \'Explorer\',\n                    action: \'Show videos\'\n                });\n                window.open(\'https://www.youtube.com/channel/UCatXKvLCA5qGkzj3jw8AQig\', \'_blank\');\n            }, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "videocam") });\n        let explorer = this;\n        let dialogbox = react["createElement"](Dialog_default.a, { title: "Budget Explorer Options", modal: false, open: explorer.state.dialogOpen, onRequestClose: explorer.handleDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: explorer.handleDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), helpcontent);\n        // -----------[ BRANCH SEGMENT]-------------\n        let branchSegments = () => {\n            let budgetBranches = explorer.state.budgetBranches;\n            // console.log(\'budgetBranches\',budgetBranches)\n            // map over budgetBranches state\n            let segments = budgetBranches.map((budgetBranch, branchIndex) => {\n                let urlparms = null;\n                if (branchIndex == 0 && this.urlparms) {\n                    urlparms = this.urlparms;\n                }\n                // collect functions to pass down to nested components\n                let actionFunctions = {\n                    // curried\n                    addCellDeclarations: this.addCellDeclarations(budgetBranch.uid),\n                    normalizeCellYearDependencies: this.normalizeCellYearDependencies(budgetBranch.uid),\n                    updateCellTimeScope: this.updateCellTimeScope(budgetBranch.uid),\n                    updateCellChartSelection: this.updateCellChartSelection(budgetBranch.uid),\n                    updateCellYearSelections: this.updateCellYearSelections(budgetBranch.uid),\n                    changeTab: this.changeTab(budgetBranch.uid),\n                    updateCellChartCode: this.updateCellChartCode(budgetBranch.uid),\n                    updateNode: this.updateNode(budgetBranch.uid),\n                    // pass-through\n                    addNodeDeclaration: this.props.addNodeDeclaration,\n                    addNodeDeclarations: this.props.addNodeDeclarations,\n                    removeNodeDeclarations: this.props.removeNodeDeclarations,\n                    changeViewpoint: this.props.changeViewpoint,\n                    updateBranch: this.props.updateBranch,\n                    changeVersion: this.props.changeVersion,\n                    toggleInflationAdjusted: this.props.toggleInflationAdjusted,\n                    updateProrata: this.props.updateProrata,\n                    changeAspect: this.props.changeAspect,\n                    incrementBranchDataVersion: this.props.incrementBranchDataVersion,\n                    clearBranchStory: this.props.clearBranchStory,\n                    toggleShowOptions: this.props.toggleShowOptions,\n                    updateCellsDataseriesName: this.props.updateCellsDataseriesName,\n                    resetLastAction: this.props.resetLastAction,\n                    harmonizeCells: this.props.harmonizeCells\n                };\n                // ----------------[ Contains ExplorerBranch ]-------------------------\n                // console.log(\'explorer branchindex and stories\',branchIndex,this.stories)\n                return react["createElement"](Card["Card"], { initiallyExpanded: true, key: budgetBranch.uid, onExpandChange: expanded => {\n                        this.onExpandChange(expanded);\n                    } }, budgetBranches.length > 1 ? react["createElement"](Card["CardTitle"], { actAsExpander: false, showExpandableButton: false }, "Row " + (branchIndex + 1) + " ", react["createElement"]("input", { defaultValue: this.stories ? this.stories[branchIndex].title : \'\', type: "text", style: { width: \'350px\', fontWeight: \'bold\', fontSize: \'14px\' }, onClick: ev => {\n                        ev.stopPropagation();\n                    } }), react["createElement"](IconButton_default.a, { style: {\n                        float: "right",\n                        marginRight: "30px"\n                    }, disabled: branchIndex == budgetBranches.length - 1, onClick: (uid => ev => {\n                        ev.stopPropagation();\n                        this.branchMoveDown(uid);\n                    })(budgetBranch.uid), tooltip: "Move down" }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "arrow_downward")), react["createElement"](IconButton_default.a, { style: {\n                        float: "right"\n                    }, disabled: branchIndex == 0, onClick: (uid => ev => {\n                        ev.stopPropagation();\n                        this.branchMoveUp(uid);\n                    })(budgetBranch.uid), tooltip: "Move up" }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "arrow_upward"))) : null, react["createElement"](Card["CardText"], { expandable: false }, react["createElement"](components_explorerbranch, { budgetBranch: budgetBranch, declarationData: explorer.props.declarationData, globalStateActions: actionFunctions, urlparms: urlparms, clearUrlParms: this.clearUrlParms, clearStories: this.clearStories, setToast: this.setToast, handleSearchDialogOpen: this.handleSearchDialogOpen, onCallAnalystNotes: this.onCallAnalystNotes, onCallViewTaxonomy: this.onCallViewTaxonomy })), react["createElement"](Card["CardActions"], { expandable: false }, react["createElement"](FloatingActionButton_default.a, { onClick: (uid => () => {\n                        this.addBranch(uid);\n                    })(budgetBranch.uid) }, react["createElement"](add_default.a, null)), budgetBranches.length > 1 ? react["createElement"](FloatingActionButton_default.a, { onClick: (uid => () => {\n                        this.removeBranch(uid);\n                    })(budgetBranch.uid), secondary: true }, react["createElement"](remove_default.a, null)) : null));\n            });\n            return segments;\n        };\n        // -----------[ COMBINE SEGMENTS ]---------------\n        let branches = branchSegments();\n        return react["createElement"]("div", null, react["createElement"]("div", { style: {\n                backgroundColor: "lemonchiffon",\n                padding: "3px",\n                margin: "3px",\n                borderRadius: "8px",\n                fontFamily: "Roboto,sans-serif",\n                fontSize: "12px"\n            } }, "PLEASE READ NOTICES BELOW. Caution: This is an early version of the Budgetpedia Explorer. The data presented in these charts should be treated as approximations. There are numerous data source quality and continuity issues, the intake process has not been validated, and the data presented has not been rigorously verified against source data."), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Budget Explorer"), react["createElement"](Card["CardText"], { expandable: true }, react["createElement"]("div", { style: { display: \'inline-block\', verticalAlign: \'top\' } }, react["createElement"]("div", null, react["createElement"]("span", { style: { lineHeight: \'48px\', verticalAlign: \'23px\' } }, "Explore charts below, or select an area of interest: "), react["createElement"](DropDownMenu_default.a, { style: { verticalAlign: \'top\' }, value: this.state.selectStoryboard, onChange: (event, index, value) => {\n                this.onSelectStoryboard(value);\n            } }, react["createElement"](MenuItem_default.a, { value: \'SELECT\', primaryText: "Select" }), react["createElement"](MenuItem_default.a, { value: \'SHARED\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "General Services") }), react["createElement"](MenuItem_default.a, { value: "WASTE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Solid Waste Management") }), react["createElement"](MenuItem_default.a, { value: "WATER", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Toronto Water") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "TTC", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "TTC") }), react["createElement"](MenuItem_default.a, { value: "WHEELTRANS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Wheel Trans") }), react["createElement"](MenuItem_default.a, { value: "TRANSPORTATION", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Transportation (Roads)") }), react["createElement"](MenuItem_default.a, { value: "PARKING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Parking") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "PFRACTIVITIES", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Parks, Forestry & Activity Centres") }), react["createElement"](MenuItem_default.a, { value: "LIBRARY", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Toronto Public Library") }), react["createElement"](MenuItem_default.a, { value: "ATTRACTIONS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Public Attractions") }), react["createElement"](MenuItem_default.a, { value: "CONSERVHERITAGE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Conservation & Heritage") }), react["createElement"](MenuItem_default.a, { value: \'SUPPORT\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "Citizen Support Services") }), react["createElement"](MenuItem_default.a, { value: "FIRE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Fire") }), react["createElement"](MenuItem_default.a, { value: "PARAMEDICS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Paramedics") }), react["createElement"](MenuItem_default.a, { value: "POLICE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Policing & Court Services") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "EMPLOYMENT", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Income Support Services") }), react["createElement"](MenuItem_default.a, { value: "HOUSING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Housing Support Services") }), react["createElement"](MenuItem_default.a, { value: "CHILDREN", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Children\'s Services") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "HEALTH", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Public Health") }), react["createElement"](MenuItem_default.a, { value: "LONGTERMCARE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Long Term Care") }), react["createElement"](MenuItem_default.a, { value: \'ADMINISTRATIVE\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "Administrative Services") }), react["createElement"](MenuItem_default.a, { value: "COUNCIL", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Corporate Management") }), react["createElement"](MenuItem_default.a, { value: "PLANNING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Planning & Development") }), react["createElement"](MenuItem_default.a, { value: "PERMITS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Permits, Licencing & Standards") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "INTERNAL", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Internal Services") }), react["createElement"](MenuItem_default.a, { value: "CORPORATE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Corporate Accounts (Finance)") }), react["createElement"](MenuItem_default.a, { disabled: true, value: \'SPECIAL\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "Special Analytics") }), react["createElement"](MenuItem_default.a, { value: "STAFFING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Staffing costs") })), react["createElement"](RaisedButton_default.a, { disabled: this.state.selectStoryboard == \'SELECT\', type: "button", style: { margin: \'3px 6px 0 0\', verticalAlign: \'23px\' }, label: "Share", onClick: this.shareStoryboard, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5)\' }, className: "material-icons" }, "share") }), react["createElement"](RaisedButton_default.a, { style: { verticalAlign: \'25px\' }, type: "button", label: "Reset", onClick: () => {\n                this.resetBranches();\n            } })), react["createElement"]("div", null, "For some background see ", showhelp, " or ", showvideos, " or ", showanalystnotes)), react["createElement"]("div", null))), dialogbox, this.storyboardDialog(), this.analystNotesDialog(), this.viewTaxonomyDialog(), this.state.searchDialogOpen ? react["createElement"](searchdialog, { onRequestClose: this.handleSearchDialogClose, onConfirm: this.findParameters.applySearchBranchSettings }) : null, branches);\n    }\n};\n// ====================================================================================\n// ------------------------------[ INJECT DATA STORE ]---------------------------------\nlet mapStateToProps = state => {\n    return {\n        declarationData: Object(reducers["b" /* getExplorerDeclarationData */])(state)\n    };\n};\n// initialize all these call backs with dispatch\nExplorer = Object(es["connect"])(mapStateToProps, {\n    // presentation\n    onetimeNotification: explorer_actions["s" /* onetimeNotification */],\n    // toggleShowControls\n    // branch actions - components\n    addBranchDeclaration: explorer_actions["a" /* addBranchDeclaration */],\n    cloneBranchDeclaration: explorer_actions["n" /* cloneBranchDeclaration */],\n    removeBranchDeclaration: explorer_actions["t" /* removeBranchDeclaration */],\n    removeBranches: explorer_actions["u" /* removeBranches */],\n    addNodeDeclaration: explorer_actions["c" /* addNodeDeclaration */],\n    addNodeDeclarations: explorer_actions["d" /* addNodeDeclarations */],\n    removeNodeDeclarations: explorer_actions["v" /* removeNodeDeclarations */],\n    addCellDeclarations: explorer_actions["b" /* addCellDeclarations */],\n    normalizeCellYearDependencies: explorer_actions["r" /* normalizeCellYearDependencies */],\n    harmonizeCells: explorer_actions["o" /* harmonizeCells */],\n    // removeCellDeclarations:ExplorerActions.removeCellDeclarations,\n    // branch actions - variations\n    changeViewpoint: explorer_actions["l" /* changeViewpoint */],\n    updateBranch: explorer_actions["A" /* updateBranch */],\n    changeVersion: explorer_actions["k" /* changeVersion */],\n    changeAspect: explorer_actions["i" /* changeAspect */],\n    toggleInflationAdjusted: explorer_actions["x" /* toggleInflationAdjusted */],\n    updateProrata: explorer_actions["G" /* updateProrata */],\n    incrementBranchDataVersion: explorer_actions["p" /* incrementBranchDataVersion */],\n    clearBranchStory: explorer_actions["m" /* clearBranchStory */],\n    toggleShowOptions: explorer_actions["y" /* toggleShowOptions */],\n    resetLastAction: explorer_actions["w" /* resetLastAction */],\n    // toggleInflationAdjustment\n    branchMoveUp: explorer_actions["f" /* branchMoveUp */],\n    branchMoveDown: explorer_actions["e" /* branchMoveDown */],\n    // node actions\n    changeTab: explorer_actions["j" /* changeTab */],\n    // cell actions\n    updateCellTimeScope: explorer_actions["D" /* updateCellTimeScope */],\n    updateCellChartSelection: explorer_actions["C" /* updateCellChartSelection */],\n    updateCellYearSelections: explorer_actions["E" /* updateCellYearSelections */],\n    // updateCellsDataseriesName: ExplorerActions.updateCellsDataseriesName,\n    updateCellChartCode: explorer_actions["B" /* updateCellChartCode */],\n    updateNode: explorer_actions["F" /* updateNode */]\n})(Explorer);\n/* harmony default export */ var explorer_explorer = __webpack_exports__["default"] = (Explorer);\n\n//# sourceURL=webpack:///./ts/addons/explorer/explorer.tsx_+_14_modules?')}}]);
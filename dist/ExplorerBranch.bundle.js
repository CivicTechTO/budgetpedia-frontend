(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{1155:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/DropDownMenu/index.js\nvar DropDownMenu = __webpack_require__(1014);\nvar DropDownMenu_default = /*#__PURE__*/__webpack_require__.n(DropDownMenu);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/MenuItem/index.js\nvar MenuItem = __webpack_require__(194);\nvar MenuItem_default = /*#__PURE__*/__webpack_require__.n(MenuItem);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Subheader/index.js\nvar Subheader = __webpack_require__(493);\nvar Subheader_default = /*#__PURE__*/__webpack_require__.n(Subheader);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/FontIcon/index.js\nvar FontIcon = __webpack_require__(107);\nvar FontIcon_default = /*#__PURE__*/__webpack_require__.n(FontIcon);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/IconButton/index.js\nvar IconButton = __webpack_require__(87);\nvar IconButton_default = /*#__PURE__*/__webpack_require__.n(IconButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Dialog/index.js\nvar Dialog = __webpack_require__(1012);\nvar Dialog_default = /*#__PURE__*/__webpack_require__.n(Dialog);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Snackbar/index.js\nvar Snackbar = __webpack_require__(1138);\nvar Snackbar_default = /*#__PURE__*/__webpack_require__.n(Snackbar);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Toggle/index.js\nvar Toggle = __webpack_require__(1131);\nvar Toggle_default = /*#__PURE__*/__webpack_require__.n(Toggle);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/RaisedButton/index.js\nvar RaisedButton = __webpack_require__(1015);\nvar RaisedButton_default = /*#__PURE__*/__webpack_require__.n(RaisedButton);\n\n// EXTERNAL MODULE: ./node_modules/react-redux-toastr/lib/index.js\nvar lib = __webpack_require__(110);\n\n// EXTERNAL MODULE: ./node_modules/react-animations/lib/index.js\nvar react_animations_lib = __webpack_require__(1021);\n\n// EXTERNAL MODULE: ./node_modules/radium/es/index.js + 22 modules\nvar es = __webpack_require__(196);\n\n// EXTERNAL MODULE: ./node_modules/radium/es/keyframes.js\nvar keyframes = __webpack_require__(366);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/modules/utilities.tsx\nvar utilities = __webpack_require__(1011);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/modules/onchartcomponentselection.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// onchartcomponentselection.tsx\n// ------------------------[ UPDATE CHART BY SELECTION ]-----------------\n// response to user selection of a chart component (such as a column )\n// called by chart callback\n// on selection, makes a child with the same datasetSpecs offset\nlet applyChartComponentSelection = (budgetBranch, nodeIndex, cellIndex, chartSelectionData) => {\n    // console.log(\'chartSelection data\',chartSelectionData)\n    let { nodes: branchNodes, uid: branchuid } = budgetBranch;\n    let budgetNode = branchNodes[nodeIndex];\n    // budgetnode is undefined on final expendigure chart\n    let budgetCell = budgetNode.cells[cellIndex];\n    if (!budgetCell) {\n        console.error(\'System Error: budgetNode, faulty cellIndex in applyChartComponentSelection\', budgetNode, cellIndex);\n        throw Error(\'faulty cellIndex in applyChartComponentSelection\');\n    }\n    // unpack chartSelectionData\n    let selection = chartSelectionData.selection[0];\n    // console.log(\'budgetCell googlecharttype\',budgetCell.googleChartType, cellIndex)\n    let logicalselectionrow = null;\n    if (selection) {\n        // TODO: understand this: setting column to null avoids bugs\n        // when chart animation is present\n        // selection.column = null\n        switch (budgetCell.googleChartType) {\n            case "ColumnChart":\n                {\n                    if (budgetCell.explorerChartCode == "DiffColumnChart") {\n                        logicalselectionrow = Math.floor(selection.row / 2);\n                    } else {\n                        logicalselectionrow = selection.row;\n                    }\n                    break;\n                }\n            case "AreaChart":\n            case "LineChart":\n                logicalselectionrow = selection.column - 1;\n                if (budgetCell.chartSelection == logicalselectionrow) {\n                    logicalselectionrow = null;\n                }\n                // TODO: save row and column separately and allow\n                // mapping among chart types\n                // chartSelectionData.selection[0].row = null\n                break;\n            // TODO: find out why the piechart column null causes fail\n            // case "PieChart": \n            //     chartSelectionData.selection[0].column = null\n            default:\n                logicalselectionrow = selection.row;\n                break;\n        }\n        // } else {\n        //     logicalselectionrow = null\n        //     // return\n    }\n    // 1. stop if chart is not not drillable\n    if (budgetCell.nodeDataseriesName == \'CommonDimension\') {\n        return;\n    }\n    budgetCell.chartSelection = logicalselectionrow; // selection? chartSelectionData.selection: null\n    // console.log(\'setting chartSelection\', budgetCell.chartSelection, logicalselectionrow, selection)\n    // 2. remove any nodes to be replaced or abandoned\n    let removed = branchNodes.splice(nodeIndex + 1); // remove subsequent charts\n    let removeditems = removed.map((item, index) => {\n        return { nodeuid: item.uid, cellList: item.cellDeclarationList, index };\n    });\n    let priorCellSettings = null;\n    let priorNodeSettings = null;\n    if (removeditems.length > 0) {\n        // console.log(\'removed,removeditems\',removed,removeditems)\n        // TODO: review this for directness and efficiency\n        let removednode = removed[removeditems[0].index];\n        let priorCell = removednode.cells[removednode.nodeDeclaration.cellIndex];\n        if (priorCell) {\n            let chartConfigs = Object.assign({}, priorCell.cellDeclaration.chartConfigs);\n            let yearScope = priorCell.cellDeclaration.yearScope;\n            priorCellSettings = {\n                chartConfigs,\n                yearScope\n            };\n            priorNodeSettings = {\n                yearSelections: Object.assign({}, removednode.nodeDeclaration.yearSelections),\n                cellIndex: removednode.nodeDeclaration.cellIndex\n            };\n        } else {\n            console.log(\'error: did not find priorCell for node\', removednode);\n        }\n        let { removeNodeDeclarations } = budgetBranch.actions;\n        removeNodeDeclarations(removeditems);\n    }\n    let { updateCellChartSelection } = budgetNode.actions;\n    // console.log(\'logicalselectionrow\', logicalselectionrow)\n    updateCellChartSelection(budgetCell.uid, logicalselectionrow); // chartSelectionData.selection)\n    if (logicalselectionrow === null) {\n        // deselected\n        budgetCell.chartSelection = null;\n        return;\n    }\n    // 3. otherwise create new child node\n    budgetCell.chartSelection = logicalselectionrow; // chartSelectionData.selection\n    let childprops = {\n        selectionrow: logicalselectionrow,\n        nodeIndex,\n        cellIndex: parseInt(cellIndex),\n        priorCellSettings,\n        priorNodeSettings\n    };\n    budgetBranch.createChildNodeDeclaration(childprops);\n};\nconst onChartComponentSelection = budgetBranch => nodeIndex => cellIndex => chartSelectionData => {\n    // console.log(\'chart selection data\',chartSelectionData)\n    applyChartComponentSelection(budgetBranch, nodeIndex, cellIndex, chartSelectionData);\n};\n// EXTERNAL MODULE: ./ts/addons/explorer/modules/getbudgetnode.tsx\nvar getbudgetnode = __webpack_require__(1023);\n\n// EXTERNAL MODULE: ./node_modules/react-loadable/lib/index.js\nvar react_loadable_lib = __webpack_require__(197);\nvar react_loadable_lib_default = /*#__PURE__*/__webpack_require__.n(react_loadable_lib);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/actions.tsx\nvar explorer_actions = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/classes/branch.class.tsx + 4 modules\nvar branch_class = __webpack_require__(1017);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/components/explorerbranch.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorerbranch.tsx\n/*\n    TODO:\n    - implement scrolldown to new clone\n    - implement inheritance of settings to new clone\n    - add input fields to title, explorer header, and branch rightmost box\n      to allow textual explanations of pages\n    - add control to explorer header to toggle show/hide controls of charts\n    - have per unit and performance views\n    - include document source version (eg. summary vs fpars)\n    - prevent resetting branch when viewpoint selected is same as previous\n*/\n\n// -------------------[ libraries ]---------------------\n\n\nvar { Component } = react;\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet { StyleRoot } = es;\nconst animations = {\n    fadeIn: {\n        animation: \'x .5s\',\n        animationName: keyframes["a" /* default */](react_animations_lib["fadeIn"], \'fadeIn\')\n    },\n    fadeOut: {\n        animation: \'x .5s\',\n        animationName: keyframes["a" /* default */](react_animations_lib["fadeOut"], \'fadeOut\')\n    }\n};\nlet jsonpack = __webpack_require__(1024);\nlet validurl = __webpack_require__(491);\nlet ReactGA = __webpack_require__(486);\n// ------------------------[ modules ]-----------------------------\n\n\n// import { ExplorerNode } from \'./explorernode\'\n\nconst Loading = () => react["createElement"]("div", null, "Loading...");\nconst ExplorerNode = react_loadable_lib_default()({\n    loader: () => Promise.all(/* import() | ExplorerNode */[__webpack_require__.e(3), __webpack_require__.e(6)]).then(__webpack_require__.bind(null, 1160)),\n    loading: Loading\n});\n\n\n// ------------------------[ class ]-----------------------------\nclass explorerbranch_ExplorerBranch extends Component {\n    constructor() {\n        // ---------------------[ initialization ]------------------------\n        super(...arguments);\n        this.state = {\n            branchNodes: [],\n            viewpointData: null,\n            snackbar: { open: false, message: \'empty\' },\n            comparatorselection: \'Off\',\n            techDialogOpen: false,\n            noticeDialogOpen: false,\n            selectionsDialogOpen: false,\n            animations: {\n                buttons: null,\n                controls: null\n            }\n        };\n        this.waitafteraction = 0;\n        /*\n            getState() and getProps() for budgetBranch object:\n            return fresh copy of state object; changes after being set\n            used by budgetBranch instance\n        */\n        this.getState = () => this.state;\n        this.getProps = () => this.props;\n        // provide for curried versions\n        this.addNodeDeclaration = branchUid => settings => this.props.globalStateActions.addNodeDeclaration(branchUid, settings);\n        this.addNodeDeclarations = branchUid => settingslist => this.props.globalStateActions.addNodeDeclarations(branchUid, settingslist);\n        this.removeNodeDeclarations = branchUid => nodeItems => this.props.globalStateActions.removeNodeDeclarations(branchUid, nodeItems);\n        this.urlparms = null;\n        this.urlparmscleared = [];\n        this.clearUrlParms = nodeIndex => {\n            if (!this.urlparms) {\n                console.error(\'call to remove expired urlparms\', nodeIndex);\n            }\n            this.urlparmscleared.push(nodeIndex);\n            if (this.urlparmscleared.length == this.urlparms.settingsdata.length) {\n                this.urlparms = null;\n                this.urlparmscleared = [];\n            }\n            setTimeout(() => {\n                this.onPortalCreation();\n            }, 1000);\n        };\n        this.logEvent = parms => {\n            if (window.location.hostname == \'budgetpedia.ca\') {\n                ReactGA.event(parms);\n            }\n        };\n        //----------------------------[ stories ]--------------------------------\n        // these are sets of branches; this section is for this branch\'s story section\n        this.story = null;\n        this.storiescleared = [];\n        this.storysettings = [];\n        this.clearStory = nodeIndex => {\n            if (!this.story) {\n                console.error(\'call to remove expired story\', nodeIndex);\n            }\n            this.storiescleared.push(nodeIndex);\n            if (this.storiescleared.length == this.storysettings.length) {\n                this.story = null;\n                this.storiescleared = [];\n                setTimeout(() => {\n                    this.onPortalCreation();\n                }, 1000);\n            }\n        };\n        this._createStoryNodes = (story, viewpointdata) => {\n            let path = this._getStoryPath(story);\n            // console.log(\'story path\',story.code,path)\n            this.props.clearStories(branch_class["a" /* default */]);\n            story.path = path;\n            let settingslist = this._getStorySettingsList(story, viewpointdata);\n            this.storysettings = settingslist;\n            // console.log(\'settingslist\',settingslist)\n            let explorerbranch = this;\n            explorerbranch._stateActions.addNodeDeclarations(settingslist);\n        };\n        this._getStoryPath = story => {\n            let path = [];\n            let viewpoint = this.state.viewpointData;\n            // console.log(\'story viewpoint data\',viewpoint)\n            if (viewpoint.Components && story.code) {\n                this._getPath(path, story.code, viewpoint.Components);\n            }\n            return path;\n        };\n        this._getStorySettingsList = (story, viewpointdata) => {\n            let settingslist = [];\n            let path = story.path;\n            let nodeCount = path.length + 1;\n            for (let n = 0; n < nodeCount; n++) {\n                let nodeDefaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.node));\n                let nodeSettings = {\n                    aspectName: story.aspect,\n                    cellIndex: n == nodeCount - 1 ? story.tab : 0,\n                    cellList: null,\n                    dataPath: path.slice(0, n),\n                    nodeIndex: n,\n                    viewpointName: story.viewpoint,\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                let settings = Object.assign(nodeDefaultSettings, nodeSettings);\n                settingslist.push({\n                    settings\n                });\n            }\n            return settingslist;\n        };\n        // -------------------------[ utilities ]----------------------\n        this._getPath = (path, targetcode, components) => {\n            for (let code in components) {\n                if (code == targetcode) {\n                    let subcomponents = components[code].Components;\n                    if (!subcomponents) {\n                        subcomponents = components[code].CommonDimension;\n                    }\n                    if (subcomponents) {\n                        path.push(code);\n                    }\n                    return true;\n                }\n                let subcomponents = components[code].Components;\n                if (subcomponents) {\n                    path.push(code);\n                    if (this._getPath(path, targetcode, subcomponents)) {\n                        return true;\n                    } else {\n                        path.pop();\n                    }\n                }\n            }\n            return false;\n        };\n        this._createUrlNodes = urlparms => {\n            this.urlparms = urlparms;\n            this.props.clearUrlParms();\n            try {\n                let path = urlparms.branchdata.pa;\n                // TODO: validate data path\n                let dataNode = Object(getbudgetnode["a" /* default */])(this.state.viewpointData, path);\n                // let dataNode = null\n                if (dataNode) {\n                    let settingslist = this._geturlsettingslist(urlparms);\n                    this._stateActions.addNodeDeclarations(settingslist);\n                    return true;\n                } else {\n                    this.props.setToast(\'error\', \'unable to locate data requested by url parameter. Using defaults...\');\n                }\n            } catch (e) {\n                console.log(\'urlparms failure\', urlparms);\n                this.urlparms = null;\n            }\n            return false;\n        };\n        this._geturlsettingslist = urlparms => {\n            let nodesettings = urlparms.settingsdata;\n            let branch = urlparms.branchdata;\n            let settingslist = [];\n            for (let nodeindex in nodesettings) {\n                let node = nodesettings[nodeindex];\n                let settings = {\n                    aspectName: branch.as,\n                    cellIndex: node.ci,\n                    cellList: null,\n                    dataPath: branch.pa.slice(0, parseInt(nodeindex)),\n                    nodeIndex: parseInt(nodeindex),\n                    viewpointName: branch.vi,\n                    yearSelections: {\n                        leftYear: node.ys.ly,\n                        rightYear: node.ys.ry\n                    },\n                    yearsRange: {\n                        firstYear: null,\n                        lastYear: null\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n            }\n            return settingslist;\n        };\n        this._initialize = () => {\n            let branch = this;\n            let { budgetBranch, globalStateActions: actions, declarationData } = branch.props;\n            // create global actions bundle for children\n            branch._stateActions = Object.assign({}, actions);\n            // replace originals with curried versions\n            branch._stateActions.addNodeDeclaration = branch.addNodeDeclaration(budgetBranch.uid);\n            branch._stateActions.addNodeDeclarations = branch.addNodeDeclarations(budgetBranch.uid);\n            branch._stateActions.removeNodeDeclarations = branch.removeNodeDeclarations(budgetBranch.uid);\n            let { onPortalCreation } = branch;\n            // create display callbacks bundle for children\n            branch._nodeDisplayCallbacks = {\n                onPortalCreation\n            };\n            // complete initialization of budgetBranch class instance\n            // assign helpful getters and setters to budgetBranch\n            budgetBranch.getProps = branch.getProps;\n            budgetBranch.getState = branch.getState;\n            budgetBranch.setState = branch.setState.bind(branch);\n            // assign callbacks to budgetBranch\n            budgetBranch.actions = branch._stateActions;\n            budgetBranch.nodeCallbacks = branch._nodeDisplayCallbacks;\n            branch._previousControlData = declarationData; // initialize\n        };\n        this._getLeafPath = (code, viewpointdata) => {\n            // console.log(\'code, viewpointdata\',code, viewpointdata)\n            let path = [];\n            let selections = [];\n            // let code = parms.code\n            let result = this._searchComponents(code, path, selections, viewpointdata.Components, viewpointdata.SortedComponents);\n            if (!result) {\n                path = [];\n                // toastr.warning(parms.aspect + \' chart not available for that selection (\' + parms.name + \')\')\n            }\n            let isLeaf = !path.pop();\n            if (isLeaf) {\n                path.pop();\n                selections.pop();\n            }\n            this.pathSelections = selections;\n            // console.log(\'leafpath, selections\',path,selections)\n            return path;\n        };\n        this.lastactiongeneration = 0;\n        /*\n            harmonization means creating local nodes to match global declarations\n            acts as a sentinel; if count goes below zero, means that some\n            harmonization operation has failed, which is a system error\n        */\n        this.harmonizecount = null;\n        // harmonize branch nodes; add pending node objects, and process state changes\n        this.harmonizeNodesToState = (branchNodes, nodeList, nodesById, budgetBranch) => {\n            if (this.harmonizecount === null) {\n                // initialize harmonization count\n                this.harmonizecount = nodeList.length - branchNodes.length;\n            }\n            // let harmonizecount = (nodeList.length - branchNodes.length)\n            // first task is to harmonize declarationData nodeList list with local branchNode list\n            // this condition will keep adding nodes on each render cycle triggered by \n            // addBranchNode, until all nodes are drawn\n            if (this.harmonizecount > 0) {\n                // places sentinal in place in case addNode below fails\n                //   generating an infinite loop\n                this.harmonizecount--;\n                let nodeIndex = branchNodes.length;\n                let budgetNodeId = nodeList[nodeIndex];\n                // console.log(\'arguments for addNode\',nodeIndex,nodeList,budgetNodeId,nodesById,this.harmonizecount)\n                // TODO: investigate doing addNodes instead, and adding them to the nodes state in one operation\n                budgetBranch.addNode( // sets state to trigger a render, and re-visitation of this code\n                budgetNodeId, nodeIndex, nodesById[budgetNodeId] // declarations\n                );\n                return true;\n            } else {\n                // otherwise see if there are other cascading actions that have to be taken\n                this.harmonizecount = null; // reset\n                return false;\n            }\n        };\n        // state change machine\n        // TODO return value is ignored\n        this._respondToGlobalStateChange = () => {\n            let { budgetBranch } = this.props;\n            let previousControlData = this._previousControlData;\n            let currentControlData = this.props.declarationData;\n            let { lastTargetedAction } = currentControlData;\n            let lastAction = lastTargetedAction[budgetBranch.uid] || {};\n            let returnvalue = true;\n            if (!explorer_actions["g" /* branchTypes */][lastAction.type]) {\n                return false;\n            }\n            // the generation counter could be the same if render is being triggered\n            // solely by a local state change, which we want to ignore here\n            if (previousControlData && currentControlData.generation == previousControlData.generation) {\n                return false;\n            }\n            switch (lastAction.type) {\n                case explorer_actions["g" /* branchTypes */].CHANGE_VIEWPOINT:\n                    {\n                        this._processChangeViewpointSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].UPDATE_BRANCH:\n                    {\n                        this._processUpdateBranchStateChange(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].CHANGE_VERSION:\n                    {\n                        this._processChangeVersionSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].CHANGE_ASPECT:\n                    {\n                        this._processChangeAspectSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].TOGGLE_INFLATION_ADJUSTED:\n                    {\n                        this._processToggleInflationAdjustedSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].UPDATE_PRORATA:\n                    {\n                        this._processUpdateProrataSelection(budgetBranch);\n                        break;\n                    }\n                case explorer_actions["g" /* branchTypes */].HARMONIZE_CELLS:\n                    {\n                        budgetBranch.harmonizeCells();\n                        break;\n                    }\n                default:\n                    returnvalue = false;\n            }\n            this._previousControlData = currentControlData;\n            return returnvalue;\n        };\n        this._processChangeViewpointSelection = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                let budgetNodeParms = budgetBranch.getInitialBranchNodeParms();\n                this._stateActions.addNodeDeclaration(budgetNodeParms);\n            }).catch(reason => {\n                console.error(\'error in data fetch, changeviewpoint\', reason);\n            });\n        };\n        this._processUpdateBranchStateChange = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                let settingslist = this._getFinderNodeSettingsList();\n                this._stateActions.addNodeDeclarations(settingslist);\n                let explorerbranch = this;\n                setTimeout(() => {\n                    explorerbranch._updateCellChartSelections();\n                });\n                setTimeout(() => {\n                    explorerbranch.onPortalCreation();\n                }, 1000);\n            }).catch(reason => {\n                console.error(\'error in data fetch, update branch\', reason);\n            });\n        };\n        this._updateCellChartSelections = () => {\n            let nodes = this.state.branchNodes;\n            let selections = this.pathSelections;\n            for (let index in selections) {\n                let node = nodes[index];\n                let cell = node.cells[0];\n                let selection = selections[index];\n                this._stateActions.updateCellChartSelection(node.uid)(cell.uid, selection);\n                cell.chartSelection = selection;\n                cell.refreshSelection();\n            }\n        };\n        // --------------------------[ finder (search) ]-----------------------------\n        this._getFinderNodeSettingsList = () => {\n            let viewpointdata = this.state.viewpointData;\n            let parms = this.finderParms;\n            let dictionary = this.findParmsToStateDictionary;\n            let settingslist = [];\n            // let defaults = this.props.declarationData.defaults.node\n            // console.log(\'viewpointdata\',viewpointdata)\n            // if this is a common dimension request, return first portal only\n            if (parms.source == \'detailedbudgets\' && [\'expense\', \'revenue\', \'permanence\'].indexOf(parms.level) > -1) {\n                // console.log(\'found common dimension\')\n                let settings = {\n                    aspectName: dictionary.aspect[parms.aspect],\n                    cellIndex: 1,\n                    cellList: null,\n                    dataPath: [],\n                    nodeIndex: 0,\n                    viewpointName: dictionary.viewpoint[parms.viewpoint],\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n                lib["toastr"].info(\'Find \' + dictionary.level[parms.level].toUpperCase() + \' tabs at any program drilldown level\');\n            } else {\n                let leafpath = this._getLeafPath(parms.code, viewpointdata);\n                let settings = {\n                    aspectName: dictionary.aspect[parms.aspect],\n                    cellIndex: 0,\n                    cellList: null,\n                    dataPath: [],\n                    nodeIndex: 0,\n                    viewpointName: dictionary.viewpoint[parms.viewpoint],\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n                for (let nodeindex in leafpath) {\n                    let settings = {\n                        aspectName: dictionary.aspect[parms.aspect],\n                        cellIndex: 0,\n                        cellList: null,\n                        dataPath: leafpath.slice(0, parseInt(nodeindex) + 1),\n                        nodeIndex: parseInt(nodeindex) + 1,\n                        viewpointName: dictionary.viewpoint[parms.viewpoint],\n                        yearSelections: {\n                            leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                            rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                        },\n                        yearsRange: {\n                            firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                            lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                        }\n                    };\n                    settingslist.push({\n                        settings\n                    });\n                }\n            }\n            // console.log(\'viewpointdata and parms in get node settings list\',viewpointdata, parms, settingslist)\n            return settingslist;\n        };\n        this._searchComponents = (code, path, selections, components, sortedcomponents) => {\n            for (let component_name in components) {\n                path.push(component_name);\n                if (component_name == code) {\n                    // leaf\n                    let depth = path.length;\n                    let selection;\n                    for (let index = 0; index < sortedcomponents.length; index++) {\n                        if (sortedcomponents[index].Code == component_name) {\n                            selection = index;\n                            break;\n                        }\n                    }\n                    selections[depth - 1] = selection;\n                    let node = components[component_name];\n                    if (node.Components || node.CommonDimension) {\n                        path.push(true);\n                    } else {\n                        path.push(false);\n                    }\n                    return true;\n                } else {\n                    let subcomponents = components[component_name].Components;\n                    let depth = path.length;\n                    if (subcomponents) {\n                        let sortedsubcomponents = components[component_name].SortedComponents;\n                        if (this._searchComponents(code, path, selections, subcomponents, sortedsubcomponents)) {\n                            // console.log(\'returning from depth\',depth,code,component_name,components,sortedcomponents)\n                            let selection;\n                            for (let index = 0; index < sortedcomponents.length; index++) {\n                                if (sortedcomponents[index].Code == component_name) {\n                                    selection = index;\n                                    break;\n                                }\n                            }\n                            selections[depth - 1] = selection;\n                            // TODO add selection\n                            return true;\n                        }\n                    }\n                }\n                path.pop();\n            }\n            return false;\n        };\n        // ---------------------------[ user requested state changes ]------------------\n        this._processChangeVersionSelection = budgetBranch => {\n            // console.log(\'previousVersionPath\',this.previousVersionPath)\n            budgetBranch.getViewpointData().then(() => {\n                let path = this.previousVersionPath;\n                if (path.length) {\n                    let code = path.pop();\n                    path = this._getLeafPath(code, this.state.viewpointData);\n                }\n                let settingslist = this._getTreeSelectionNodeSettingsList(path);\n                this._stateActions.addNodeDeclarations(settingslist);\n                let explorerbranch = this;\n                setTimeout(() => {\n                    explorerbranch._updateCellChartSelections();\n                }, 500);\n                setTimeout(() => {\n                    explorerbranch.onPortalCreation();\n                }, 1000);\n                // this._stateActions.incrementBranchDataVersion(budgetBranch.uid)\n                // let budgetNodeParms:BudgetNodeDeclarationParms = budgetBranch.getInitialBranchNodeParms()\n                // this._stateActions.addNodeDeclaration(budgetNodeParms)\n            }).catch(reason => {\n                console.error(\'error in data fetch, changeversion\', reason);\n            });\n        };\n        this._processToggleInflationAdjustedSelection = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                budgetBranch.toggleInflationAdjusted();\n            }).catch(reason => {\n                console.error(\'error in data fetch, toggle inflation adjustment\', reason);\n            });\n        };\n        this._processUpdateProrataSelection = budgetBranch => {\n            budgetBranch.calculateProRata(this.state.viewpointData).then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                budgetBranch.updateProrata();\n            }).catch(reason => {\n                console.error(\'error in data fetch, updata prorata\', reason);\n            });\n        };\n        this._processChangeAspectSelection = budgetBranch => {\n            budgetBranch.getViewpointData().then(() => {\n                this._stateActions.incrementBranchDataVersion(budgetBranch.uid);\n                let switchResults = budgetBranch.switchAspect();\n                let { deeperdata, shallowerdata, mismatch } = switchResults;\n                if (mismatch) {\n                    let message = switchResults.message;\n                    let { snackbar } = this.state;\n                    snackbar = Object.assign({}, snackbar);\n                    snackbar.message = message;\n                    snackbar.open = true;\n                    this.setState({\n                        snackbar\n                    });\n                }\n                if (deeperdata || shallowerdata) {\n                    let message = null;\n                    if (deeperdata) {\n                        message = "More drilldown is available for current selection";\n                    } else {\n                        message = "Less drilldown is available for current selection";\n                    }\n                    let { snackbar } = this.state;\n                    snackbar = Object.assign({}, snackbar);\n                    snackbar.message = message;\n                    snackbar.open = true;\n                    this.setState({\n                        snackbar\n                    });\n                }\n            }).catch(reason => {\n                console.error(\'error in data fetch, changeaspect\', reason);\n            });\n        };\n        this.handleSnackbarRequestClose = () => {\n            // this.props.globalStateActions.resetLastAction()\n            this.setState({\n                snackbar: {\n                    open: false,\n                    message: \'empty\'\n                }\n            });\n        };\n        // ============================================================\n        // ---------------------[ *** BRANCH *** CONTROL RESPONSES ]------------------\n        // onPortalCreation animates scroll-in of new portal\n        this.branchScrollBlock = null;\n        this.onPortalCreation = () => {\n            let element = this.branchScrollBlock;\n            if (!element) {\n                console.error(\'System Error: expected branch element not found in onPortalCreation\');\n                return;\n            }\n            setTimeout(() => {\n                let scrollwidth = element.scrollWidth;\n                let scrollleft = element.scrollLeft;\n                let clientwidth = element.clientWidth;\n                let scrollright = scrollleft + clientwidth;\n                let targetright = scrollwidth - 500;\n                let adjustment = scrollright - targetright;\n                // console.log(\'scrollwidth,scrollleft,clientwidth,scrollright,targetright,adjustment\',scrollwidth,scrollleft,clientwidth,scrollright,targetright,adjustment)\n                if (adjustment > 0) {\n                    adjustment = Math.min(adjustment, scrollleft);\n                }\n                // console.log(\'final adjustment\',adjustment)\n                let frames = 60;\n                let t = 1 / frames;\n                let counter = 0;\n                let tick = () => {\n                    counter++;\n                    let factor = this.easeOutCubic(counter * t);\n                    let scrollinterval = adjustment * factor;\n                    element.scrollLeft = scrollleft - scrollinterval;\n                    if (counter < frames) {\n                        requestAnimationFrame(tick);\n                    }\n                };\n                requestAnimationFrame(tick);\n            }, 10);\n        };\n        // from https://github.com/DelvarWorld/easing-utils/blob/master/src/easing.js\n        this.easeOutCubic = t => {\n            const t1 = t - 1;\n            return t1 * t1 * t1 + 1;\n        };\n        // ---------------------[ user interactions ]---------------------------\n        this.selectViewpoint = viewpointname => {\n            let { budgetBranch } = this.props;\n            let { nodes: branchNodes } = budgetBranch;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = this._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            globalStateActions.changeViewpoint(budgetBranch.uid, viewpointname);\n        };\n        this.previousVersionPath = null;\n        this.selectVersion = versionName => {\n            let { budgetBranch } = this.props;\n            let { nodes: branchNodes } = budgetBranch;\n            let path = null;\n            for (let n = branchNodes.length - 1; n >= 0; n--) {\n                let node = branchNodes[n];\n                if (node.treeNodeData.Baseline) {\n                    path = node.dataPath;\n                }\n                if (!path) path = node.dataPath;\n            }\n            this.previousVersionPath = path;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = this._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            // now the viewpoint can be changed, triggering a change in viewpoint data\n            globalStateActions.changeVersion(budgetBranch.uid, versionName);\n        };\n        this.selectAspect = aspect => {\n            switch (aspect) {\n                case "Expenses":\n                case "Revenues":\n                case "Staffing":\n                    break;\n                default:\n                    return;\n            }\n            let { budgetBranch } = this.props;\n            budgetBranch.saveNodeStates();\n            this.props.globalStateActions.changeAspect(budgetBranch.uid, aspect);\n        };\n        this.switchComparator = comparatorindex => {\n            let { budgetBranch } = this.props;\n            this.props.globalStateActions.updateProrata(budgetBranch.uid, comparatorindex);\n        };\n        this.toggleInflationAdjustment = value => {\n            let { budgetBranch } = this.props;\n            this.props.globalStateActions.toggleInflationAdjusted(budgetBranch.uid, value);\n        };\n        this.toggleShowOptions = value => {\n            let anims = {\n                buttons: null,\n                controls: null\n            };\n            this.setState({\n                animations: anims\n            }, () => {\n                let a = value ? animations.fadeIn : animations.fadeOut;\n                let anims = {\n                    buttons: a,\n                    controls: a\n                };\n                this.setState({\n                    animations: anims\n                }, () => {\n                    let { budgetBranch } = this.props;\n                    this.props.globalStateActions.toggleShowOptions(budgetBranch.uid, value);\n                });\n            });\n        };\n        // ---------------------------[ search dialog response ]-------------------------\n        this.handleSearch = e => {\n            this.props.handleSearchDialogOpen(e, this.applySearchBranchSettings);\n        };\n        this.finderParms = null;\n        this.findParmsToStateDictionary = {\n            viewpoint: {\n                functionalbudget: \'FUNCTIONAL\',\n                structuralbudget: \'STRUCTURAL\',\n                actualexpenses: \'ACTUALEXPENSES\',\n                actualrevenues: \'ACTUALREVENUES\',\n                expenditures: \'EXPENDITURES\'\n            },\n            source: {\n                summarybudgets: \'SUMMARY\',\n                detailedbudgets: \'PBFT\',\n                auditedexpenses: \'ACTUALEXPENSES\',\n                auditedrevenues: \'ACTUALREVENUES\',\n                auditedexpenditures: \'EXPENDITURES\'\n            },\n            aspect: {\n                expenses: \'Expenses\',\n                revenues: \'Revenues\',\n                staffing: \'Staffing\',\n                expenditures: \'Expenditure\'\n            },\n            level: {\n                expense: \'Expenditures\',\n                revenue: \'Receipts\',\n                permanence: \'Permanence\'\n            }\n        };\n        this.applySearchBranchSettings = parms => {\n            let explorerbranch = this;\n            if (parms.viewpoint == \'expenditures\') {\n                parms.aspect = \'expenditures\';\n            }\n            explorerbranch.finderParms = parms;\n            let { budgetBranch } = explorerbranch.props;\n            let { nodes: branchNodes } = budgetBranch;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = explorerbranch._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            let settings = explorerbranch._getNewBranchSettings(parms);\n            globalStateActions.updateBranch(budgetBranch.uid, settings);\n        };\n        this._getNewBranchSettings = parms => {\n            let dictionary = this.findParmsToStateDictionary;\n            let settings = {\n                viewpoint: dictionary.viewpoint[parms.viewpoint],\n                aspect: dictionary.aspect[parms.aspect],\n                version: dictionary.source[parms.source]\n            };\n            return settings;\n        };\n        // ------------------------------[ workspace tree selection response ]------------------------\n        this.applytaxonomyselection = parms => {\n            let targetcode = parms.selectedleafnode ? parms.selectedleafnode : parms.selectedtreenode;\n            // console.log(\'applytaxonomyselection parms\',parms,targetcode)\n            let branchDeclaration = this.props.declarationData.branchesById[this.props.budgetBranch.uid];\n            let pathParms = {\n                code: targetcode,\n                aspect: branchDeclaration.aspect,\n                name: targetcode\n            };\n            let path = this._getLeafPath(pathParms.code, this.state.viewpointData);\n            // console.log(\'path\',path)\n            // remove previous branches\n            let { budgetBranch } = this.props;\n            let { nodes: branchNodes } = budgetBranch;\n            // branchNodes is just a copy of the component state\'s BranchNodes\n            let removed = branchNodes.splice(0); // identify nodes to remove\n            let removeditems = removed.map(item => {\n                return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n            });\n            // this will trigger render cycle that will delete the component state\'s stored nodes\n            let globalStateActions = this._stateActions;\n            globalStateActions.removeNodeDeclarations(removeditems);\n            // add new branches\n            let settingslist = this._getTreeSelectionNodeSettingsList(path);\n            this._stateActions.addNodeDeclarations(settingslist);\n            let explorerbranch = this;\n            setTimeout(() => {\n                explorerbranch._updateCellChartSelections();\n            }, 500);\n            setTimeout(() => {\n                explorerbranch.onPortalCreation();\n            }, 1000);\n        };\n        this._getTreeSelectionNodeSettingsList = path => {\n            let settingslist = [];\n            let viewpointdata = this.state.viewpointData;\n            let branchDeclaration = this.props.declarationData.branchesById[this.props.budgetBranch.uid];\n            let settings = {\n                aspectName: branchDeclaration.aspect,\n                cellIndex: 0,\n                cellList: null,\n                dataPath: [],\n                nodeIndex: 0,\n                viewpointName: branchDeclaration.viewpoint,\n                yearSelections: {\n                    leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                    rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                },\n                yearsRange: {\n                    firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                    lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                }\n            };\n            settingslist.push({\n                settings\n            });\n            for (let nodeindex in path) {\n                let settings = {\n                    aspectName: branchDeclaration.aspect,\n                    cellIndex: 0,\n                    cellList: null,\n                    dataPath: path.slice(0, parseInt(nodeindex) + 1),\n                    nodeIndex: parseInt(nodeindex) + 1,\n                    viewpointName: branchDeclaration.viewpoint,\n                    yearSelections: {\n                        leftYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        rightYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    },\n                    yearsRange: {\n                        firstYear: viewpointdata.Meta.datasetConfig.YearsRange.start,\n                        lastYear: viewpointdata.Meta.datasetConfig.YearsRange.end\n                    }\n                };\n                settingslist.push({\n                    settings\n                });\n            }\n            return settingslist;\n        };\n        // ---------------------------[ callbacks ]------------------------------\n        /*\n            harmonize:\n            node:\n            - tab selection cellIndex\n            - yearSelections selection yearSelections\n            cell:\n            - yearScope selection "OneYear" etc.\n            - chart selection [YearScope].ExplorerChartCode\n                 TODO: if the reference chart is an expenditure chart\n                then all other nodes should also show expenditure chart\n                -- so if the reference chart is in the leaf node\n        */\n        this.harmonizeCells = (nodeUid, cellUid) => {\n            let { budgetBranch } = this.props;\n            let nodeList = [];\n            let cellList = [];\n            let nodeProperties = { cellIndex: null, yearSelections: null };\n            let cellProperties = { yearScope: null, chartCode: null, nodeDataseriesName: null };\n            let declarationData = this.props.declarationData;\n            let refnode = declarationData.nodesById[nodeUid];\n            let refcell = declarationData.cellsById[cellUid];\n            // get defaults to apply\n            nodeProperties.cellIndex = refnode.cellIndex;\n            nodeProperties.yearSelections = Object.assign({}, refnode.yearSelections);\n            cellProperties.yearScope = refcell.yearScope;\n            cellProperties.chartCode = refcell.chartConfigs[refcell.yearScope].explorerChartCode;\n            cellProperties.nodeDataseriesName = refcell.nodeDataseriesName;\n            // collect node and cell lists\n            let nodeidlist = declarationData.branchesById[budgetBranch.uid].nodeList;\n            for (let nodeid of nodeidlist) {\n                // if (nodeid == nodeUid) continue\n                nodeList.push(nodeid);\n                let tempnode = declarationData.nodesById[nodeid];\n                let cellidlist = tempnode.cellList;\n                for (let cellid of cellidlist) {\n                    if (cellid == cellUid) continue;\n                    cellList.push(cellid);\n                }\n            }\n            if (nodeList.length > 0) {\n                this._stateActions.harmonizeCells(budgetBranch.uid, nodeProperties, cellProperties, nodeList, cellList);\n            }\n        };\n        // -----------------------------[ prepare for render ]---------------------------------\n        // get React components to render\n        this.getPortals = budgetNodes => {\n            let branch = this;\n            let { viewpointData } = branch.state;\n            if (!viewpointData) return [];\n            let datasetConfig = viewpointData.Meta.datasetConfig;\n            let portalSeriesName = datasetConfig.DatasetName;\n            if (datasetConfig.Units == \'DOLLAR\') {\n                portalSeriesName += \' (\' + datasetConfig.UnitsAlias + \')\';\n            }\n            let portals = budgetNodes.map((budgetNode, nodeindex) => {\n                let branchDeclaration = branch.props.declarationData.branchesById[branch.props.budgetBranch.uid];\n                let portalName = null;\n                let treeNodeData = budgetNode.treeNodeData;\n                if (treeNodeData.Name) {\n                    // .Name) // MetaDataFromParentSortedList) {\n                    portalName = budgetNode.treeNodeData.Name;\n                    portalName += \' \' + portalSeriesName;\n                } else {\n                    portalName = datasetConfig.DatasetTitle; //\'City Budget\'\n                }\n                let portalConfig = {\n                    portalName\n                };\n                budgetNode.portalConfig = portalConfig;\n                let viewpointdata = branch.state.viewpointData;\n                let { NamingConfigurations: viewpointNamingConfigs,\n                    // datasetConfig, declared previously\n                    isInflationAdjusted } = viewpointdata.Meta;\n                let viewpointConfigPack = {\n                    viewpointNamingConfigs,\n                    datasetConfig,\n                    isInflationAdjusted,\n                    prorata: branchDeclaration.prorata\n                };\n                budgetNode.viewpointConfigPack = viewpointConfigPack;\n                budgetNode.branchSettings = branch.props.budgetBranch.branchDeclaration;\n                budgetNode.onChartComponentSelection = onChartComponentSelection(branch.props.budgetBranch);\n                let actions = Object.assign({}, branch._stateActions);\n                actions.updateCellTimeScope = branch._stateActions.updateCellTimeScope(budgetNode.uid);\n                actions.updateCellChartSelection = branch._stateActions.updateCellChartSelection(budgetNode.uid);\n                actions.updateCellChartCode = branch._stateActions.updateCellChartCode(budgetNode.uid);\n                actions.updateCellYearSelections = branch._stateActions.updateCellYearSelections(budgetNode.uid);\n                return react["createElement"](ExplorerNode, { key: budgetNode.uid, callbackid: nodeindex, budgetNode: budgetNode, declarationData: branch.props.declarationData, globalStateActions: actions, showControls: branchDeclaration.showOptions, dataGenerationCounter: branchDeclaration.branchDataGeneration, callbacks: { harmonizeCells: branch.harmonizeCells }, urlparms: this.urlparms, story: this.story, clearUrlParms: this.clearUrlParms, clearStory: this.clearStory, onCallAnalystNotes: this.props.onCallAnalystNotes });\n            });\n            return portals;\n        };\n        this._inputonfocus = () => {\n            this._inputfieldref.setSelectionRange(0, this._inputfieldref.value.length);\n        };\n        // ----------------------------[ response to share request ]--------------------------\n        this.shareBranch = () => {\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Share branch\'\n            });\n            let longurl = this._getShareUrl();\n            // console.log(\'long url\',longurl)\n            this._getBitlyUrl(longurl).then(json => {\n                // console.log(\'result\',json)\n                if (json.status_code != 200) {\n                    let errmessage = json.status_txt + \'(\' + json.status_code + \')\';\n                    console.log(\'error message\', errmessage);\n                    throw new Error(errmessage);\n                }\n                let url = json.data.url;\n                let toastrComponent = () => react["createElement"]("div", { style: { width: "300px" } }, react["createElement"]("p", { style: { width: "290px" } }, "To share the selected row of charts, copy the url below, and send it to a friend."), react["createElement"]("input", { ref: node => {\n                        this._inputfieldref = node;\n                    }, onFocus: this._inputonfocus, style: { width: "290px" }, value: url, readOnly: true }));\n                let toastrOptions = {\n                    icon: react["createElement"](FontIcon_default.a, { className: "material-icons" }, "share"),\n                    component: toastrComponent\n                };\n                lib["toastr"].message(\'Share charts\', toastrOptions);\n            }).catch(error => {\n                console.log(\'error getting bitly\', error);\n                lib["toastr"].error(\'Bitly error\', error.message);\n            });\n        };\n        // bitly token: bdf92b4b130fbc1d19871694f8fe957ccb775e12\n        this._getBitlyUrl = longurl => {\n            let token = \'bdf92b4b130fbc1d19871694f8fe957ccb775e12\';\n            return fetch(\'https://api-ssl.bitly.com/v3/shorten?access_token=\' + token + \'&longUrl=\' + encodeURIComponent(\'http://\' + longurl)).then(response => {\n                // let reply = response.\n                let json = response.json();\n                return json;\n            }).catch(error => {\n                console.error(\'error getting bitly url\', error);\n            });\n        };\n        this._getShareUrl = () => {\n            let branch = this;\n            let branchDeclaration = branch.props.declarationData.branchesById[branch.props.budgetBranch.uid];\n            let government = branchDeclaration.repository;\n            let viewpoint = branchDeclaration.viewpoint;\n            let version = branchDeclaration.version;\n            let aspect = branchDeclaration.aspect;\n            let prorata = branchDeclaration.prorata;\n            let adjusted = branchDeclaration.inflationAdjusted;\n            let path = this.state.branchNodes[this.state.branchNodes.length - 1].dataPath;\n            let query = {\n                g: government,\n                vi: viewpoint,\n                ve: version,\n                as: aspect,\n                pr: prorata,\n                ad: adjusted,\n                pa: path\n            };\n            let nodeDeclarations = [];\n            let node;\n            for (node of this.state.branchNodes) {\n                nodeDeclarations.push(node.nodeDeclaration);\n            }\n            let settings = [];\n            for (let nodeDeclaration of nodeDeclarations) {\n                let cellDeclarations = [];\n                for (let celluid of nodeDeclaration.cellList) {\n                    cellDeclarations.push(branch.props.declarationData.cellsById[celluid]);\n                }\n                let cellSettingsList = [];\n                // TODO: only process the cellDeclaration for current cellIndex\n                for (let cellDeclaration of cellDeclarations) {\n                    let cellSettings = {\n                        ys: cellDeclaration.yearScope,\n                        // cs:cellDeclaration.chartSelection,\n                        ct: cellDeclaration.chartConfigs[cellDeclaration.yearScope].explorerChartCode\n                    };\n                    cellSettingsList.push(cellSettings);\n                }\n                let nodesettings = {\n                    ci: nodeDeclaration.cellIndex,\n                    ys: {\n                        ly: nodeDeclaration.yearSelections.leftYear,\n                        ry: nodeDeclaration.yearSelections.rightYear\n                    },\n                    c: cellSettingsList[nodeDeclaration.cellIndex]\n                };\n                settings.push(nodesettings);\n            }\n            let branchstring = jsonpack.pack(query);\n            let bsencoded = encodeURIComponent(branchstring);\n            let settingsstring = jsonpack.pack(settings);\n            let ssencoded = encodeURIComponent(settingsstring);\n            let hashcode = utilities["b" /* default */].hashCode(branchstring + settingsstring);\n            // console.log(\'query\',query, branchstring,branchstring.length,bsencoded,bsencoded.length)\n            // console.log(\'settings\',settings,settingsstring, settingsstring.length,ssencoded,ssencoded.length)\n            let url = location.hostname + \'/explorer?branch=\' + bsencoded + \'&settings=\' + ssencoded + \'&hash=\' + hashcode;\n            // console.log(\'url\',url,url.length)\n            return url;\n        };\n        // -------------------------------------[ handle dialog requests ]-----------------------\n        this.handleSelectionsDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Selections Dialog\'\n            });\n            this.setState({\n                selectionsDialogOpen: true\n            });\n        };\n        this.handleTechDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Show sources\'\n            });\n            this.setState({\n                techDialogOpen: true\n            });\n        };\n        this.handleNoticeDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Show notices\'\n            });\n            this.setState({\n                noticeDialogOpen: true\n            });\n        };\n        this.handleSelectionsDialogClose = () => {\n            this.setState({\n                selectionsDialogOpen: false\n            });\n        };\n        this.handleTechDialogClose = () => {\n            this.setState({\n                techDialogOpen: false\n            });\n        };\n        this.handleNoticeDialogClose = () => {\n            this.setState({\n                noticeDialogOpen: false\n            });\n        };\n        this.openwindow = url => {\n            open(url, \'_blank\');\n        };\n        this.getBranchDataMessages = () => {\n            if (!this.state.viewpointData) return null;\n            let { datasetConfig } = this.state.viewpointData.Meta;\n            let { DatasetTitle, Sources } = datasetConfig;\n            let { Messages } = Sources;\n            let messages = [];\n            for (let index in Messages) {\n                messages.push(react["createElement"]("div", { key: index }, Messages[index]));\n            }\n            // console.log(\'messages\',messages, Messages)\n            return messages.length > 0 ? react["createElement"]("div", { style: { padding: "3px", margin: "3px", backgroundColor: "LemonChiffon" } }, messages) : null;\n        };\n        this.getTechNotesDisplay = () => {\n            if (!this.state.viewpointData) return null;\n            let { datasetConfig } = this.state.viewpointData.Meta;\n            let { DatasetTitle, Sources } = datasetConfig;\n            let { Headers } = Sources;\n            // console.log(\'headers\',Headers)\n            let headerkeys = Object.keys(Headers);\n            let itemlist = headerkeys.map(headerkey => {\n                let item = Headers[headerkey];\n                let notes = item.NOTES_CONTENT;\n                let link = item.SOURCE_DOCUMENT_LINK_COPY;\n                let isvalidurl = validurl.isUri(link);\n                let doctitle = item.SOURCE_DOCUMENT_TITLE;\n                let tablelocation = item.SOURCE_DOCUMENT_TABLE_LOCATION;\n                let tabletitle = item.SOURCE_DOCUMENT_TABLE_TITLE;\n                // console.log(\'ListItem values\',notes, link, isvalidurl, doctitle, tablelocation,tabletitle)\n                return react["createElement"]("div", { key: headerkey, style: {\n                        marginBottom: "8px",\n                        border: "1px solid silver",\n                        borderRadius: "8px",\n                        padding: "3px"\n                    } }, react["createElement"](RaisedButton_default.a, { style: { marginLeft: "3px", float: "right" }, disabled: !isvalidurl, type: "button", label: "Source", onClick: () => {\n                        isvalidurl ? this.openwindow(link) : void 0;\n                    } }), react["createElement"]("div", { style: { fontWeight: "bold" } }, headerkey), react["createElement"]("div", { style: { whiteSpace: "normal" } }, react["createElement"]("div", null, "Document title: ", doctitle), !isvalidurl ? react["createElement"]("div", null, "Invalid link! no source available") : null, tabletitle ? react["createElement"]("div", null, "Table title: ", tabletitle) : null, tablelocation ? react["createElement"]("div", null, "Table location: ", tablelocation) : null, notes ? react["createElement"]("div", null, "Note: ", notes) : null));\n            });\n            return react["createElement"]("div", null, react["createElement"](Subheader_default.a, null, DatasetTitle), itemlist);\n        };\n        // handleSearchDialogOpen = (e) => {\n        //     this.props.handleSearchDialogOpen(e)\n        // }\n        this.taxonomychoices = {\n            FUNCTIONAL: "Programs by function",\n            STRUCTURAL: "Programs by org type",\n            ACTUALEXPENSES: "Expenses by function",\n            ACTUALREVENUES: "Revenues by type",\n            EXPENDITURES: "Expenses by type",\n            FINANCIALASSETS: "Financial assets",\n            TANGIBLEASSETS: "Tangible assets",\n            LIABILITIES: "Liabilities",\n            RESERVES: "Reserves"\n        };\n    }\n    // finish initialization of budgetBranch and branch explorer objects\n    componentWillMount() {\n        this._initialize();\n        let { budgetBranch, declarationData } = this.props;\n        let branchDeclarationData = declarationData.branchesById[budgetBranch.uid];\n        if (branchDeclarationData.story) {\n            this.story = branchDeclarationData.story;\n            this._stateActions.clearBranchStory(budgetBranch.uid);\n        }\n        budgetBranch.getViewpointData().then(() => {\n            // console.log(\'branch story var\',this.story)\n            this._stateActions.incrementBranchDataVersion(budgetBranch.uid); // change data generation counter for child compare\n            let story;\n            let explorerbranch = this;\n            if (this.story) {\n                story = explorerbranch.story;\n                explorerbranch._createStoryNodes(story, explorerbranch.state.viewpointData);\n                return; // should never fail as it is internal\n            } // else\n            if (branchDeclarationData.nodeList.length == 0) {\n                let { urlparms } = this.props;\n                if (urlparms) {\n                    if (this._createUrlNodes(urlparms)) return;\n                }\n                let budgetNodeParms = budgetBranch.getInitialBranchNodeParms();\n                // console.log(\'budgetNodeParms in branchWillMount\',budgetNodeParms)\n                this._stateActions.addNodeDeclaration(budgetNodeParms);\n            } else {\n                setTimeout(() => {\n                    this._stateActions.resetLastAction(); // trigger update -> render\n                });\n            }\n        }).catch(reason => {\n            console.error(\'error in data fetch, componentWillMount (branch)\', reason);\n        });\n    }\n    // ---------------------------[ lifecycle events ]--------------------------\n    // remove obsolete node objects\n    componentWillReceiveProps(nextProps) {\n        let { nodesById } = nextProps.declarationData;\n        let branchNodes = this.props.budgetBranch.nodes; // copy\n        let newBranchNodes = branchNodes.filter(node => {\n            return !!nodesById[node.uid];\n        });\n        if (newBranchNodes.length != branchNodes.length) {\n            // some nodes were deleted\n            this.setState({\n                branchNodes: newBranchNodes\n            });\n        }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        let show = false; // debug\n        // Exception: allow snackbar open through in any case\n        if (nextState.snackbar.open != this.state.snackbar.open) {\n            if (show) console.log(\'should update branch return true for snackbar\');\n            return true;\n        }\n        let branchComponent = this;\n        return utilities["b" /* default */].filterActionsForUpdate(nextProps, branchComponent, show);\n    }\n    componentDidUpdate() {\n        // refresh branchnodes\n        let { budgetBranch, declarationData } = this.props;\n        let branchDeclarations = declarationData.branchesById[budgetBranch.uid];\n        let { nodeList } = branchDeclarations;\n        let { nodesById } = this.props.declarationData;\n        let branchNodes = this.props.budgetBranch.nodes; // copy\n        // harmonize is here for first setup; called from will mount for re-creation\n        if (!this.harmonizeNodesToState(branchNodes, nodeList, nodesById, budgetBranch)) {\n            this._respondToGlobalStateChange();\n        }\n        // console.log(\'nodes\', branchNodes)\n    }\n    // -------------------------------------[ render! ]---------------------------------\n    render() {\n        // ---------------------------------[ interactive controls ]--------------------------\n        let branch = this;\n        let drilldownrow = branch.props.budgetBranch.nodes;\n        // console.log(\'drilldownrow\',drilldownrow)\n        let drilldownportals = branch.getPortals(drilldownrow);\n        let branchDeclaration = this.props.declarationData.branchesById[this.props.budgetBranch.uid];\n        let viewpointselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'23px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Select dataset:")), react["createElement"](DropDownMenu_default.a, { value: branchDeclaration.viewpoint, onChange: (e, index, value) => {\n                branch.selectViewpoint(value);\n            } }, react["createElement"]("div", { style: { padding: "3px", fontStyle: \'italic\' } }, "Operating Cash Budget"), react["createElement"](MenuItem_default.a, { value: \'FUNCTIONAL\', primaryText: this.taxonomychoices.FUNCTIONAL }), react["createElement"](MenuItem_default.a, { value: \'STRUCTURAL\', primaryText: this.taxonomychoices.STRUCTURAL }), react["createElement"]("div", { style: { padding: "3px", fontStyle: \'italic\' } }, "Audited Actual"), react["createElement"](MenuItem_default.a, { value: \'ACTUALEXPENSES\', primaryText: this.taxonomychoices.ACTUALEXPENSES }), react["createElement"](MenuItem_default.a, { value: \'ACTUALREVENUES\', primaryText: this.taxonomychoices.ACTUALREVENUES }), react["createElement"](MenuItem_default.a, { value: \'EXPENDITURES\', primaryText: this.taxonomychoices.EXPENDITURES }), react["createElement"](MenuItem_default.a, { value: \'FINANCIALASSETS\', primaryText: this.taxonomychoices.FINANCIALASSETS }), react["createElement"](MenuItem_default.a, { value: \'LIABILITIES\', primaryText: this.taxonomychoices.LIABILITIES }), react["createElement"](MenuItem_default.a, { value: \'NONFINANCIALASSETS\', primaryText: this.taxonomychoices.TANGIBLEASSETS }), react["createElement"](MenuItem_default.a, { value: \'RESERVES\', primaryText: this.taxonomychoices.RESERVES }))));\n        // <span style={{ fontStyle: "italic" }}>Government: </span>\n        let governmentselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "City:")), react["createElement"](DropDownMenu_default.a, { value: "Toronto", disabled: true }, react["createElement"](MenuItem_default.a, { value: \'Toronto\', primaryText: "Toronto, Ontario" })));\n        // TODO externalize this; make it metadata-driven\n        const versionchoices = () => {\n            switch (branchDeclaration.viewpoint) {\n                case "FUNCTIONAL":\n                case "STRUCTURAL":\n                    return [react["createElement"](MenuItem_default.a, { key: 1, value: \'SUMMARY\', primaryText: "Summary PDF reports 2003 - 2017" }, react["createElement"]("em", null, "This data is shallower, but goes back further:")), react["createElement"](MenuItem_default.a, { key: 2, value: \'PBFT\', primaryText: "Detail open data portal files 2011 - 2017" }, react["createElement"]("em", null, "This data drills down to Account Categories:")), react["createElement"](MenuItem_default.a, { key: 3, disabled: true, value: \'VARIANCE\', primaryText: "PDF Variance Reports" })];\n                case \'ACTUALEXPENSES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'ACTUALEXPENSES\', primaryText: "Audited statements 1998 - 2016" })];\n                case \'ACTUALREVENUES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'ACTUALREVENUES\', primaryText: "Audited statements 1998 - 2016" })];\n                case \'EXPENDITURES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'EXPENDITURES\', primaryText: "Audited statements 1998 - 2016" })];\n                case \'FINANCIALASSETS\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'FINANCIALASSETS\', primaryText: "Audited statements 2010 - 2016" })];\n                case \'NONFINANCIALASSETS\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'NONFINANCIALASSETS\', primaryText: "Audited statements 2010 - 2016" })];\n                case \'LIABILITIES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'LIABILITIES\', primaryText: "Audited statements 2010 - 2016" })];\n                case \'RESERVES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'RESERVES\', primaryText: "Audited statements 2010 - 2016" })];\n            }\n        };\n        // TODO: add contitional logic depending on viewpoint selection\n        let versionselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Data source:")), react["createElement"](DropDownMenu_default.a, { disabled: versionchoices().length < 2, value: branchDeclaration.version, onChange: (e, index, value) => {\n                branch.selectVersion(value);\n            } }, versionchoices()));\n        // TODO externalize this; make it metadata-driven\n        const aspectchoices = () => {\n            // console.log(\'branchdeclaration.viewpoint\',branchDeclaration.viewpoint)\n            switch (branchDeclaration.viewpoint) {\n                case "FUNCTIONAL":\n                case "STRUCTURAL":\n                    return [react["createElement"](MenuItem_default.a, { key: 1, value: \'Expenses\', primaryText: "Expenditures" }), react["createElement"](MenuItem_default.a, { key: 2, value: \'Revenues\', primaryText: "Receipts" }), react["createElement"](MenuItem_default.a, { key: 3, value: \'Staffing\', primaryText: "Staffing" })];\n                case \'ACTUALEXPENSES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Expenses\', primaryText: "Expenses" })];\n                case \'ACTUALREVENUES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Revenues\', primaryText: "Revenues" })];\n                case \'EXPENDITURES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Expenditure\', primaryText: "Expenses" })];\n                case \'FINANCIALASSETS\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Assets\', primaryText: "Assets" })];\n                case \'NONFINANCIALASSETS\':\n                    {\n                        return [react["createElement"](MenuItem_default.a, { key: 4, value: \'TangibleAssets\', primaryText: "Tangible Assets" })];\n                    }\n                case \'LIABILITIES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Liabilities\', primaryText: "Liabilities" })];\n                case \'RESERVES\':\n                    return [react["createElement"](MenuItem_default.a, { key: 4, value: \'Reserves\', primaryText: "Reserves" })];\n            }\n        };\n        // aspect = category\n        let aspectselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Category:")), react["createElement"](DropDownMenu_default.a, { disabled: aspectchoices().length < 2, value: branchDeclaration.aspect, onChange: (e, index, value) => {\n                branch.selectAspect(value);\n            } }, aspectchoices()));\n        let byunitselection = react["createElement"]("div", { style: { display: \'inline-block\' } }, react["createElement"]("div", { style: { fontStyle: "italic", display: \'inline-block\', height: \'48px\', verticalAlign: \'top\', paddingTop: \'5px\' } }, react["createElement"]("span", { style: { lineHeight: \'44px\' } }, "Prorated:")), react["createElement"](DropDownMenu_default.a, { value: branchDeclaration.prorata, onChange: (e, index, value) => {\n                this.switchComparator(value);\n            } }, react["createElement"](MenuItem_default.a, { value: \'OFF\', primaryText: "Off" }), react["createElement"](MenuItem_default.a, { value: \'PERPERSON\', primaryText: "Per resident" }), react["createElement"](MenuItem_default.a, { value: \'PER100000PERSONS\', primaryText: "Per 100,000 people" }), react["createElement"](MenuItem_default.a, { value: \'PERHOUSEHOLD\', primaryText: "Per household" }), react["createElement"](MenuItem_default.a, { value: \'PER40000HOUSEHOLDS\', primaryText: "Per 40,000 households" }), react["createElement"](MenuItem_default.a, { value: \'PERWARD\', primaryText: "Per ward (x 44)" }), react["createElement"](MenuItem_default.a, { value: \'PERNEIGHBOURHOOD\', primaryText: "Per neighbourhood (x 4 x 44)" })));\n        let inflationadjustment = react["createElement"]("div", { style: {\n                display: \'inline-block\',\n                whiteSpace: "nowrap",\n                verticalAlign: "top",\n                marginRight: \'16px\'\n            } }, react["createElement"](Toggle_default.a, { label: \'Inflation adjusted:\', style: {\n                height: \'32px\',\n                marginTop: \'16px\',\n                display: \'inline-block\'\n            }, onToggle: (e, value) => {\n                this.toggleInflationAdjustment(value);\n            }, labelStyle: {\n                fontStyle: \'italic\'\n            }, defaultToggled: branchDeclaration.inflationAdjusted }));\n        let showcontrols = react["createElement"]("div", { style: {\n                display: \'inline-block\',\n                whiteSpace: "nowrap",\n                verticalAlign: "top"\n            } }, react["createElement"](Toggle_default.a, { label: \'Show chart controls:\', style: { height: \'32px\', marginTop: \'16px\' }, labelStyle: { fontStyle: \'italic\' }, defaultToggled: branchDeclaration.showOptions, onToggle: (e, value) => {\n                this.toggleShowOptions(value);\n            } }));\n        // dialogs\n        let selectionsdialog = branchDeclaration.showOptions ? react["createElement"](Dialog_default.a, { title: "Select dataset for this row of charts", modal: false, open: branch.state.selectionsDialogOpen, onRequestClose: branch.handleSelectionsDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: branch.handleSelectionsDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", null, react["createElement"]("div", null, governmentselection), react["createElement"]("div", null, viewpointselection), react["createElement"]("div", null, versionselection), react["createElement"]("div", null, aspectselection)), react["createElement"](RaisedButton_default.a, { label: "Done", style: { margin: \'3px 6px 0 0\', float: \'right\' }, onClick: branch.handleSelectionsDialogClose }), react["createElement"]("div", null)) : null;\n        let noticesdialog = branchDeclaration.showOptions ? react["createElement"](Dialog_default.a, { title: "Notices for this data", modal: false, open: branch.state.noticeDialogOpen, onRequestClose: branch.handleNoticeDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: branch.handleNoticeDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), branch.state.noticeDialogOpen ? branch.getBranchDataMessages() : null) : null;\n        let technotesdialog = branchDeclaration.showOptions ? react["createElement"](Dialog_default.a, { title: "Row Data Sources", modal: false, open: branch.state.techDialogOpen, onRequestClose: branch.handleTechDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: branch.handleTechDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", null, "Please report any problems to ", react["createElement"]("a", { target: "_blank", href: "mailto:mail@budgetpedia.ca" }, "mail@budgetpedia.ca"), " "), branch.state.techDialogOpen ? branch.getTechNotesDisplay() : null, react["createElement"]("div", null, "Note: some historical numbers have been allocated to contemporary categories for continuity -- to make the numbers more easily comparable. We plan to disclose continuity details here.")) : null;\n        // dialog calls\n        let technotes = react["createElement"](RaisedButton_default.a, { style: { margin: \'3px 6px 0 0\' }, type: "button", label: "Sources", onClick: branch.handleTechDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "cloud") });\n        let notices = react["createElement"](RaisedButton_default.a, { style: { margin: \'3px 6px 0 0\' }, type: "button", label: "Notices", onClick: branch.handleNoticeDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "priority_high") });\n        let makeselections = react["createElement"](RaisedButton_default.a, { label: "Select dataset", style: { margin: \'3px 6px 0 0\' }, type: "button", onClick: branch.handleSelectionsDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "settings_applications") });\n        let viewtaxonomy = react["createElement"](RaisedButton_default.a, { label: "Dataset tree", style: { margin: \'3px 6px 0 0\' }, type: "button", onClick: () => {\n                let viewpointselection = {\n                    viewpoint: branchDeclaration.viewpoint,\n                    name: this.taxonomychoices[branchDeclaration.viewpoint]\n                };\n                this.props.onCallViewTaxonomy(this.state.viewpointData, viewpointselection, this.applytaxonomyselection);\n            }, labelPosition: "before", icon: react["createElement"]("img", { style: { width: \'24px\' }, src: "./public/icons/org_chart.svg" }) });\n        let search = react["createElement"](RaisedButton_default.a, { label: "Search", style: { margin: \'3px 6px 0 0\' }, type: "button", onClick: this.handleSearch, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5)\' }, className: "material-icons" }, "search") });\n        let shareurl = react["createElement"](RaisedButton_default.a, { type: "button", style: { margin: \'3px 6px 0 0\' }, label: "Share", onClick: this.shareBranch, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5)\' }, className: "material-icons" }, "share") });\n        // assemble the page\n        // if (branchDeclaration.showOptions) {\n        //     // this.animations.controls = this.animations.buttons = animations.zoomInLeft\n        // } else {\n        //     this.animations.controls = this.animations.buttons = animations.zoomOutLeft\n        // }\n        let maxheight = branchDeclaration.showOptions ? \'130px\' : \'0\';\n        let height = branchDeclaration.showOptions ? \'52px\' : \'0\';\n        let maxwidth = branchDeclaration.showOptions ? \'600px\' : \'0\';\n        return react["createElement"](StyleRoot, null, react["createElement"]("div", { style: { marginBottom: \'12px\' } }, " ", react["createElement"]("div", null, react["createElement"]("div", { style: { maxHeight: maxheight, transition: \'max-height .5s\', overflow: \'hidden\' } }, react["createElement"]("div", { style: [this.state.animations.buttons, { marginBottom: \'12px\' }] }, makeselections, viewtaxonomy, search, shareurl, technotes, notices), selectionsdialog, noticesdialog, technotesdialog), react["createElement"]("div", { style: [this.state.animations.controls, {\n                height,\n                maxWidth: maxwidth,\n                overflow: \'hidden\',\n                display: "inline-block",\n                transition: \'height .3s,max-width .3s\'\n            }] }, react["createElement"]("div", { style: { height: \'48px\',\n                whiteSpace: \'nowrap\',\n                display: "inline-block",\n                backgroundColor: "#ebfaf9",\n                border: "1px solid silver",\n                borderRadius: "8px",\n                marginRight: "6px",\n                paddingLeft: "6px"\n            } }, byunitselection, inflationadjustment)), showcontrols)), react["createElement"]("div", { style: { whiteSpace: "nowrap" } }, react["createElement"]("div", { ref: node => {\n                branch.branchScrollBlock = node;\n            }, style: { overflow: "scroll" } }, drilldownportals, react["createElement"]("div", { style: { display: "inline-block", width: "500px", height: "20px" } }))), react["createElement"](Snackbar_default.a, { open: this.state.snackbar.open, message: this.state.snackbar.message, autoHideDuration: 4000, onRequestClose: this.handleSnackbarRequestClose }));\n    }\n}\n/* harmony default export */ var components_explorerbranch = __webpack_exports__["default"] = (explorerbranch_ExplorerBranch);\n\n//# sourceURL=webpack:///./ts/addons/explorer/components/explorerbranch.tsx_+_1_modules?')}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{1016:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ColorBrightness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return hashCode; });\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// utilities.tsx\n/* requires component.lastactiongeneration property to be present\n    component.waitafteraction is optional if explicit wait is desired\n    - the puprose of this utility is to filter out unneeded updates, to protect\n        performance of the explorer page\n    its complexity comes from its use of lastAction: this is set by redux reducer,\n    but redux does not send notification to subscribers on every state change; rather\n    it accumulates changes during js code block, or has a timer. In any case, some lastActions\n    are overwritten, if they are generated close together. (this after reduction in the use of setTimeout, 0ms)\n    To accommodate this, the lastAction reducer is complemented by a lastTargetedAction reducer\n    which accumulates actions by uid, acting as a kind of cache (and avoiding a queue). see reducer.tsx\n\n    The elaborate logic below is meant to accommodate the various conditions that can obtain.\n    It makes assumptions however:\n    1. that individual uid actions will not be overriden, so the code\n    should only generate one instance-specific action at a time.\n    2. It also makes the assumption that the lastAction is complementary to the lastTargetedAction. so when\n    the latter is allowed through, the former will also run. I think that means that one or the other has\n    to operate on the global state only, so that its complement will cause branching to the correct\n    post-action behaviour. Put another way, I think the post-action behaviour must be designed to support\n    all combinations of post-action behaviour.\n\n    Oh, and all this supports a hybrid redux/flux (global/local) state management system. Global is used\n    for (more or less) persitent settings, whereas local is used for transient constructs.\n\n    These assumptions have not been proven! (but so far it's working)\n    TODO: prove these assumptions!\n\n*/\nconst filterActionsForUpdate = (nextProps, component, show = false) => {\n    let componentName = component.constructor.name;\n    let instance, text, targetType;\n    switch (componentName) {\n        case 'explorerbranch_ExplorerBranch':\n        case 'ExplorerBranch':\n            let { budgetBranch } = nextProps;\n            instance = budgetBranch;\n            text = 'BRANCH';\n            targetType = 'branch';\n            break;\n        case 'explorernode_ExplorerNode':\n        case 'ExplorerNode':\n            let { budgetNode } = nextProps;\n            instance = budgetNode;\n            text = 'NODE';\n            targetType = 'node';\n            break;\n        case 'explorercell_ExplorerCell':\n        case 'ExplorerCell':\n            let { budgetCell } = nextProps;\n            instance = budgetCell;\n            text = 'CELL';\n            targetType = 'cell';\n            break;\n        default:\n            throw Error(componentName + ':unexpected component called filterActionsForUpdate');\n    }\n    let { declarationData } = nextProps;\n    let { generation } = declarationData;\n    // 1. explicit call to skip an update\n    if (component.waitafteraction) {\n        component.lastactiongeneration = generation;\n        component.waitafteraction--;\n        if (show) console.log(`should update ${text} return waitafteraction`);\n        return false;\n    }\n    // 2. if the last action is not marked explorer, cancel update\n    let { lastAction } = declarationData;\n    if (generation > component.lastactiongeneration) {\n        if (!lastAction.explorer) {\n            if (show) console.log(`should update ${text} return false for not explorer`, generation, component.lastactiongeneration, lastAction);\n            component.lastactiongeneration = generation;\n            return false;\n        }\n    }\n    // 3. look for targeted action (may have been bypassed with redux race condition)\n    let { lastTargetedAction } = nextProps.declarationData;\n    let uid = instance.uid;\n    let lastTargetedTypeAction = lastTargetedAction[uid];\n    if (lastTargetedTypeAction && component.lastactiongeneration < lastTargetedTypeAction.generation) {\n        if (show) console.log(`returning from targeted ${text} should component update`, instance.uid, true, component.lastactiongeneration, generation, lastAction, lastTargetedAction, lastTargetedTypeAction);\n        component.lastactiongeneration = generation;\n        return true;\n    }\n    // 4. look for general action\n    if (!lastAction[targetType + 'uid'] && generation > component.lastactiongeneration) {\n        if (show) console.log(`returning TRUE for lastAction without ${text} reference`, instance.uid, component.lastactiongeneration, generation, lastAction);\n        component.lastactiongeneration = generation;\n        return true;\n    }\n    // 5. filter out legitimate mismatched targets\n    let filtered = Object.keys(lastTargetedAction).filter(item => {\n        let itemaction = lastTargetedAction[item];\n        if (itemaction[targetType] && itemaction.generation > component.lastactiongeneration) {\n            return true;\n        }\n    });\n    if (filtered.length > 0) {\n        component.lastactiongeneration = generation;\n        if (show) console.log(`returning FALSE viable ${text} action for another ${text}`, instance.uid);\n        return false;\n    }\n    // 6. explorer actions not targeted let through, but sets lastactiongeneration\n    if (generation > component.lastactiongeneration) {\n        if (show) console.log(`returning default true for ${text} action`, lastAction, generation, component.lastactiongeneration);\n        component.lastactiongeneration = generation;\n        return true;\n    }\n    // 7. default non-actions (local setState) let through\n    if (show) console.log(`returning default true for ${text} NON-ACTION`);\n    return true;\n};\n// from https://css-tricks.com/snippets/javascript/lighten-darken-color/\n// amount is 0 - 256 (probably -- haven't tested upper limit; negative makes darker)\nlet ColorBrightness = (col, amt) => {\n    var usePound = false;\n    if (col[0] == \"#\") {\n        col = col.slice(1);\n        usePound = true;\n    }\n    var num = parseInt(col, 16);\n    var r = (num >> 16) + amt;\n    if (r > 255) r = 255;else if (r < 0) r = 0;\n    var b = (num >> 8 & 0x00FF) + amt;\n    if (b > 255) b = 255;else if (b < 0) b = 0;\n    var g = (num & 0x0000FF) + amt;\n    if (g > 255) g = 255;else if (g < 0) g = 0;\n    return (usePound ? \"#\" : \"\") + (g | b << 8 | r << 16).toString(16);\n};\n// from http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\nconst hashCode = string => {\n    let hash = 0;\n    if (string.length == 0) return hash;\n    for (let i = 0; i < string.length; i++) {\n        let char = string.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\nlet Utilities = {\n    hashCode: hashCode,\n    filterActionsForUpdate,\n    ColorBrightness\n};\n/* harmony default export */ __webpack_exports__[\"b\"] = (Utilities);\n\n//# sourceURL=webpack:///./ts/addons/explorer/modules/utilities.tsx?")},1021:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./forked_modules/react-google-charts/DEFAULT_CHART_COLORS.js\nvar DEFAULT_CHART_COLORS = __webpack_require__(1148);\nvar DEFAULT_CHART_COLORS_default = /*#__PURE__*/__webpack_require__.n(DEFAULT_CHART_COLORS);\n\n// EXTERNAL MODULE: ./node_modules/scriptjs/dist/script.js\nvar script = __webpack_require__(1147);\nvar script_default = /*#__PURE__*/__webpack_require__.n(script);\n\n// CONCATENATED MODULE: ./forked_modules/react-google-charts/GoogleChartLoader.js\n//GoogleChartLoader Singleton\n\n// Based on http://blog.arkency.com/2014/09/react-dot-js-and-google-charts/\n// import Promise from 'bluebird';\n\nconst debug = __webpack_require__(1146)('react-google-charts:GoogleChartLoader');\n\nconst googleChartLoader = {\n\n  isLoaded : false,\n  isLoading: false,\n  initPromise: {},\n  init(packages, version) {\n    debug('init', packages, version);\n\n    if (this.isLoading || this.isLoaded) {\n      return this.initPromise;\n    }\n    this.isLoading = true;\n    this.initPromise =  new Promise((resolve, reject)=> {\n      if(typeof window !== 'undefined') {\n        script_default()(\"https://www.gstatic.com/charts/loader.js\", () => {\n\n          google.charts.load(version || 'current', {packages: packages || ['corechart']});\n          google.charts.setOnLoadCallback(() => {\n            debug('Chart Loaded');\n            this.isLoaded = true;\n            this.isLoading = false;\n            resolve();\n          });\n        });\n      }\n      else {\n        resolve();\n      }\n    });\n    return this.initPromise;\n  }\n}\n\n/* harmony default export */ var GoogleChartLoader = (googleChartLoader);\n\n// CONCATENATED MODULE: ./forked_modules/react-google-charts/Chart.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chart\", function() { return Chart_Chart; });\n\n// import Promise from 'bluebird';\n\n// const debug = require('debug')('react-google-charts:Chart');\n\n\n\nlet uniqueID = 0;\n\nconst generateUniqueID = () => {\n  uniqueID++;\n  return \"reactgooglegraph-\" + uniqueID;\n}\n\nconst googleErrorHandler = (id, message) => {\n  console.error(\"Google Charts encountered an error : \")\n  console.error(`Error ID : ${id}`);\n  console.error(`Error MESSAGE : ${message}`);\n}\n\nclass Chart_Chart extends react_default.a.Component {\n  constructor(props) {\n    if (false) {}\n    // debug('constructor', props);\n    super(props);\n    this.state = {graphID: props.graph_id || generateUniqueID()};\n    this.chart = null;\n    this.wrapper = null;\n    this.hidden_columns = {};\n    this.dataTable = [];\n  }\n  componentDidMount(){\n    // debug('componentDidMount');\n    GoogleChartLoader.init(this.props.chartPackages, this.props.chartVersion).then((asd)=>{\n      // console.log('drawchart from did mount')\n      this.drawChart()\n    });\n  }\n  componentWillUnmount() {\n      try {\n          google.visualization.events.removeAllListeners(this.wrapper);\n      }\n      catch(err) {\n        console.error(\"Error removing events, error : \", err);\n      }\n  }\n  componentDidUpdate(){\n    // debug('componentDidUpdate');\n    if (GoogleChartLoader.isLoading){\n      GoogleChartLoader.initPromise.then(()=>{\n        // console.log('calling drawchart from did update PROMISE')\n        this.drawChart.bind(this)();\n\n      })\n\t\t}\n    else if (GoogleChartLoader.isLoaded) {\n\n      // console.log('calling drawchart from did update ISLOADED')\n      this.drawChart.bind(this)();\n\n    } else {\n        // console.log('drawchart from did update/loading')\n      // console.log('NOT calling drawChart from componentDidUpdate')\n    }\n  }\n  buildDataTableFromProps() {\n    // debug('buildDataTableFromProps', this.props);\n    if (this.props.diffdata) {\n\n        let diffdata = this.props.diffdata\n        let oldData = google.visualization.arrayToDataTable(diffdata.old)\n        let newData = google.visualization.arrayToDataTable(diffdata.new)\n        // must take computeDiff from prototypes since not available with charts early in process\n        let computeDiff = google.visualization[this.props.chartType].prototype.computeDiff\n        let chartDiff = computeDiff(oldData,newData)\n\n        return chartDiff\n\n    }\n\n    if (this.props.data === null && this.props.rows.length === 0){\n      throw new Error(\"Can't build DataTable from rows and columns: rows array in props is empty\");\n    }\n    else if (this.props.data === null && this.props.columns.length === 0) {\n      throw new Error(\"Can't build DataTable from rows and columns: columns array in props is empty\");\n    }\n    if (this.props.data !== null) {\n      try {\n          this.wrapper.setDataTable(this.props.data);\n          let dataTable = this.wrapper.getDataTable();\n          return dataTable;\n      }\n      catch(err) {\n        console.log('Failed to set DataTable from data props ! ', err);\n        throw new Error('Failed to set DataTable from data props ! ', err);\n      }\n    }\n\n    let dataTable = new google.visualization.DataTable();\n    this.props.columns.forEach((column)=>{\n      dataTable.addColumn(column);\n    });\n    dataTable.addRows(this.props.rows);\n    return dataTable;\n  }\n  updateDataTable() {\n    // debug(\"updateDataTable\");\n    google.visualization.errors.removeAll(document.getElementById(this.wrapper.getContainerId()));\n    this.dataTable.removeRows(0, this.dataTable.getNumberOfRows());\n    this.dataTable.removeColumns(0, this.dataTable.getNumberOfColumns());\n    this.dataTable = this.buildDataTableFromProps.bind(this)();\n    return this.dataTable;\n  }\n  //DEPRECATED AND NOT USED\n  getDataTableFromProps() {\n    // debug(\"getDataTableFromProps\");\n    return this.props.data !== null ? this.props.data : this.buildDataTableFromProps.bind(this)();\n  }\n  drawChart() {\n    // console.log(\"drawChart\", this);\n    if (!this.wrapper) {\n      let chartConfig = {\n        chartType: this.props.chartType,\n        options: this.props.options,\n        containerId: this.state.graphID\n      };\n      this.wrapper = new google.visualization.ChartWrapper(chartConfig);\n      // console.log('newly created wrapper', this.wrapper)\n      google.visualization.events.addOneTimeListener(this.wrapper, 'ready', ()=>{\n        this.chart = this.wrapper.getChart();\n        // console.log('ready after create',this.chart)\n        this.listenToChartEvents.bind(this)();\n        this.addChartActions.bind(this)();\n      });\n      this.dataTable = this.buildDataTableFromProps.bind(this)();\n      this.wrapper.setDataTable(this.dataTable)\n      // this.wrapper.draw();\n    }\n    else {\n      if (this.wrapper.getChartType() != this.props.chartType) {\n        google.visualization.events.removeAllListeners(this.wrapper)\n        this.wrapper.setChartType(this.props.chartType)\n        // console.log('newChartType BEFORE ready',this.wrapper.getChartType(),this.wrapper.getChart())\n        var self = this\n        google.visualization.events.addOneTimeListener(this.wrapper, 'ready', () => {\n          this.chart = this.wrapper.getChart();\n          this.listenToChartEvents.bind(this)();\n          this.addChartActions.bind(this)();\n        });\n        self.chart = self.wrapper.getChart();\n        self.updateDataTable.bind(self)();\n        self.wrapper.setDataTable(self.dataTable);\n        self.wrapper.setOptions(self.props.options)\n        // self.wrapper.draw();\n      } else {\n        this.updateDataTable.bind(this)();\n        this.wrapper.setDataTable(this.dataTable);\n        this.wrapper.setOptions(this.props.options)\n        // this.wrapper.draw();\n      }\n      // issue: this draw clears selection\n    }\n    this.wrapper.draw();\n  }\n\n  addChartActions() {\n    // debug('addChartActions', this.props.chartActions);\n    if (this.props.chartActions === null) {\n      return;\n    }\n    this.chart.setAction({\n      id: this.props.chartActions.id,\n      text: this.props.chartActions.text,\n      action: this.props.chartActions.action.bind(this, this.chart)\n    })\n\n  }\n  listenToChartEvents() {\n    // debug('listenToChartEvents', this.props.legend_toggle, this.props.chartEvents);\n    // console.log('listenToChartEvents')\n    if (this.props.legend_toggle) {\n      google.visualization.events.addListener(this.wrapper, 'select', this.onSelectToggle.bind(this));\n    }\n    this.props.chartEvents.forEach((chartEvent)=>{\n      if (chartEvent.eventName === 'ready') {\n        // console.log('ready event')\n        chartEvent.callback(this);\n      }\n      else {\n        ((chartEvent)=>{\n            google.visualization.events.addListener(this.chart, chartEvent.eventName, (e)=>{\n              // console.log('chart event', this.chart)\n              chartEvent.callback(this, e);\n            });\n        })(chartEvent);\n      }\n      });\n  }\n  onSelectToggle() {\n    // debug('onSelectToggle');\n    let selection = this.chart.getSelection();\n    if (selection.length > 0) {\n      if (selection[0].row == null) {\n        let column = selection[0].column;\n        this.togglePoints.bind(this)(column);\n      }\n    }\n  }\n  getColumnColor(columnIndex) {\n    if (this.props.options.colors) {\n      if (this.props.options.colors[columnIndex]) {\n        return this.props.options.colors[columnIndex];\n      }\n    }\n    else {\n      if (typeof DEFAULT_CHART_COLORS_default.a[columnIndex] !== undefined) {\n        return DEFAULT_CHART_COLORS_default.a[columnIndex];\n      }\n      else {\n        return DEFAULT_CHART_COLORS_default.a[0];\n      }\n    }\n  }\n\n  buildColumnFromSourceData(columnIndex) {\n    // debug('buildColumnFromSourceData', columnIndex);\n    return {\n      label: this.dataTable.getColumnLabel(columnIndex),\n      type: this.dataTable.getColumnType(columnIndex),\n      sourceColumn: columnIndex\n    };\n  }\n\n  buildEmptyColumnFromSourceData(columnIndex) {\n    // debug('buildEmptyColumnFromSourceData', columnIndex);\n    return {\n      label: this.dataTable.getColumnLabel(columnIndex),\n      type: this.dataTable.getColumnType(columnIndex),\n      calc: function () {\n        return null;\n      }\n    };\n  }\n  addEmptyColumnTo(columns, columnIndex) {\n    // debug('addEmptyColumnTo', columns, columnIndex);\n    let emptyColumn =  this.buildEmptyColumnFromSourceData(columnIndex);\n    columns.push(emptyColumn);\n  }\n\n  hideColumn(colors, columnIndex) {\n    // debug('hideColumn', colors, columnIndex);\n    if (!this.isHidden(columnIndex)) {\n      this.hidden_columns[columnIndex] = { color : this.getColumnColor(columnIndex-1) };\n    }\n    colors.push('#CCCCCC');\n  }\n  addSourceColumnTo(columns, columnIndex) {\n    // debug('addSourceColumnTo', columns, columnIndex);\n    let sourceColumn = this.buildColumnFromSourceData(columnIndex);\n    columns.push(sourceColumn);\n  }\n  isHidden(columnIndex) {\n    return this.hidden_columns[columnIndex] !== undefined\n  }\n  restoreColorTo(colors, columnIndex) {\n    // debug('restoreColorTo', colors, columnIndex);\n    // debug('hidden_columns',this.hidden_columns);\n    let previousColor;\n    if (this.isHidden(columnIndex)) {\n      previousColor = this.hidden_columns[columnIndex].color;\n      delete this.hidden_columns[columnIndex];\n    }\n    else {\n      previousColor = this.getColumnColor(columnIndex-1)\n    }\n    if (columnIndex !== 0) {\n\t\t\tcolors.push(previousColor);\n\t\t}\n  }\n\n  togglePoints(column) {\n    // debug('togglePoints', column);\n    let view = new google.visualization.DataView(this.wrapper.getDataTable());\n    let columnCount = view.getNumberOfColumns();\n    let colors = [];\n    let columns = [];\n    for (var i = 0; i < columnCount; i++) {\n      // If user clicked on legend\n      if (i === 0) {\n        this.addSourceColumnTo.bind(this)(columns, i);\n      }\n      else if (i === column ) {\n        if (this.isHidden(i)) {\n          this.addSourceColumnTo.bind(this)(columns, i);\n          this.restoreColorTo.bind(this)(colors, i);\n        }\n        else {\n          this.addEmptyColumnTo.bind(this)(columns,i);\n          this.hideColumn.bind(this)(colors, i);\n        }\n      }\n      else {\n        if (this.isHidden(i)) {\n          this.addEmptyColumnTo.bind(this)(columns,i);\n          this.hideColumn.bind(this)(colors, i);\n        }\n        else {\n          this.addSourceColumnTo.bind(this)(columns, i);\n          this.restoreColorTo.bind(this)(colors, i);\n        }\n      }\n    }\n    view.setColumns(columns);\n    this.props.options.colors = colors;\n    this.chart.draw(view, this.props.options);\n  }\n\n  render() { \n    // debug('render', this.props, this.state);\n    let height = this.props.height || this.props.options.height\n    let width = this.props.width || this.props.options.width\n\n    let divStyle= {height, width: width}\n    return (\n       react_default.a.createElement('div', {id:this.state.graphID, style:divStyle},\"Rendering Chart\")\n      )\n  }\n}\n\nChart_Chart.defaultProps = {\n  chartType : 'LineChart',\n  rows: [],\n  columns: [],\n  options: {\n    chart: {\n      title: 'Chart Title',\n      subtitle: 'Subtitle'\n    },\n    hAxis: {title: 'X Label'},\n    vAxis: {title: 'Y Label'},\n    width: '400px',\n    height: '300px'\n  },\n  width: '400px',\n  height: '300px',\n  chartEvents : [],\n  chartActions : null,\n  data: null,\n  onSelect: null,\n  legend_toggle: false\n}\n\n\n\n\n//# sourceURL=webpack:///./forked_modules/react-google-charts/Chart.js_+_1_modules?")},1022:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/databaseapi/setviewpointdata.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// setviewpointamounts.tsx\n// starts with hash of components, \n// recursively descends to BASELINE baselineItems, then leaves \n// summaries by year, and CommonDimension by year on ascent\nconst setViewpointData = parms => {\n    // let viewpointname = parms.viewpointname,\n    let { datasetName, viewpointDataTemplate, datasetData, lookups, inflationAdjusted } = parms;\n    let datasetMeta = datasetData.MetaData;\n    let baselineLookupIndex = datasetMeta.Dimensions[0].toLowerCase(); // use for system lookups\n    let commonDimensionLookupIndex = datasetMeta.CommonDimension;\n    if (commonDimensionLookupIndex) {\n        commonDimensionLookupIndex = commonDimensionLookupIndex.toLowerCase();\n    }\n    let baselinelookups = lookups[baselineLookupIndex];\n    let commonDimensionLookups = commonDimensionLookupIndex ? lookups[commonDimensionLookupIndex] : null;\n    let taxonomylookups = viewpointDataTemplate.Meta.Lookups.Taxonomy;\n    let lookupset = {\n        baselinelookups,\n        commonDimensionLookups,\n        taxonomylookups\n    };\n    let baselineItems = datasetData.Data;\n    let isInflationAdjustable = !!datasetMeta.InflationAdjustable;\n    if (isInflationAdjustable) {\n        if (inflationAdjusted) {\n            baselineItems = baselineItems.Adjusted;\n        } else {\n            baselineItems = baselineItems.Nominal;\n        }\n    }\n    baselineItems = JSON.parse(JSON.stringify(baselineItems));\n    // set years, and CommonDimension by years\n    try {\n        let node = viewpointDataTemplate;\n        let sorted = getIndexSortedComponentItems(node.Components, lookupset);\n        node.SortedComponents = sorted;\n        // initiates recursion\n        let nodeSummaries = getNodeSummaries(node, baselineItems, lookupset);\n        node.ComponentsDrilldown = nodeSummaries.Drilldown;\n        setNodeSummaries(node, nodeSummaries, lookupset);\n    } catch (e) {\n        console.log('error in setComponentAggregates', e);\n    }\n    // record state\n    viewpointDataTemplate.Meta.currentDataset = datasetName;\n    viewpointDataTemplate.Meta.isInflationAdjusted = inflationAdjusted;\n};\n// this is recursive, with absence of Components property at leaf\n// special treatment for 'BASELINE' baselineItems -- fetches data from data series baselineItems\n// sets years and CommonDimension for each node\nconst getNodeSummaries = (node, baselineItems, lookups) => {\n    let components = node.Components;\n    // cumulate summaries for this level\n    let aggregator = {\n        // years: {},\n        // CommonDimension: {},\n    };\n    let count = 0;\n    let subcomponentscount = 0;\n    let commondimensioncount = 0;\n    // for every component at this level\n    for (let componentname in components) {\n        count++;\n        // isolate the node...\n        let node = components[componentname];\n        let nodeSummaries = null;\n        // remove any previous aggregations...\n        if (node.years) {\n            delete node.years;\n        }\n        if (node.CommonDimension) {\n            delete node.CommonDimension;\n            delete node.SortedCommonDimension;\n        }\n        // for non-baseline baselineItems, recurse to collect aggregations\n        if (!node.Baseline) {\n            // if no components found, loop\n            if (node.Components) {\n                subcomponentscount++;\n                let sorted = getIndexSortedComponentItems(node.Components, lookups);\n                node.SortedComponents = sorted;\n                // get child node summaries recursively\n                nodeSummaries = getNodeSummaries(node, baselineItems, lookups);\n                if (nodeSummaries.CommonDimension) {\n                    commondimensioncount++;\n                }\n                node.ComponentsDrilldown = nodeSummaries.Drilldown;\n                setNodeSummaries(node, nodeSummaries, lookups);\n            }\n            // for baseline baselineItems, fetch the baseline amounts from the dataseries itemlist\n        } else {\n            // fetch the data from the dataseries itemlist\n            let importitem = baselineItems[componentname];\n            if (!importitem) {\n                console.log('failed to find dataset item to match viewpoint baseline:', componentname);\n                nodeSummaries = null;\n            } else {\n                nodeSummaries = {\n                    years: importitem.years,\n                    CommonDimension: importitem.CommonDimension\n                };\n            }\n            // capture data for chart-making\n            if (node.Components) {\n                delete node.SortedComponents;\n                delete node.Components;\n            }\n            if (importitem) {\n                // there is data; transfer it to the viewpoint node\n                if (importitem.years) {\n                    node.years = importitem.years;\n                }\n                if (importitem.CommonDimension) {\n                    commondimensioncount++;\n                    node.CommonDimension = importitem.CommonDimension;\n                }\n                if (importitem.SortedCommonDimension) {\n                    node.SortedCommonDimension = importitem.SortedCommonDimension;\n                }\n                if (importitem.Components) {\n                    subcomponentscount++;\n                    node.Components = importitem.Components;\n                }\n                if (importitem.SortedComponents) {\n                    node.SortedComponents = importitem.SortedComponents;\n                }\n                if (importitem.ComponentsDrilldown) {\n                    node.ComponentsDrilldown = importitem.ComponentsDrilldown;\n                }\n                if (importitem.CommonDimensionDrilldown) {\n                    node.CommonDimensionDrilldown = importitem.CommonDimensionDrilldown;\n                }\n            }\n            if (node.Components && !node.SortedComponents) {\n                let sorted = getNameSortedComponentItems(node.Components, lookups);\n                node.SortedComponents = sorted;\n            }\n            if (node.CommonDimension && !node.SortedCommonDimension) {\n                let sorted = getNameSortedComponentItems(node.CommonDimension, lookups);\n                node.SortedCommonDimension = sorted;\n            }\n        }\n        // aggregate the collected summaries for the caller\n        if (nodeSummaries) {\n            incrementAggregator(aggregator, nodeSummaries);\n        }\n    }\n    let drilldown;\n    if (subcomponentscount == 0 && commondimensioncount == 0) {\n        drilldown = 'None';\n    } else if (subcomponentscount == count || commondimensioncount == count) {\n        drilldown = 'All';\n    } else {\n        drilldown = 'Some';\n    }\n    aggregator.Drilldown = drilldown;\n    return aggregator;\n};\nconst setNodeSummaries = (node, nodeSummaries, lookups) => {\n    // capture data for chart-making\n    if (nodeSummaries.years) {\n        node.years = nodeSummaries.years;\n    }\n    if (nodeSummaries.CommonDimension) {\n        node.CommonDimension = nodeSummaries.CommonDimension;\n        if (node.CommonDimension) {\n            let sorted = getNameSortedComponentItems(node.CommonDimension, lookups);\n            node.SortedCommonDimension = sorted;\n        }\n    }\n};\n// -----------------------[ RETURN SORTED COMPONENT LIST ]------------------------\nconst getIndexSortedComponentItems = (components, lookups) => {\n    let sorted = [];\n    let taxonomylookups = lookups.taxonomylookups;\n    for (let componentcode in components) {\n        let component = components[componentcode];\n        let baseline = !!component.Baseline; // config = component.NamingConfigRef\n        let name = baseline // (config == 'BASELINE')\n        ? lookups.baselinelookups[componentcode] : taxonomylookups[componentcode];\n        let item = {\n            Code: componentcode,\n            Index: component.Index,\n            Name: name || componentcode // 'unknown name'\n        };\n        component.Name = name || componentcode; // 'unknown name'\n        sorted.push(item);\n    }\n    sorted.sort((a, b) => {\n        let value;\n        if (a.Index < b.Index) value = -1;else if (a.Index > b.Index) value = 1;else value = 0;\n        return value;\n    });\n    return sorted;\n};\nconst getNameSortedComponentItems = (components, lookups) => {\n    let sorted = [];\n    let complookups = lookups.commonDimensionLookups;\n    for (let componentname in components) {\n        let component = components[componentname];\n        // let config = component.NamingConfigRef\n        let name = complookups[componentname];\n        let item = {\n            Code: componentname,\n            Name: name || 'unknown name'\n        };\n        component.Name = name || 'unknown name';\n        sorted.push(item);\n    }\n    sorted.sort((a, b) => {\n        let value;\n        if (a.Name < b.Name) value = -1;else if (a.Name > b.Name) value = 1;else value = 0;\n        return value;\n    });\n    return sorted;\n};\n// -----------------------[ SUMMARIZE COMPONENT DATA ]-----------------------\n// summarize the componentSummaries into the (parent) aggregator\nconst incrementAggregator = (aggregator, componentSummaries) => {\n    // if years have been collected, add them to the total\n    if (componentSummaries.years) {\n        let years = componentSummaries.years;\n        // for each year...\n        for (let yearname in years) {\n            let yearvalue = years[yearname];\n            if (!aggregator.years) {\n                aggregator.years = {};\n            }\n            // accumulate the value...\n            if (aggregator.years[yearname]) aggregator.years[yearname] += yearvalue;else aggregator.years[yearname] = yearvalue;\n        }\n    }\n    // if CommonDimension have been collected, add them to the totals\n    if (componentSummaries.CommonDimension) {\n        let CommonDimension = componentSummaries.CommonDimension;\n        if (!aggregator.CommonDimension) {\n            aggregator.CommonDimension = {};\n        }\n        // for each aggreate...\n        for (let commonDimensionName in CommonDimension) {\n            let commonDimension = CommonDimension[commonDimensionName];\n            // for each category year...\n            // collect year values for the CommonDimension if they exist\n            if (commonDimension.years) {\n                let years = commonDimension.years;\n                for (let yearname in years) {\n                    // accumulate the year value...\n                    let yearvalue = years[yearname];\n                    let cumulatingCommonDimension = aggregator.CommonDimension[commonDimensionName] || { years: {} };\n                    if (cumulatingCommonDimension.years[yearname]) {\n                        cumulatingCommonDimension.years[yearname] += yearvalue;\n                    } else {\n                        cumulatingCommonDimension.years[yearname] = yearvalue;\n                    }\n                    // re-assemble\n                    aggregator.CommonDimension[commonDimensionName] = cumulatingCommonDimension;\n                }\n            }\n        }\n    }\n};\n/* harmony default export */ var setviewpointdata = (setViewpointData);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/databaseapi.tsx\n// databaseapi.tsx\n// TEMPORARY DATA SOURCES\n// data sources\n// deepclone = JSON.parse(JSON.stringify(obj)) // but this destroys dates, undefined, and functions\n/*\n    TODO:\n        add spinner for progress\n        add cache for all fetch elements\n*/\n\n// -----------------------[ collect the data ]------------------------------\nconst delay = ms => // for testing!\nnew Promise(resolve => setTimeout(resolve, ms));\n// =====================================[ CLASS DECLARATION ]==================================\nclass databaseapi_Database {\n    constructor() {\n        this.dbroot = '/db/repositories/';\n        this.datasetsubpath = 'json/';\n        this.lookupssubpath = 'lookups/';\n    }\n    getProrataData(parms) {\n        let { repository, prorataseries } = parms;\n        let promise = new Promise((resolve, error) => {\n            let spec = this.dbroot + repository.toLowerCase() + '/dataseries/' + prorataseries.toLowerCase() + '.json';\n            // console.log('fetching', spec)\n            fetch(spec).then(prorataseries => {\n                return prorataseries.json();\n            }).then(prorataseries => {\n                // console.log('prorataseries returned', prorataseries)\n                resolve(prorataseries);\n            }).catch(reason => {\n                console.log('get prorataseries error', reason);\n                error(reason);\n            });\n            // resolve(series)\n        });\n        return promise;\n    }\n    // getViewpointData returns a promise.\n    getViewpointData(parms) {\n        // console.log('getViewpointData parms',parms)\n        this.viewpointDataParms = parms;\n        let { viewpointName, versionName, datasetName, inflationAdjusted } = parms;\n        let viewpointDataTemplatePromise = this.getViewpointTemplatePromise(viewpointName),\n            datasetDataPromise = this.getDatasetPromise(versionName, datasetName),\n            lookupsPromise = this.getLookupsPromise(versionName),\n            datasetConfigPromise = this.getDatasetConfigPromise(versionName, datasetName);\n        let promise = new Promise((resolve, error) => {\n            Promise.all([viewpointDataTemplatePromise, datasetDataPromise, lookupsPromise, datasetConfigPromise]).then(values => {\n                let viewpointDataTemplate;\n                let datasetData;\n                let lookups;\n                let datasetConfig;\n                // calculate all compatible data together, cached\n                [viewpointDataTemplate, datasetData, lookups, datasetConfig] = values;\n                viewpointDataTemplate.Meta.datasetConfig = datasetConfig; // TODO try to avoid this\n                let setparms = {\n                    datasetName,\n                    inflationAdjusted,\n                    viewpointDataTemplate,\n                    datasetData,\n                    lookups\n                };\n                this.calculateViewpointData(setparms);\n                viewpointDataTemplate = setparms.viewpointDataTemplate;\n                resolve(viewpointDataTemplate);\n            }).catch(reason => {\n                console.log(reason);\n                // error(reason)\n            });\n        });\n        return promise;\n    }\n    // TODO: use local cache\n    calculateViewpointData(parms) {\n        setviewpointdata(parms);\n    }\n    // -------------------------[ promises to collect data ]---------------------\n    getViewpointTemplatePromise(viewpoint) {\n        let promise = new Promise((resolve, error) => {\n            let path = this.dbroot + this.viewpointDataParms.repository.toLowerCase() + '/viewpoints/' + viewpoint.toLowerCase() + '.json';\n            fetch(path).then(viewpoint => {\n                return viewpoint.json();\n            }).then(viewpointdata => {\n                resolve(viewpointdata);\n            }).catch(reason => {\n                console.log('get viewpoint template error', reason);\n                error(reason);\n            });\n        });\n        return promise;\n    }\n    // internal promise for dataset config\n    // TODO: get this from meta subdir\n    getDatasetConfigPromise(versionName, datasetName) {\n        let datasetpromise = this.getDatasetPromise(versionName, datasetName);\n        let promise = new Promise(resolve => {\n            datasetpromise.then(datasetdata => {\n                let metaData = datasetdata.MetaData;\n                let { Headers, Notes, Allocations, Messages } = datasetdata;\n                let Sources = {\n                    Headers,\n                    Notes,\n                    Allocations,\n                    Messages\n                };\n                let { DatasetName, YearsRange, DatasetTitle, Dataseries, DimensionNames, CellTitles, Units, UnitsAlias, UnitRatio, CommonDimension, InflationAdjustable, InflationReferenceYear } = metaData;\n                let config = {\n                    DatasetName,\n                    YearsRange,\n                    DatasetTitle,\n                    Dataseries,\n                    DimensionNames,\n                    CellTitles,\n                    Units,\n                    UnitsAlias,\n                    UnitRatio,\n                    CommonDimension,\n                    InflationAdjustable,\n                    InflationReferenceYear,\n                    Sources\n                };\n                resolve(config);\n            });\n        });\n        return promise;\n    }\n    getDatasetPromise(versionName, datasetName) {\n        let promise = new Promise((resolve, error) => {\n            let path = this.dbroot + this.viewpointDataParms.repository.toLowerCase() + '/datasets/' + versionName.toLowerCase() + '/' + this.datasetsubpath + datasetName.toLowerCase() + '.json';\n            fetch(path).then(dataset => {\n                return dataset.json();\n            }).then(dataset => {\n                resolve(dataset);\n            }).catch(reason => {\n                console.log('get dataset error', reason);\n                // error(reason)\n            });\n        });\n        return promise;\n    }\n    getLookupsPromise(version = undefined) {\n        let promise = new Promise((resolve, error) => {\n            let path = this.dbroot + this.viewpointDataParms.repository.toLowerCase() + '/datasets/' + version.toLowerCase() + '/' + this.lookupssubpath + 'lookups.json';\n            fetch(path).then(lookups => {\n                return lookups.json();\n            }).then(lookups => {\n                resolve(lookups);\n            }).catch(reason => {\n                console.log('get lookups error', reason);\n                // error(reason)\n            });\n        });\n        return promise;\n    }\n}\nconst database = new databaseapi_Database();\n/* harmony default export */ var databaseapi = (database);\n// EXTERNAL MODULE: ./ts/addons/explorer/modules/getbudgetnode.tsx\nvar getbudgetnode = __webpack_require__(1028);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/constants.tsx\nvar constants = __webpack_require__(149);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/modules/utilities.tsx\nvar utilities = __webpack_require__(1016);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/cell.class.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// budgetcell.tsx\n/*\n\nTitle components:\n- Node meta category\n- Node cagegory\n- YearsRange\n- Total (for one year charts)\n- Inflation adjustment\n\nVertical axis:\n- Metric (qualifier)\n\nHorizontal access:\n- Dimension\n\n*/\n\n\n\nvar format = __webpack_require__(1027);\nclass cell_class_BudgetCell {\n    constructor(specs) {\n        this.chartSelection = null; // interpreted by explorer; the logical row of the selection (per Sorted... lists)\n        // ========================[ METHODS ]==========================\n        // reset the visible element selection (if any) on the current chart\n        // google charts clear the selection on blur, must be re-instated after each\n        // operation\n        // called after animation, on mount, and after update\n        this.refreshSelection = () => {\n            let budgetCell = this;\n            // console.log('budgetCell.chartSelection',budgetCell.chartSelection, budgetCell)\n            if (budgetCell.chartSelection !== null) {\n                if (budgetCell.chart && budgetCell.chart.getSelection().length == 0) {\n                    let selectionObj = { row: null, column: null };\n                    let chartSelection = [selectionObj];\n                    // console.log('chartSelection',chartSelection)\n                    switch (budgetCell.googleChartType) {\n                        case \"PieChart\":\n                            selectionObj.row = budgetCell.chartSelection;\n                            break;\n                        case \"ColumnChart\":\n                            if (budgetCell.explorerChartCode == \"DiffColumnChart\") {\n                                selectionObj.row = Math.round(budgetCell.chartSelection * 2 + 1);\n                                selectionObj.column = 2;\n                                // console.log('set diffcolumnchart selection',selectionObj)\n                            } else {\n                                selectionObj.row = budgetCell.chartSelection;\n                                selectionObj.column = 1; // ?\n                            }\n                            break;\n                        case \"LineChart\":\n                        case \"AreaChart\":\n                            selectionObj.column = budgetCell.chartSelection + 1;\n                            break;\n                        default:\n                            console.log('ERROR: default invoked in refreshSelection');\n                            break;\n                    }\n                    budgetCell.chart.setSelection(chartSelection);\n                }\n            }\n        };\n        this.switchChartCode = () => {\n            this.setChartParms();\n        };\n        this.switchYearScope = () => {\n            this.setChartParms();\n        };\n        // ----------------------[ setChartParms ]-------------------------\n        this.prorataControls = {\n            prorataindex: null,\n            yearsselector: null,\n            isprorata: null,\n            proratastring: null\n        };\n        // creates formal input parameters for google charts, through Chart Component\n        // dataset is a data tree fetched from database\n        // dataseries is a list of data rows attached to a node\n        this.setChartParms = () => {\n            let budgetCell = this;\n            // --------------[ Unpack data bundles ]-------------\n            let { viewpointNamingConfigs, datasetConfig, isInflationAdjusted, prorata } = budgetCell.viewpointConfigPack;\n            let { treeNodeData, yearsRange } = budgetCell.nodeDataPack;\n            // ---------------------[ get data node components ]------------------\n            // collect chart node and its components as data sources for the graph\n            if (!treeNodeData) {\n                console.error('System Error: node not found in setChartParms', budgetCell);\n                throw Error('node not found');\n            }\n            let { prorataControls } = budgetCell;\n            prorataControls.prorataindex = prorata;\n            if (prorata == 'OFF') {\n                prorataControls.isprorata = false;\n                prorataControls.yearsselector = 'years';\n                prorataControls.proratastring = null;\n            } else {\n                prorataControls.isprorata = true;\n                prorataControls.yearsselector = 'calcyears';\n                let thestring;\n                switch (prorata) {\n                    case \"PERPERSON\":\n                        thestring = 'per resident';\n                        break;\n                    case \"PER100000PERSONS\":\n                        thestring = 'per 100,000 people';\n                        break;\n                    case \"PERHOUSEHOLD\":\n                        thestring = 'per household';\n                        break;\n                    case \"PER40000HOUSEHOLDS\":\n                        thestring = 'per 40,000 households';\n                        break;\n                    case \"PERWARD\":\n                        thestring = 'per ward (average)';\n                        break;\n                    case \"PERNEIGHBOURHOOD\":\n                        thestring = 'per neighbourhood (average)';\n                        break;\n                    default:\n                        console.error('unknown prorataindex in _doProRataCalc', prorata);\n                        return;\n                }\n                prorataControls.proratastring = thestring;\n            }\n            // ====================[ COLLECT CHART PARMS ]======================\n            // ------------------\n            // 1. chart type:\n            // ------------------\n            let chartType = budgetCell.googleChartType;\n            // ------------------\n            // 2. chart options:\n            // ------------------\n            let options = budgetCell._chartParmsOptions(treeNodeData, viewpointNamingConfigs, datasetConfig, yearsRange);\n            // ------------------\n            // 3. chart events:\n            // ------------------\n            let events = budgetCell._chartParmsEvents();\n            // ------------------\n            // 4. chart columns:\n            // ------------------\n            let columns = null; // = budgetCell._chartParmsColumns(yearsRange, treeNodeData)\n            // ------------------\n            // 5. chart rows:\n            // ------------------\n            let { nodeDataseriesName } = budgetCell;\n            let sortedlistName = 'Sorted' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            let explorerChartCode = this.explorerChartCode;\n            let rows = null;\n            let diffdata = null;\n            switch (explorerChartCode) {\n                // ------------------\n                // 5. diff data:\n                // ------------------\n                case \"DiffColumnChart\":\n                case \"DiffPieChart\":\n                    {\n                        // console.log('processing chart code',explorerChartCode)\n                        let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n                        let leftcolumns = budgetCell._columns_diffChart(yearsRange, leftYear);\n                        let rightcolumns = budgetCell._columns_diffChart(yearsRange, rightYear);\n                        diffdata = this._chartParmsDiffData(treeNodeData, yearsRange);\n                        diffdata.old.splice(0, 0, leftcolumns);\n                        diffdata.new.splice(0, 0, rightcolumns);\n                        if (explorerChartCode == \"DiffPieChart\") {\n                            options.diff = {\n                                innerCircle: { radiusFactor: 0.5 }\n                            };\n                            options.pieSliceText = 'percentage';\n                            options.pieHole = null;\n                        }\n                        // console.log( 'diffdata', diffdata, options)\n                        break;\n                    }\n                default:\n                    {\n                        columns = budgetCell._chartParmsColumns(yearsRange, treeNodeData);\n                        // code...\n                        if (sortedDataseries) {\n                            rows = budgetCell._chartParmsRows(treeNodeData, yearsRange);\n                        } else {\n                            // fires on last chart\n                            console.error('System Error: no sortedDataSeries', sortedlistName, sortedDataseries, treeNodeData);\n                            return;\n                        }\n                    }\n            }\n            // --------------------[ ASSEMBLE PARMS PACK ]----------------\n            let chartParms = {\n                chartType,\n                options,\n                events,\n                columns,\n                rows,\n                diffdata\n            };\n            this.chartParmsObject = chartParms;\n            // console.log('chartParms',chartParms)\n            // save it\n            this.setState({\n                chartParms\n            });\n        };\n        // ===========================================================================\n        // 2. chart options:\n        // ===========================================================================\n        this._chartParmsOptions = (treeNodeData, viewpointNamingConfigs, datasetConfig, yearsRange) => {\n            // ----------------------[ assemble support variables ]-------------------\n            let budgetCell = this;\n            let { aspectName, nodeDataseriesName } = budgetCell;\n            let datasetName = constants[\"a\" /* AspectNameToDatasetName */][aspectName];\n            let units = datasetConfig.Units;\n            // --------------------[ assemble vertical label value ]--------------------\n            let calcAlias;\n            if (budgetCell.prorataControls.isprorata) {\n                calcAlias = datasetConfig.CalcUnitsAlias;\n            }\n            let verticalLabel = calcAlias || datasetConfig.UnitsAlias || datasetConfig.Units;\n            verticalLabel = datasetConfig.DatasetName + ' (' + verticalLabel + ')';\n            // -------------------[ assemble horizontal label value ]--------------------\n            let horizontalLabel = null;\n            if (treeNodeData.NamingConfigRef && nodeDataseriesName != 'CommonDimension') {\n                let titleref = viewpointNamingConfigs[treeNodeData.NamingConfigRef];\n                horizontalLabel = titleref.Contents.Alias || titleref.Contents.Name;\n            } else {\n                if (nodeDataseriesName == 'CommonDimension') {\n                    let contentdimensionname = datasetConfig.CommonDimension;\n                    let names = datasetConfig.DimensionNames;\n                    horizontalLabel = names[contentdimensionname].Collection;\n                } else {\n                    let contentdimensionname = treeNodeData.ComponentsDimensionName;\n                    let names = datasetConfig.DimensionNames;\n                    horizontalLabel = names[contentdimensionname].Collection;\n                }\n            }\n            // ----------------------[ assemble chart title ]----------------------\n            // TODO: report reason for 'unknown category'\n            // set basic title\n            let nodename = null;\n            if (treeNodeData.Name) {\n                nodename = treeNodeData.Name;\n            } else {\n                nodename = datasetConfig.DatasetTitle;\n            }\n            // add category name\n            let configindex = treeNodeData.NamingConfigRef;\n            let catname = null;\n            if (configindex) {\n                // viewpoint node\n                let names = viewpointNamingConfigs[configindex];\n                let instancenames = names.Instance;\n                catname = instancenames.Alias || instancenames.Name;\n            } else {\n                // sub-baseline dataset node\n                let { nodeDataPack } = this;\n                if (nodeDataPack.parentBudgetNode && nodeDataPack.parentBudgetNode.treeNodeData) {\n                    let { parentBudgetNode } = nodeDataPack;\n                    let parentconfigindex = parentBudgetNode.treeNodeData.NamingConfigRef;\n                    // first level below depends in parentconfigindex\n                    if (parentconfigindex) {\n                        let names = viewpointNamingConfigs[parentconfigindex];\n                        if (names && names.Contents && names.Contents.DefaultInstance) {\n                            catname = names.Contents.DefaultInstance.Name;\n                            if (!catname) {\n                                console.log('category name not found in names.Contents.DefaultInstance.Name', parentconfigindex, viewpointNamingConfigs);\n                            }\n                        }\n                        // lower levels depend on dimension category names.\n                    } else {\n                        let nameindex = nodeDataseriesName;\n                        if (nameindex == 'Components') {\n                            nameindex += 'DimensionName';\n                        } else if (nameindex == 'CommonDimension') {\n                            nameindex += 'Name';\n                        } else {\n                            console.error('nodeDataseriesName not found for ', this);\n                        }\n                        let dimensionname = parentBudgetNode.treeNodeData[nameindex];\n                        catname = datasetConfig.DimensionNames[dimensionname].Instance;\n                        if (!catname) {\n                            console.log('category name not found in datasetConfig.DimensionNames[dimensionname].Instance', datasetConfig);\n                        }\n                    }\n                }\n                if (!catname) {\n                    catname = '(** Unknown Category **)';\n                }\n            }\n            let title = catname + ': ' + nodename;\n            // add yearspan to title\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { yearScope } = cellDeclaration;\n            let timeSuffix = null;\n            if (yearScope == constants[\"d\" /* TimeScope */][constants[\"d\" /* TimeScope */].OneYear]) {\n                timeSuffix = rightYear.toString();\n            } else {\n                let separator;\n                if (yearScope == constants[\"d\" /* TimeScope */][constants[\"d\" /* TimeScope */].TwoYears]) {\n                    separator = ':';\n                } else {\n                    // must be AllYears\n                    separator = ' - ';\n                }\n                timeSuffix = leftYear + separator + rightYear;\n            }\n            timeSuffix = ', ' + timeSuffix;\n            title += timeSuffix;\n            // add title amount\n            if (yearScope == constants[\"d\" /* TimeScope */][constants[\"d\" /* TimeScope */].OneYear]) {\n                let titleamount = null;\n                // utility functions for number formatting\n                let dollarformat = format({ prefix: \"$\" });\n                let rounded = format({ round: 0, integerSeparator: '' });\n                let simpleroundedone = format({ round: 1, integerSeparator: ',' });\n                let yearsselector = budgetCell.prorataControls.yearsselector;\n                if (treeNodeData[yearsselector]) {\n                    titleamount = treeNodeData[yearsselector][rightYear];\n                    if (units == 'DOLLAR') {\n                        titleamount = dollarformat(titleamount);\n                    } else {\n                        titleamount = simpleroundedone(titleamount);\n                    }\n                    if (!titleamount) titleamount = 'nil';\n                    title += ' (Total: ' + titleamount + ')';\n                }\n            }\n            // add inflation adjustment indicator if appropriate\n            if (datasetConfig.InflationAdjustable) {\n                if (!(yearScope == constants[\"d\" /* TimeScope */][constants[\"d\" /* TimeScope */].OneYear] && datasetConfig.InflationReferenceYear <= rightYear)) {\n                    let isInflationAdjusted = this.viewpointConfigPack.isInflationAdjusted;\n                    let fragment;\n                    if (!isInflationAdjusted) {\n                        fragment = ' -- nominal $';\n                    } else {\n                        fragment = ` -- inflation adjusted to ${datasetConfig.InflationReferenceYear} $`;\n                    }\n                    title += fragment;\n                }\n            }\n            if (budgetCell.prorataControls.isprorata) {\n                title += '; ' + budgetCell.prorataControls.proratastring;\n            }\n            // ------------------------------[ assemble options ]--------------------------------\n            let options = {\n                animation: {\n                    startup: true,\n                    duration: 500,\n                    easing: 'out'\n                },\n                title,\n                vAxis: {\n                    title: verticalLabel,\n                    minValue: 0,\n                    textStyle: {\n                        fontSize: 8\n                    }\n                },\n                hAxis: {\n                    title: horizontalLabel,\n                    textStyle: {\n                        fontSize: 10\n                    }\n                },\n                bar: {\n                    groupWidth: \"95%\"\n                },\n                // width: children.length * 120,// 120 per column\n                height: \"400px\",\n                width: \"400px\",\n                diff: null,\n                pieHole: null,\n                pieSliceText: null\n            };\n            let options_extension = budgetCell._chartTypeOptions(budgetCell.googleChartType, treeNodeData);\n            options = Object.assign(options, options_extension);\n            return options;\n        };\n        this._chartTypeOptions = (googleChartType, treeNodeData) => {\n            let options;\n            switch (googleChartType) {\n                case \"ColumnChart\":\n                    options = {\n                        legend: 'none',\n                        chartArea: {\n                            height: '50%',\n                            top: '15%',\n                            left: '25%',\n                            width: '70%'\n                        }\n                    };\n                    break;\n                case \"PieChart\":\n                    {\n                        options = this._pieChartOptions(treeNodeData);\n                        break;\n                    }\n                case \"AreaChart\":\n                    {\n                        options = {\n                            isStacked: true\n                        };\n                        if (this.explorerChartCode == \"Proportional\") {\n                            options.isStacked = 'percent';\n                        }\n                    }\n                case \"LineChart\":\n                    {\n                        if (!options) options = {};\n                        options.legend = {\n                            position: \"top\",\n                            textStyle: {\n                                fontSize: 9\n                            },\n                            maxLines: 4\n                        };\n                        options.chartArea = {\n                            height: '55%',\n                            top: '30%',\n                            left: 'auto',\n                            width: 'auto'\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        options = {};\n                    }\n            }\n            return options;\n        };\n        this._pieChartOptions = treeNodeData => {\n            let budgetCell = this;\n            // let cellDeclaration = this.cellDeclaration\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { nodeDataseriesName } = budgetCell;\n            let nodeDataseries = treeNodeData[nodeDataseriesName];\n            let sortedlistName = 'Sorted' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            if (!sortedDataseries) {\n                console.error({\n                    errorMessage: 'sorted list \"' + sortedlistName + '\" not available'\n                });\n                throw Error('sorted list \"' + sortedlistName + '\" not available');\n            }\n            let sliceslist = sortedDataseries.map(sortedItem => {\n                let componentItem = nodeDataseries[sortedItem.Code];\n                if (!componentItem) {\n                    console.error('System Error: component not found for (node, sortedlistName, nodeDataseries, item, item.Code) ', treeNodeData, sortedlistName, nodeDataseries, sortedItem.Code, sortedItem);\n                    throw Error('componentItem not found');\n                }\n                let offset = !(componentItem.Components || componentItem.CommonDimension) ? 0.2 : 0;\n                return offset;\n            });\n            let slices = {};\n            for (let index in sliceslist) {\n                slices[index] = { offset: sliceslist[index] };\n                if (slices[index].offset != 0) {\n                    slices[index].color = Object(utilities[\"a\" /* ColorBrightness */])(constants[\"c\" /* GoogleChartColors */][index], 120);\n                    slices[index].offset = 0; // I changed my mind about having an offset; now just a proxy for no drilldown\n                }\n            }\n            let options = {\n                slices,\n                pieHole: 0.4,\n                // is3D: true,\n                legend: {\n                    position: \"top\",\n                    textStyle: {\n                        fontSize: 9\n                    },\n                    maxLines: 4\n                },\n                chartArea: {\n                    height: '55%',\n                    top: '30%',\n                    left: 'auto',\n                    width: 'auto'\n                }\n            };\n            return options;\n        };\n        // ===========================================================================\n        // 3. chart events:\n        // ===========================================================================\n        this._chartParmsEvents = () => {\n            let budgetCell = this;\n            return [{\n                eventName: 'select',\n                callback: (Chart, err) => {\n                    let chart = Chart.chart;\n                    let selection = chart.getSelection();\n                    let chartSelectionData = {\n                        selection,\n                        err\n                    };\n                    budgetCell.selectionCallback(chartSelectionData);\n                }\n            }, {\n                eventName: 'animationfinish',\n                callback: (cell => Chart => {\n                    let selection = Chart.chart.getSelection();\n                    if (selection.length == 0 && cell.chartSelection !== null) {\n                        if (cell.chart) {\n                            cell.refreshSelection();\n                        }\n                    }\n                })(budgetCell)\n            }];\n        };\n        // ===========================================================================\n        // 4. chart columns:\n        // ===========================================================================\n        this._chartParmsColumns = (yearsRange, treeNodeData) => {\n            let budgetCell = this;\n            let { googleChartType } = budgetCell;\n            switch (googleChartType) {\n                case \"ColumnChart\":\n                    return this._columns_ColumnChart(yearsRange);\n                case \"PieChart\":\n                    return this._columns_PieChart(yearsRange);\n                case 'LineChart':\n                case 'AreaChart':\n                    return this._columns_LineChart(treeNodeData);\n                default:\n                    return null;\n            }\n        };\n        this._columns_LineChart = treeNodeData => {\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let budgetCell = this;\n            let columns = [\n            // type is required, else throws silent error\n            { type: 'string', label: 'Year' }];\n            let chartDimensionType = this.nodeDataseriesName;\n            let listName = 'Sorted' + chartDimensionType;\n            let list = treeNodeData[listName];\n            for (let listindex in list) {\n                columns.push({ type: 'number', label: list[listindex].Name });\n            }\n            return columns;\n        };\n        this._columns_ColumnChart = yearsRange => {\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let budgetCell = this;\n            let categorylabel = 'Component'; // placeholder\n            let columns = [\n            // type is required, else throws silent error\n            { type: 'string', label: categorylabel }, { type: 'number', label: rightYear.toString() }, { type: 'string', role: 'style' }];\n            return columns;\n        };\n        this._columns_diffChart = (yearsRange, year) => {\n            let cellDeclaration = this.cellDeclaration;\n            // let { rightYear, leftYear} = this.nodeDataPack.yearSelections\n            let budgetCell = this;\n            let categorylabel = 'Component'; // placeholder\n            let columns = [\n            // type is required, else throws silent error\n            { type: 'string', label: categorylabel }, { type: 'number', label: year.toString() }];\n            return columns;\n        };\n        this._columns_PieChart = yearsRange => {\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let budgetCell = this;\n            let categorylabel = 'Component'; // placeholder\n            let columns = [\n            // type is required, else throws silent error\n            { type: 'string', label: categorylabel }, { type: 'number', label: rightYear.toString() }];\n            return columns;\n        };\n        // ===========================================================================\n        // 5. chart rows:\n        // ===========================================================================\n        this._chartParmsRows = (treeNodeData, yearsRange) => {\n            let budgetCell = this;\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { nodeDataseriesName } = budgetCell;\n            let nodeDataseries = treeNodeData[nodeDataseriesName];\n            let sortedlistName = 'Sorted' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            if (!sortedDataseries) {\n                console.error({\n                    errorMessage: 'sorted list \"' + sortedlistName + '\" not available'\n                });\n                throw Error('sorted list \"' + sortedlistName + '\" not available');\n            }\n            switch (budgetCell.googleChartType) {\n                case \"PieChart\":\n                case \"ColumnChart\":\n                    {\n                        let { googleChartType: chartType } = budgetCell;\n                        let rows = this._getYearRows(sortedDataseries, nodeDataseries, rightYear, chartType);\n                        return rows;\n                    }\n                case \"LineChart\":\n                case \"AreaChart\":\n                    return this._LineChartRows(treeNodeData, sortedDataseries, yearsRange);\n            }\n        };\n        this._chartParmsDiffData = (treeNodeData, yearsRange) => {\n            let budgetCell = this;\n            let diffdata = {\n                old: null,\n                new: null\n            };\n            let cellDeclaration = this.cellDeclaration;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let { nodeDataseriesName } = budgetCell;\n            let nodeDataseries = treeNodeData[nodeDataseriesName];\n            let sortedlistName = 'Sorted' + nodeDataseriesName;\n            let sortedDataseries = treeNodeData[sortedlistName];\n            if (!sortedDataseries) {\n                console.error({\n                    errorMessage: 'sorted list \"' + sortedlistName + '\" not available'\n                });\n                throw Error('sorted list \"' + sortedlistName + '\" not available');\n            }\n            let chartType = this.explorerChartCode;\n            let rows;\n            diffdata.new = this._getYearRows(sortedDataseries, nodeDataseries, rightYear, chartType);\n            diffdata.old = this._getYearRows(sortedDataseries, nodeDataseries, leftYear, chartType);\n            return diffdata;\n        };\n        this._getYearRows = (sortedDataseries, nodeDataseries, year, chartType) => {\n            let budgetCell = this;\n            let rows = sortedDataseries.map(sortedItem => {\n                let componentItem = nodeDataseries[sortedItem.Code];\n                if (!componentItem) {\n                    console.error('System Error: component not found for (node, sortedlistName, nodeDataseries, item, item.Code) ', nodeDataseries, sortedItem.Code, sortedItem);\n                    throw Error('componentItem not found');\n                }\n                let yearsselector = budgetCell.prorataControls.yearsselector;\n                let amount;\n                // amount cannot be null or undefined; causes diff charts to fail\n                if (componentItem[yearsselector]) {\n                    amount = componentItem[yearsselector][year];\n                    if (amount === undefined) amount = 0;\n                } else {\n                    amount = 0;\n                }\n                let row = [sortedItem.Name, amount];\n                // enhance row\n                switch (chartType) {\n                    case \"ColumnChart\":\n                        row = budgetCell._rows_ColumnCharts_row(row, componentItem);\n                        break;\n                }\n                return row;\n            });\n            return rows;\n        };\n        this._LineChartRows = (treeNodeData, sortedDataSeries, yearsRange) => {\n            let rows = [];\n            let budgetCell = this;\n            let { rightYear, leftYear } = this.nodeDataPack.yearSelections;\n            let yearsselector = budgetCell.prorataControls.yearsselector;\n            for (let year = leftYear; year <= rightYear; year++) {\n                let items = sortedDataSeries.map(sortedItem => {\n                    let amount = null;\n                    let years = treeNodeData[this.nodeDataseriesName][sortedItem.Code][yearsselector];\n                    if (years && years[year] !== undefined) {\n                        amount = years[year];\n                    }\n                    return amount;\n                });\n                let row = [year.toString(), ...items];\n                rows.push(row);\n            }\n            return rows;\n        };\n        this._rows_ColumnCharts_row = (row, componentItem) => {\n            let style = '';\n            if (componentItem.Baseline) {\n                style = 'stroke-color: Gold; stroke-width: 3;';\n            }\n            if (!(componentItem.Components || componentItem.CommonDimension)) {\n                style += 'fill-color: #3366CC;fill-opacity:0.5;';\n            }\n            row.push(style);\n            return row;\n        };\n        this.getDataTable = () => {\n            // console.log('chartParms',this.chartParmsObject)\n            let { chartType, columns, rows, diffdata, options } = this.chartParmsObject;\n            let { hAxis, vAxis, title } = options;\n            let chartCode = this.explorerChartCode;\n            let tableparms = {\n                chartCode,\n                chartType,\n                chartdata: {\n                    rows,\n                    diffdata,\n                    columns,\n                    hAxis,\n                    vAxis\n                },\n                title\n            };\n            let outputparms = this._preProcessTableData(tableparms);\n            // console.log('outputparms',outputparms)\n            return outputparms;\n        };\n        this._preProcessTableData = tableparms => {\n            let { chartCode, chartType } = tableparms;\n            let outputparms = {\n                chartCode,\n                chartType,\n                data: null,\n                columns: null,\n                title: null,\n                footer: null\n            };\n            // 'DonutChart':'PieChart',\n            // 'ColumnChart':'ColumnChart',\n            // 'DiffPieChart':'PieChart',\n            // 'DiffColumnChart':'ColumnChart',\n            // 'TimeLine':'LineChart',\n            // 'StackedArea':'AreaChart', // isStacked:'absolute'\n            // 'Proportional':'AreaChart', // isStacked:'percent'\n            switch (chartCode) {\n                case \"ColumnChart\":\n                    outputparms = this.prepareColumnChartData(tableparms, outputparms);\n                    break;\n                case \"DonutChart\":\n                    outputparms = this.prepareDonutChartData(tableparms, outputparms);\n                    break;\n                case \"DiffColumnChart\":\n                    outputparms = this.prepareDiffColumnChartData(tableparms, outputparms);\n                    break;\n                case \"DiffPieChart\":\n                    outputparms = this.prepareDiffPieChartData(tableparms, outputparms);\n                    break;\n                case \"TimeLine\":\n                    outputparms = this.prepareTimelineData(tableparms, outputparms);\n                    break;\n                case \"StackedArea\":\n                    outputparms = this.prepareStackedAreaData(tableparms, outputparms);\n                    break;\n                case \"Proportional\":\n                    outputparms = this.prepareProportionalData(tableparms, outputparms);\n                    break;\n                default:\n                    throw 'Unknown chart type in cell.class._processTableData: ' + chartCode;\n            }\n            return outputparms;\n        };\n        // ----------- one year --------------\n        this.prepareColumnChartData = (tableparms, outputparms) => {\n            let rows = this._getOutputRows(tableparms.chartdata.rows, 2);\n            let footer = this._getOutputFooter(rows, 2);\n            let columns = [];\n            for (let n = 0; n < 2; n++) {\n                columns.push({ Header: tableparms.chartdata.columns[n].label, type: 'number' });\n            }\n            // replace placeholder...\n            columns[0].Header = tableparms.chartdata.hAxis.title;\n            columns[0].type = 'label';\n            let title = tableparms.title + '. Data: ' + tableparms.chartdata.vAxis.title;\n            outputparms.data = rows;\n            outputparms.columns = columns;\n            outputparms.footer = footer;\n            outputparms.title = title;\n            return outputparms;\n        };\n        this._getOutputRows = (rows, colcount) => {\n            let newrows = [];\n            for (let row of rows) {\n                let newrow = [];\n                for (let n = 0; n < colcount; n++) {\n                    newrow.push(row[n]);\n                }\n                newrows.push(newrow);\n            }\n            return newrows;\n        };\n        this._getOutputFooter = (rows, itemcount) => {\n            let footer = ['Total'];\n            for (let n = 1; n < itemcount; n++) {\n                let totalamount = rows.reduce((accumulator, currentvalue) => {\n                    return currentvalue[n] ? accumulator + currentvalue[n] : accumulator;\n                }, 0);\n                footer.push(totalamount);\n            }\n            return footer;\n        };\n        this.prepareDonutChartData = (tableparms, outputparms) => {\n            outputparms = this.prepareColumnChartData(tableparms, outputparms); // same input\n            outputparms.columns.push({ Header: 'Ratio', type: 'ratio' });\n            let total = outputparms.footer[1];\n            if (total) outputparms.footer.push(1);else outputparms.footer.push(null);\n            for (let n = 0; n < outputparms.data.length; n++) {\n                let numerator = outputparms.data[n][1];\n                if (numerator && total) {\n                    outputparms.data[n].push(numerator / total);\n                } else {\n                    outputparms.data[n].push(null);\n                }\n            }\n            return outputparms;\n        };\n        // ----------- two yeara --------------\n        this.prepareDiffColumnChartData = (tableparms, outputparms) => {\n            let { old: olddata, new: newdata } = tableparms.chartdata.diffdata;\n            let oldrows = olddata.slice(1);\n            let oldcolumns = olddata.slice(0, 1)[0];\n            oldrows = this._getOutputRows(oldrows, 2);\n            let oldfooter = this._getOutputFooter(oldrows, 2);\n            let newrows = newdata.slice(1);\n            let newcolumns = newdata.slice(0, 1)[0];\n            newrows = this._getOutputRows(newrows, 2);\n            let newfooter = this._getOutputFooter(newrows, 2);\n            // console.log('oldrows, oldcolumns, newrows, newcolumns',oldrows,oldcolumns,newrows,newcolumns)\n            let outputrows = oldrows;\n            for (let n = 0; n < newrows.length; n++) {\n                outputrows[n].push(newrows[n][1]);\n            }\n            for (let n = 0; n < outputrows.length; n++) {\n                let current = outputrows[n][2];\n                let previous = outputrows[n][1];\n                let change = null;\n                if (!isNaN(current) && !isNaN(previous)) {\n                    change = current - previous;\n                }\n                outputrows[n].push(change);\n            }\n            let footer = oldfooter;\n            footer.push(newfooter[1]);\n            let current = footer[2]; // any required to overcome ts evaluation as string type\n            let previous = footer[1];\n            let change = null;\n            if (!isNaN(current) && !isNaN(previous)) {\n                change = current - previous;\n            }\n            footer.push(change);\n            // console.log('outputrows',outputrows)\n            let columns = [{ Header: tableparms.chartdata.hAxis.title, type: 'label' }, { Header: oldcolumns[1].label, type: 'number' }, { Header: newcolumns[1].label, type: 'number' }, { Header: 'Change', type: 'number' }];\n            let title = tableparms.title + '. Data: ' + tableparms.chartdata.vAxis.title;\n            outputparms.data = outputrows;\n            outputparms.columns = columns;\n            outputparms.footer = footer;\n            outputparms.title = title;\n            return outputparms;\n        };\n        this.prepareDiffPieChartData = (tableparms, outputparms) => {\n            outputparms = this.prepareDiffColumnChartData(tableparms, outputparms); // same input\n            let columns = outputparms.columns;\n            columns.splice(2, 0, { Header: columns[1].Header + ' Ratio', type: 'ratio' });\n            columns.splice(4, 0, { Header: columns[3].Header + ' Ratio', type: 'ratio' });\n            columns.push({ Header: 'Ratio of Change to Previous', type: 'ratio' }, { Header: 'Ratio of Change to Current', type: 'ratio' });\n            let footer = outputparms.footer;\n            let previoustotal = footer[1];\n            let currenttotal = footer[2];\n            let totalchange = footer[3];\n            footer.splice(2, 0, 1);\n            footer.splice(4, 0, 1);\n            let changetoprevious = null;\n            let changetocurrent = null;\n            if (!isNaN(totalchange)) {\n                if (!isNaN(previoustotal) && previoustotal) {\n                    changetoprevious = totalchange / previoustotal;\n                }\n                if (!isNaN(currenttotal) && currenttotal) {\n                    changetocurrent = totalchange / currenttotal;\n                }\n            }\n            footer.push(changetoprevious, changetocurrent);\n            let data = outputparms.data;\n            for (let n = 0; n < data.length; n++) {\n                let row = data[n];\n                let previousvalue = row[1];\n                let currentvalue = row[2];\n                let change = row[3];\n                let previousratio = null;\n                let currentratio = null;\n                let changetoprevious = null;\n                let changetocurrent = null;\n                if (!isNaN(previoustotal) && !isNaN(previousvalue) && previousvalue && previoustotal) {\n                    previousratio = previousvalue / previoustotal;\n                }\n                if (!isNaN(currenttotal) && !isNaN(currentvalue) && currentvalue && currenttotal) {\n                    currentratio = currentvalue / currenttotal;\n                }\n                if (!isNaN(change)) {\n                    if (!isNaN(previousvalue) && previousvalue) {\n                        changetoprevious = change / previousvalue;\n                    }\n                    if (!isNaN(currentvalue) && currentvalue) {\n                        changetocurrent = change / currentvalue;\n                    }\n                }\n                row.splice(2, 0, previousratio);\n                row.splice(4, 0, currentratio);\n                row.push(changetoprevious, changetocurrent);\n            }\n            return outputparms;\n        };\n        // ----------- all years --------------\n        this.prepareTimelineData = (tableparms, outputparms) => {\n            let title = tableparms.title + '. Data: ' + tableparms.chartdata.vAxis.title;\n            let data = [];\n            for (let n = 0; n < tableparms.chartdata.columns.length - 1; n++) {\n                data.push([]);\n            }\n            // console.log('data',data)\n            let rows = tableparms.chartdata.rows;\n            let newrows = [];\n            let columns = [];\n            for (let n = 0; n < rows.length; n++) {\n                let row = rows[n];\n                let type = 'number';\n                columns.push({ Header: row[0], type });\n                for (let x = 1; x < row.length; x++) {\n                    data[x - 1][n] = row[x];\n                }\n            }\n            let sourcecolumns = tableparms.chartdata.columns;\n            for (let n = 1; n < sourcecolumns.length; n++) {\n                data[n - 1].splice(0, 0, sourcecolumns[n].label);\n            }\n            columns.splice(0, 0, { Header: tableparms.chartdata.hAxis.title, type: 'label' });\n            let footer = this._getOutputFooter(data, columns.length);\n            outputparms.data = data;\n            outputparms.columns = columns;\n            outputparms.title = title;\n            outputparms.footer = footer;\n            return outputparms;\n        };\n        this.prepareStackedAreaData = (tableparms, outputparms) => {\n            outputparms = this.prepareTimelineData(tableparms, outputparms); // same data\n            return outputparms;\n        };\n        this.prepareProportionalData = (tableparms, outputparms) => {\n            outputparms = this.prepareTimelineData(tableparms, outputparms); // same input\n            let columns = outputparms.columns;\n            for (let n = columns.length; n > 1; n--) {\n                columns.splice(n, 0, { Header: columns[n - 1].Header + ' Ratio', type: 'ratio' });\n            }\n            let { footer, data } = outputparms;\n            for (let n = footer.length; n > 1; n--) {\n                for (let rownum = 0; rownum < data.length; rownum++) {\n                    let row = data[rownum];\n                    let numerator = row[n - 1];\n                    let denominator = footer[n - 1];\n                    let ratio = null;\n                    if (!isNaN(numerator) && !isNaN(denominator) && denominator) {\n                        ratio = numerator / denominator;\n                    }\n                    row.splice(n, 0, ratio);\n                }\n                footer.splice(n, 0, 1);\n            }\n            return outputparms;\n        };\n        let { nodeDataseriesName, chartSelection, uid } = specs;\n        this.nodeDataseriesName = nodeDataseriesName;\n        this.chartSelection = chartSelection;\n        this.uid = uid;\n    }\n    get state() {\n        return this.getState();\n    }\n    // =======================[ PROPERTIES ]============================\n    // -------------[ primary control properties, set on creation ]---------------\n    get explorerChartCode() {\n        let cellDeclaration = this.getProps().declarationData.cellsById[this.uid];\n        let settings = cellDeclaration.chartConfigs[cellDeclaration.yearScope];\n        return settings.explorerChartCode;\n    }\n    // ------------[ derivative control properties ]-------------------\n    // map from internal code to googleChartType\n    get googleChartType() {\n        return constants[\"b\" /* ChartCodeToGoogleChartType */][this.explorerChartCode];\n    }\n    get cellDeclaration() {\n        return this.getProps().declarationData.cellsById[this.uid];\n    }\n    // current chart (can change) taken from chartComponent...\n    get chart() {\n        if (this.chartComponent) return this.chartComponent.chart; // up to date version\n        else return null;\n    }\n    // readonly; set by setChartParms()\n    // the formal parameters required by Chart Component for google chart creation\n    // private _chartParms: ChartParms\n    get chartParms() {\n        return this.getState().chartParms;\n    }\n}\n/* harmony default export */ var cell_class = (cell_class_BudgetCell);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/node.class.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// budgetnode.tsx\n\n\nclass node_class_BudgetNode {\n    constructor(parms, uid, node, parentBudgetNode = null) {\n        // let portalcharts = parms.datasetSpecs\n        this.new = true;\n        this.updated = false;\n        this.newCells = null;\n        this.parentBudgetNode = null;\n        this.updateAspect = (aspect, treeNodeData) => {\n            this.aspectName = aspect;\n            this.updateDataNode(treeNodeData);\n        };\n        this.updateDataNode = treeNodeData => {\n            this._nodeData = treeNodeData;\n            this.updated = true;\n        };\n        this.oldNodeState = {\n            hasChildren: null\n        };\n        // ====================================================================\n        // ---------------------[ PRIVATE ]------------------------------------\n        this.getCellDeclarationParms = () => {\n            let budgetNode = this;\n            let parmsList = [];\n            let datasetName = constants[\"a\" /* AspectNameToDatasetName */][budgetNode.aspectName];\n            let chartSpecs = budgetNode.viewpointConfigPack.datasetConfig.Dataseries;\n            let node = budgetNode.treeNodeData;\n            let cellDeclarationData;\n            if (budgetNode.parentBudgetNode) {\n                let parent = this.parentBudgetNode;\n                if (parent.priorCellSettings) {\n                    cellDeclarationData = parent.priorCellSettings;\n                    parent.priorCellSettings = null;\n                } else {\n                    let parentNodeDeclaration = budgetNode.props.declarationData.nodesById[parent.uid];\n                    let cellIndex = parentNodeDeclaration.cellIndex;\n                    let parentCell = parent.cells[cellIndex];\n                    if (parentCell) {\n                        // could fail with race condition of multiple concurrent node declarations from urlparms\n                        // console.log('getCellDeclarationParms budgetNode',budgetNode)\n                        let callingCellDeclaration = budgetNode.props.declarationData.cellsById[parentCell.uid];\n                        let chartConfigs = Object.assign({}, callingCellDeclaration.chartConfigs);\n                        cellDeclarationData = {\n                            yearScope: callingCellDeclaration.yearScope,\n                            chartConfigs\n                        };\n                    } else {\n                        cellDeclarationData = this.props.declarationData.defaults.cell;\n                    }\n                }\n            } else {\n                cellDeclarationData = this.props.declarationData.defaults.cell;\n            }\n            for (let chartSpec of chartSpecs) {\n                let cellDeclaration = Object.assign({}, cellDeclarationData);\n                // not only must the dataseries be mandated, but also present...\n                if (node[chartSpec.Type]) {\n                    cellDeclaration.nodeDataseriesName = chartSpec.Type;\n                    parmsList.push(cellDeclaration);\n                }\n            }\n            return parmsList;\n        };\n        this._updateCell = (cell, cellIndex) => {\n            let budgetNode = this;\n            let { viewpointConfigPack, treeNodeData, yearsRange, yearSelections, parentBudgetNode, nodeIndex } = budgetNode;\n            let nodeDataPack = {\n                treeNodeData,\n                yearsRange,\n                yearSelections,\n                parentBudgetNode,\n                budgetNode\n            };\n            cell.viewpointConfigPack = viewpointConfigPack;\n            cell.nodeDataPack = nodeDataPack;\n            cell.aspectName = budgetNode.branchSettings.aspect, budgetNode._setCellSelectionCallback(cell, cellIndex);\n            budgetNode._setCellTitle(cell);\n        };\n        this._setCellTitle = budgetCell => {\n            let portaltitles = budgetCell.viewpointConfigPack.datasetConfig.CellTitles;\n            let chartblocktitle = null;\n            if (budgetCell.nodeDataseriesName == 'CommonDimension') {\n                chartblocktitle = portaltitles.CommonDimension;\n            } else {\n                chartblocktitle = portaltitles.Components;\n            }\n            budgetCell.cellTitle = chartblocktitle;\n        };\n        this._setCellSelectionCallback = (cell, cellIndex) => {\n            let budgetNode = this;\n            let selectfn = this.onChartComponentSelection;\n            let fcurrent = selectfn(budgetNode.nodeIndex)(cellIndex);\n            cell.selectionCallback = fcurrent;\n        };\n        this.viewpointName = parms.viewpointName;\n        this.aspectName = parms.aspectName;\n        this.dataPath = parms.dataPath;\n        this.nodeIndex = parms.nodeIndex;\n        this.yearsRange = parms.yearsRange;\n        this.yearSelections = parms.yearSelections;\n        this._nodeData = node;\n        this.uid = uid;\n        if (parentBudgetNode) this.parentBudgetNode = parentBudgetNode;\n    }\n    get treeNodeData() {\n        return this._nodeData;\n    }\n    get state() {\n        return this.getState();\n    }\n    get props() {\n        return this.getProps();\n    }\n    // treeNodeMetaDataFromParentSortedList: any = null // includes parentNode for now\n    // parentNode: any = null\n    get nodeDeclaration() {\n        return this.props.declarationData.nodesById[this.uid];\n    }\n    get cells() {\n        return [...this.state.nodeCells];\n    }\n    setCells(cellDeclarations) {\n        let cells = [];\n        // // TODO: should be default for each chart...\n        // build cells array\n        for (let cellIndex in cellDeclarations) {\n            let cellDeclaration = cellDeclarations[cellIndex];\n            // TODO: this should use cellIndex not celluid of cellDeclaration!!\n            let { nodeDataseriesName, celluid, chartSelection } = cellDeclaration;\n            if (chartSelection === undefined) chartSelection = null;\n            let cell = new cell_class({\n                nodeDataseriesName,\n                chartSelection,\n                uid: celluid\n            });\n            this._updateCell(cell, cellIndex);\n            cells.push(cell);\n        }\n        return cells;\n    }\n    resetCells() {\n        let budgetNode = this;\n        let cells = budgetNode.cells;\n        for (let cellIndex in cells) {\n            let cell = cells[cellIndex];\n            budgetNode._updateCell(cell, cellIndex);\n            cell.setChartParms();\n        }\n        this.newCells = cells;\n        this.updated = true;\n    }\n    switchYearSelections(yearSelections) {\n        let budgetNode = this;\n        this.yearSelections = yearSelections;\n        let cells = budgetNode.cells;\n        for (let cellIndex in cells) {\n            let cell = cells[cellIndex];\n            budgetNode._updateCell(cell, cellIndex);\n            cell.setChartParms();\n        }\n        this.newCells = cells;\n        this.updated = true;\n    }\n    get cellDeclarationList() {\n        let list = this.getProps().declarationData.nodesById[this.uid].cellList;\n        if (list == null) return list;else return [...list];\n    }\n}\n/* harmony default export */ var node_class = (node_class_BudgetNode);\n// CONCATENATED MODULE: ./ts/addons/explorer/classes/branch.class.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// budgetbranch.tsx\n/*\n\nTODO: fix addnode to pass along cell settings for new child\n\n*/\n\n\n\n\nclass branch_class_BudgetBranch {\n    constructor(parms) {\n        // this generates a trigger to create a budget node object\n        this.getInitialBranchNodeParms = () => {\n            let defaults = this.getProps().declarationData.defaults.node;\n            let branchSettings = this.branchDeclaration;\n            let viewpointData = this.state.viewpointData;\n            let budgetBranch = this;\n            let datapath = [];\n            let { viewpoint: viewpointName, aspect: aspectName } = branchSettings;\n            let budgetNodeParms = {\n                viewpointName,\n                aspectName,\n                yearsRange: {\n                    firstYear: null,\n                    lastYear: null\n                },\n                yearSelections: Object.assign({}, defaults.yearSelections),\n                dataPath: [],\n                nodeIndex: 0,\n                cellIndex: 0\n            };\n            budgetNodeParms = Object.assign(defaults, budgetNodeParms);\n            return budgetNodeParms;\n        };\n        // this is a response to the addNode action\n        this.addNode = (budgetNodeUid, nodeIndex, budgetNodeParms) => {\n            let budgetBranch = this;\n            let { dataPath } = budgetNodeParms;\n            let branchSettings = budgetBranch.branchDeclaration;\n            let branchNode = budgetBranch;\n            let viewpointData = budgetBranch.state.viewpointData;\n            if (!viewpointData) return;\n            let treeNodeData = Object(getbudgetnode[\"a\" /* default */])(viewpointData, dataPath);\n            if (!treeNodeData) {\n                console.error('failure to find treenode data', dataPath, viewpointData);\n            }\n            let branchNodes = budgetBranch.nodes;\n            let parentNode = nodeIndex === 0 ? null : branchNodes[branchNodes.length - 1];\n            // TODO: obtain and pass cell configurations - yearScope and chartConfigs\n            let budgetNode = new node_class(budgetNodeParms, budgetNodeUid, treeNodeData, parentNode);\n            branchNodes[nodeIndex] = budgetNode;\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        this.saveNodeStates = () => {\n            let budgetBranch = this;\n            let nodes = budgetBranch.nodes;\n            let node;\n            for (node of nodes) {\n                // console.log('node in saveNodeStates',node)\n                node.oldNodeState.hasChildren = !!node.treeNodeData.Components;\n            }\n        };\n        this.toggleInflationAdjusted = () => {\n            let budgetBranch = this;\n            let nodeIndex;\n            let branchuid = budgetBranch.uid;\n            let branchSettings = budgetBranch.branchDeclaration;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let branchNodes = budgetBranch.nodes;\n            for (nodeIndex in branchNodes) {\n                let budgetNode = branchNodes[nodeIndex];\n                let dataNode = Object(getbudgetnode[\"a\" /* default */])(viewpointData, budgetNode.dataPath);\n                budgetNode.updateDataNode(dataNode);\n                budgetNode.resetCells();\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        this.harmonizeCells = () => {\n            let budgetBranch = this;\n            let nodeIndex;\n            let branchNodes = budgetBranch.nodes;\n            for (nodeIndex in branchNodes) {\n                let budgetNode = branchNodes[nodeIndex];\n                let nodeDeclaration = budgetNode.props.declarationData.nodesById[budgetNode.uid];\n                budgetNode.switchYearSelections(nodeDeclaration.yearSelections);\n                budgetNode.resetCells();\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        // this resets the branch in response to the change aspect user request\n        this.switchAspect = () => {\n            let budgetBranch = this;\n            let { actions, nodeCallbacks: callbacks } = budgetBranch;\n            let switchResults = {\n                deeperdata: false,\n                shallowerdata: false,\n                mismatch: false,\n                message: null\n            };\n            let branchSettings = budgetBranch.branchDeclaration;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let branchNodes = budgetBranch.nodes;\n            let budgetNode = null;\n            let parentBudgetNode;\n            let nodeIndex;\n            let isError = false;\n            let chartParmsObj = null;\n            let branchuid = budgetBranch.uid;\n            for (nodeIndex in branchNodes) {\n                parentBudgetNode = budgetNode;\n                budgetNode = branchNodes[nodeIndex];\n                let dataNode = Object(getbudgetnode[\"a\" /* default */])(viewpointData, budgetNode.dataPath);\n                if (dataNode) {\n                    // check previous cell configuration against previous node\n                    // TODO: THIS IS A PROXY THAT NEEDS TO BE REPLACED\n                    // there is only one chart where there should be 2\n                    let deeperdata = !!dataNode.Components && !budgetNode.oldNodeState.hasChildren;\n                    // there are two charts where there should be 1\n                    let shallowerdata = !dataNode.Components && budgetNode.oldNodeState.hasChildren;\n                    // now set budgetNode with new data node\n                    let parentDataNode = null;\n                    if (nodeIndex > 0) {\n                        parentDataNode = branchNodes[nodeIndex - 1].treeNodeData;\n                    }\n                    if (deeperdata || shallowerdata) {\n                        switchResults.deeperdata = deeperdata;\n                        switchResults.shallowerdata = shallowerdata;\n                        // replace budgetNode\n                        isError = true;\n                        let prevBudgetNode = branchNodes[nodeIndex - 1];\n                        let removed = branchNodes.splice(nodeIndex);\n                        let removedids = removed.map(item => {\n                            return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n                        });\n                        actions.removeNodeDeclarations(removedids);\n                        setTimeout(() => {\n                            let prevBudgetCell = prevBudgetNode.cells[0];\n                            // TODO: pass prior cell and node settings\n                            let childprops = {\n                                selectionrow: prevBudgetCell.chartSelection,\n                                nodeIndex: prevBudgetNode.nodeIndex,\n                                cellIndex: 0,\n                                priorCellSettings: null,\n                                priorNodeSettings: null\n                            };\n                            // let fcurrent = fn(nodeIndex)(0)\n                            // let budgetBranch = this\n                            budgetBranch.createChildNodeDeclaration(childprops);\n                        });\n                        budgetNode = null; // branchNodes[nodeIndex] // created by createChildNodeDeclaration as side effect\n                    } else {\n                        budgetNode.updateAspect(branchSettings.aspect, dataNode\n                        // parentDataNode\n                        );\n                        budgetNode.resetCells();\n                        // budgetNode.newCells = newCells\n                    }\n                } else {\n                    let removed = branchNodes.splice(nodeIndex);\n                    let removedids = removed.map(item => {\n                        return { nodeuid: item.uid, cellList: item.cellDeclarationList };\n                    });\n                    actions.removeNodeDeclarations(removedids);\n                    switchResults.mismatch = true;\n                    switchResults.message = 'The new aspect does not have a matching chart for ' + budgetNode.treeNodeData.Name;\n                    let cells = parentBudgetNode.cells;\n                    for (let cell of cells) {\n                        let theCell = cell;\n                        if (theCell.chartSelection !== null) {\n                            theCell.chartSelection = null;\n                        }\n                    }\n                }\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n            return switchResults;\n        };\n        this.calculateProRata = viewpointdata => {\n            let { branchDeclaration } = this;\n            let { repository, prorata: prorataindex } = branchDeclaration;\n            let prorataseries;\n            switch (prorataindex) {\n                case \"OFF\":\n                    {\n                        prorataseries = 'none';\n                        break;\n                    }\n                case \"PERPERSON\":\n                case \"PER100000PERSONS\":\n                    prorataseries = 'population';\n                    break;\n                case \"PERHOUSEHOLD\":\n                case \"PER40000HOUSEHOLDS\":\n                    prorataseries = 'households';\n                    break;\n                case \"PERWARD\":\n                case \"PERNEIGHBOURHOOD\":\n                    prorataseries = 'none';\n                    break;\n                default:\n                    console.error('unknown prorataindex', prorataindex);\n                    return;\n            }\n            let promise = new Promise((resolve, error) => {\n                if (prorataindex == 'OFF') {\n                    resolve(true);\n                } else {\n                    if (prorataseries == 'none') {\n                        let { YearsRange } = viewpointdata.Meta.datasetConfig;\n                        let { start, end } = YearsRange;\n                        let proratadata = {\n                            years: {}\n                        };\n                        for (let year = start; year <= end; year++) {\n                            proratadata.years[year] = null;\n                        }\n                        let budgetBranch = this;\n                        budgetBranch._doProRataCalc(viewpointdata, proratadata);\n                        resolve(true);\n                    } else {\n                        let _promise = databaseapi.getProrataData({\n                            repository,\n                            prorataseries\n                        });\n                        _promise.then(proratadata => {\n                            // console.log('returned proratadata',proratadata)\n                            let budgetBranch = this;\n                            budgetBranch._doProRataCalc(viewpointdata, proratadata);\n                            resolve(true);\n                        }).catch(reason => {\n                            console.error(reason);\n                            error(reason);\n                        });\n                    }\n                }\n            });\n            return promise;\n        };\n        this._doProRataCalc = (viewpointdata, proratadata) => {\n            // console.log('viewpointdata,proratadata',viewpointdata,proratadata)\n            let proratayearlist = Object.assign({}, proratadata.years);\n            let { branchDeclaration } = this;\n            let { prorata: prorataindex } = branchDeclaration;\n            let { datasetConfig } = viewpointdata.Meta;\n            let unitratio = datasetConfig.UnitRatio;\n            let denominator,\n                multiplier,\n                precision = 5,\n                threshhold = 10000;\n            let proratatype = 'yearly';\n            switch (prorataindex) {\n                case \"PERPERSON\":\n                    denominator = 1;\n                    multiplier = unitratio;\n                    break;\n                case \"PER100000PERSONS\":\n                    denominator = 100000;\n                    multiplier = 1;\n                    break;\n                case \"PERHOUSEHOLD\":\n                    denominator = 1;\n                    multiplier = unitratio;\n                    break;\n                case \"PER40000HOUSEHOLDS\":\n                    denominator = 40000;\n                    multiplier = 1;\n                    break;\n                case \"PERWARD\":\n                    denominator = 44;\n                    multiplier = 1;\n                    proratatype = 'fixed';\n                    break;\n                case \"PERNEIGHBOURHOOD\":\n                    denominator = 4 * 44;\n                    multiplier = 1;\n                    proratatype = 'fixed';\n                    break;\n                default:\n                    console.error('unknown prorataindex in _doProRataCalc', prorataindex);\n                    return;\n            }\n            if (multiplier != 1) {\n                datasetConfig.CalcUnitRatio = 1;\n                datasetConfig.CalcUnitsAlias = \"dollars\";\n            } else {\n                datasetConfig.CalcUnitRatio = datasetConfig.UnitRatio;\n                datasetConfig.CalcUnitsAlias = datasetConfig.UnitsAlias;\n            }\n            if (proratatype == 'fixed') {\n                for (let yearindex in proratayearlist) {\n                    proratayearlist[yearindex] = denominator;\n                }\n            } else {\n                for (let yearindex in proratayearlist) {\n                    let amount = proratayearlist[yearindex];\n                    proratayearlist[yearindex] = amount / denominator / multiplier;\n                }\n            }\n            this._doCalcYears(viewpointdata, proratayearlist, threshhold, precision);\n            // console.log('_doProRataCalc', viewpointdata, proratayearlist, threshhold, precision)\n        };\n        this._doCalcYears = (node, proratayearlist, threshhold, precision) => {\n            let calcyears = {};\n            let years = node.years;\n            if (years) {\n                for (let yearindex in years) {\n                    if (proratayearlist[yearindex]) {\n                        let amount = years[yearindex] / proratayearlist[yearindex];\n                        if (amount < threshhold) {\n                            amount = Number(amount.toPrecision(precision));\n                        } else {\n                            amount = Number(amount.toFixed(0));\n                        }\n                        calcyears[yearindex] = amount;\n                    }\n                }\n                node.calcyears = calcyears;\n            }\n            if (node.Components) {\n                for (let index in node.Components) {\n                    let subnode = node.Components[index];\n                    this._doCalcYears(subnode, proratayearlist, threshhold, precision);\n                }\n            }\n            if (node.CommonDimension) {\n                for (let index in node.CommonDimension) {\n                    let subnode = node.CommonDimension[index];\n                    this._doCalcYears(subnode, proratayearlist, threshhold, precision);\n                }\n            }\n        };\n        this.updateProrata = () => {\n            let budgetBranch = this;\n            let nodeIndex;\n            let branchuid = budgetBranch.uid;\n            let branchSettings = budgetBranch.branchDeclaration;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let branchNodes = budgetBranch.nodes;\n            for (nodeIndex in branchNodes) {\n                let budgetNode = branchNodes[nodeIndex];\n                let dataNode = Object(getbudgetnode[\"a\" /* default */])(viewpointData, budgetNode.dataPath);\n                budgetNode.updateDataNode(dataNode);\n                budgetNode.resetCells();\n            }\n            budgetBranch.setState({\n                branchNodes\n            });\n        };\n        // TODO: generate action to show progress\n        this.getViewpointData = () => {\n            let branchSettings = this.branchDeclaration;\n            let { viewpoint: viewpointName, aspect: aspectName, inflationAdjusted, version: versionName, repository } = branchSettings;\n            // console.log('aspectName, AspectNameToDatasetName',aspectName, AspectNameToDatasetName)\n            let datasetName = constants[\"a\" /* AspectNameToDatasetName */][aspectName];\n            let _promise = databaseapi.getViewpointData({\n                repository,\n                viewpointName,\n                versionName,\n                datasetName,\n                inflationAdjusted\n            });\n            let promise = new Promise((resolve, error) => {\n                _promise.then(viewpointdata => {\n                    let budgetBranch = this;\n                    this.calculateProRata(viewpointdata).then(() => {\n                        budgetBranch.setState({\n                            viewpointData: viewpointdata\n                        });\n                        resolve(true);\n                    }).catch(reason => {\n                        console.error(reason);\n                        throw Error(reason);\n                    });\n                }).catch(reason => {\n                    console.error(reason);\n                    error(reason);\n                });\n            });\n            return promise;\n        };\n        // called only by user chart row selection\n        // therefore metadata is always component\n        this.createChildNodeDeclaration = props => {\n            let budgetBranch = this;\n            let { selectionrow, nodeIndex, cellIndex, priorCellSettings, priorNodeSettings } = props;\n            let { nodes: branchNodes, nodeCallbacks: callbacks, actions, branchDeclaration: branchSettings } = budgetBranch;\n            let viewpointData = budgetBranch.state.viewpointData;\n            let budgetNode = branchNodes[nodeIndex];\n            // a hack to pass prior settings to child\n            if (priorCellSettings) {\n                budgetNode.priorCellSettings = priorCellSettings;\n            }\n            let { aspectName, viewpointName } = budgetNode;\n            let { onPortalCreation } = callbacks;\n            // ----------------------------------------------------\n            // ----------------[ create child ]--------------------\n            // copy path\n            let childdatapath = budgetNode.dataPath.slice();\n            let treeNodeData = budgetNode.treeNodeData;\n            if (!treeNodeData.Components) {\n                return;\n            }\n            let components = treeNodeData.Components;\n            let code = null;\n            if (treeNodeData && treeNodeData.SortedComponents && treeNodeData.SortedComponents[selectionrow]) {\n                let componentMetaDataFromSortedList = treeNodeData.SortedComponents[selectionrow];\n                code = componentMetaDataFromSortedList.Code;\n            }\n            if (code) childdatapath.push(code);else {\n                return;\n            }\n            let newnode = treeNodeData.Components[code];\n            if (!newnode.Components && !newnode.CommonDimension) {\n                return;\n            }\n            let newrange = Object.assign({}, budgetNode.yearsRange);\n            let newselections;\n            let newCellIndex = cellIndex;\n            if (priorNodeSettings) {\n                newselections = priorNodeSettings.yearSelections;\n                newCellIndex = priorNodeSettings.cellIndex;\n            } else {\n                newselections = Object.assign({}, budgetNode.yearSelections);\n            }\n            let newdatanode = Object(getbudgetnode[\"a\" /* default */])(viewpointData, childdatapath);\n            let newnodeconfigparms = {\n                viewpointName,\n                aspectName,\n                dataPath: childdatapath,\n                nodeIndex: nodeIndex + 1,\n                yearsRange: newrange,\n                yearSelections: newselections,\n                cellIndex: newCellIndex\n            };\n            actions.addNodeDeclaration(newnodeconfigparms);\n            setTimeout(() => {\n                onPortalCreation();\n            });\n        };\n        this.uid = parms.uid;\n    }\n    get nodes() {\n        let copy = [...this.state.branchNodes];\n        return copy; // new copy\n    }\n    get state() {\n        return this.getState();\n    }\n    get props() {\n        return this.getProps();\n    }\n    get branchDeclaration() {\n        return this.props.declarationData.branchesById[this.uid];\n    }\n}\n/* harmony default export */ var branch_class = __webpack_exports__[\"a\"] = (branch_class_BudgetBranch);\n\n//# sourceURL=webpack:///./ts/addons/explorer/classes/branch.class.tsx_+_4_modules?")},1028:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// getnodedatasets.tsx\n/*\n    a node consists of\n    - Index\n    - NamingConfigRef\n    - years\n    - Components\n    - CommonDimension\n    - SortedComponents\n    - SortedCommonDimension\n*/\nlet getBudgetNode = (node, path) => {\n    let components = node.Components;\n    for (let index of path) {\n        if (!components) {\n            return null;\n        }\n        node = components[index];\n        if (!node) {\n            // can happen legitimately switching from one aspect to another\n            return null;\n        }\n        components = node.Components;\n    }\n    return node;\n};\n/* harmony default export */ __webpack_exports__["a"] = (getBudgetNode);\n\n//# sourceURL=webpack:///./ts/addons/explorer/modules/getbudgetnode.tsx?')},1148:function(module,exports){eval("//Taken from http://there4development.com/blog/2012/05/02/google-chart-color-list/\n\nmodule.exports = [\n\t'#3366CC',\n\t'#DC3912',\n\t'#FF9900',\n\t'#109618',\n\t'#990099',\n\t'#3B3EAC',\n\t'#0099C6',\n\t'#DD4477',\n\t'#66AA00',\n\t'#B82E2E',\n\t'#316395',\n\t'#994499',\n\t'#22AA99',\n\t'#AAAA11',\n\t'#6633CC',\n\t'#E67300',\n\t'#8B0707',\n\t'#329262',\n\t'#5574A6',\n\t'#3B3EAC'\n];\n\n//# sourceURL=webpack:///./forked_modules/react-google-charts/DEFAULT_CHART_COLORS.js?")},1161:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 23 modules\nvar es = __webpack_require__(56);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Card/index.js\nvar Card = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/FontIcon/index.js\nvar FontIcon = __webpack_require__(115);\nvar FontIcon_default = /*#__PURE__*/__webpack_require__.n(FontIcon);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/IconButton/index.js\nvar IconButton = __webpack_require__(95);\nvar IconButton_default = /*#__PURE__*/__webpack_require__.n(IconButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Dialog/index.js\nvar Dialog = __webpack_require__(1017);\nvar Dialog_default = /*#__PURE__*/__webpack_require__.n(Dialog);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/FloatingActionButton/index.js\nvar FloatingActionButton = __webpack_require__(201);\nvar FloatingActionButton_default = /*#__PURE__*/__webpack_require__.n(FloatingActionButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/MenuItem/index.js\nvar MenuItem = __webpack_require__(211);\nvar MenuItem_default = /*#__PURE__*/__webpack_require__.n(MenuItem);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/RaisedButton/index.js\nvar RaisedButton = __webpack_require__(1020);\nvar RaisedButton_default = /*#__PURE__*/__webpack_require__.n(RaisedButton);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/svg-icons/content/add.js\nvar add = __webpack_require__(1157);\nvar add_default = /*#__PURE__*/__webpack_require__.n(add);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/svg-icons/content/remove.js\nvar remove = __webpack_require__(1156);\nvar remove_default = /*#__PURE__*/__webpack_require__.n(remove);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/DropDownMenu/index.js\nvar DropDownMenu = __webpack_require__(1019);\nvar DropDownMenu_default = /*#__PURE__*/__webpack_require__.n(DropDownMenu);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/Divider/index.js\nvar Divider = __webpack_require__(123);\nvar Divider_default = /*#__PURE__*/__webpack_require__.n(Divider);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/LinearProgress/index.js\nvar LinearProgress = __webpack_require__(1150);\nvar LinearProgress_default = /*#__PURE__*/__webpack_require__.n(LinearProgress);\n\n// EXTERNAL MODULE: ./node_modules/react-redux-toastr/lib/index.js\nvar lib = __webpack_require__(118);\n\n// EXTERNAL MODULE: ./node_modules/react-loadable/lib/index.js\nvar react_loadable_lib = __webpack_require__(213);\nvar react_loadable_lib_default = /*#__PURE__*/__webpack_require__.n(react_loadable_lib);\n\n// EXTERNAL MODULE: ./node_modules/react-router-dom/es/index.js + 13 modules\nvar react_router_dom_es = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/actions.tsx\nvar actions = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/classes/branch.class.tsx + 4 modules\nvar branch_class = __webpack_require__(1022);\n\n// EXTERNAL MODULE: ./ts/addons/explorer/reducers.tsx\nvar reducers = __webpack_require__(439);\n\n// EXTERNAL MODULE: ./node_modules/material-ui/SvgIcon/index.js\nvar SvgIcon = __webpack_require__(47);\nvar SvgIcon_default = /*#__PURE__*/__webpack_require__.n(SvgIcon);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/content/helpcontent.tsx\n// helpcontent.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorerbranch.tsx\n\n\n\n\nlet content = react["createElement"]("div", null, react["createElement"](Card["Card"], null, react["createElement"](Card["CardText"], null, "The best way to become familiar with the explorer is to ", react["createElement"]("span", { style: { fontStyle: \'italic\' } }, "play with it"), " (experiment). Once in a while, review the lists below. Click on any title below for details."), react["createElement"](Card["CardText"], null, "For some explanatory screencasts, see our ", react["createElement"]("a", { target: "_blank", href: "https://www.youtube.com/channel/UCatXKvLCA5qGkzj3jw8AQig" }, "YouTube channel"), ".")), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Dataset Options"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, "There are several dataset options available for charts:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Taxonomy")), react["createElement"]("dd", null, " a taxonomy is a classification scheme of a set of accounts."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Dataset")), react["createElement"]("dd", null, "alternate detailed datasets available for the selected Taxonomy (see the Budgetpedia project\'s ", react["createElement"]("a", { target: "_blank", href: "https://drive.google.com/drive/u/0/folders/0B208oCU9D8OuM2NmUk9XR1VCbEU" }, "research repository)")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Category")), react["createElement"]("dd", null, " particular aspects of the dataset, including Revenue, Expenses or Staffing"), react["createElement"]("dt", null, react["createElement"]("strong", null, "Prorated")), react["createElement"]("dd", null, " the beginnings of diagnostic analytics, using simple math to view the data compared with relevant related metrics, such as per person or per household"), react["createElement"]("dt", null, react["createElement"]("strong", null, "Inflation adjusted")), react["createElement"]("dd", null, " the datasets are updated annually to reflect the Bank of Canada\'s Inflation Calculator. This makes it possible to get historical perspectives that are meaningful in today\'s dollar terms.")), react["createElement"]("p", null, "Choices for the selections are interdependent. Toronto budgets have similar classifications for Revenue and Expenses for example, and therefore these can be viewed together. Financial statements on the other hand do not have similar classifications for Revenue and Expenses."), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Taxonomy")), " choices include:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Programs by function (budget)")), react["createElement"]("dd", null, "combines City of Toronto Agencies and Divisions into groups according to the nature of the services delivered (this is the default). The classification scheme above the Division/Agency level was developed by Budgetpedia project contributors."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Programs by org type (budget)")), react["createElement"]("dd", null, "more traditional: separates Agencies from Divisions, and generally by organizational structures. Groupings are closer to those found in City annual Budget Summaries."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses by function (actual), and Revenues by type (actual)")), react["createElement"]("dd", null, "These reporting structures are manadated by the province (and GAAP -- Generally Accepted Accounting Principles). They are comparable to other municipalities in the province. Summary groupings above the statment levels are added by the Budgetpedia project for easier access."), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses by type (actual)")), react["createElement"]("dd", null, "Expenses by type is a restatement of expenses by object of expenditure, such as materials, or Wages & Salaries. These categories cross all Divisions and Agencies, and therefore provide a general picture of the ways that money is spent.")), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Dataset")), " choices depend on the Taxonomy that is chosen."), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("em", null, "For budget taxonomies (both functional and org type), Versions"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Summary PDF Reports 2003 - 2016")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Detailed open data files 2011 - 2016")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Variance Reports"), " ", react["createElement"]("em", null, "[deferred]")))), react["createElement"]("dd", null, "The detailed files are generated by ", react["createElement"]("em", null, "PBFT"), " which stands for ", react["createElement"]("em", null, "Public Budget Formulation Tool"), " which is part of the City\'s new FPARS (Financial Planning Analysis and Reporting System) system"), react["createElement"]("dt", { style: { marginTop: "20px" } }, react["createElement"]("em", null, "For Viewpoint = Audited Expenses or Revenues, Source"), " includes:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Audited Statements 1998 - 2015")), react["createElement"]("dt", null, react["createElement"]("strong", null, "to come: Financial Information Returns")))), react["createElement"]("dd", null, "FIR for MMAH = Financial Information Returns for the Ontario Ministry of Municipal Affairs and Housing.")), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "CAtegory")), " choices depend on the Taxonomy and Version that is chosen."), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("em", null, "For Taxonomy = Budget (both functional and structural), Version = Summary or Detailed, Categories"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Revenue")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Staffing")))), react["createElement"]("dd", null, " All of these are based on City documents which have similar line items across all catagories. This makes the figures from all sources comparable."), react["createElement"]("dt", { style: { marginTop: "20px" } }, react["createElement"]("em", null, "For Taxononmies based on actuals, any Version, Categories"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Revenue (actual), or")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses (actual)")))), react["createElement"]("dd", null, "The classification schemes for these are different for each, and therefore they cannot be combined."), react["createElement"]("dt", { style: { marginTop: "20px" } }, react["createElement"]("em", null, "For Taxonomy = Expenses by type, Dataset = Audited Statements, Categories"), " include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Expenses")))), react["createElement"]("dd", null, "These come from notes to the audited financial statements.")), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Prorated")), " choices are common for all other choices, and include:"), react["createElement"]("dl", null, react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"]("strong", null, "Population: per resident")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Population: per 100,000 people")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per household")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per 40,000 households")), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per Ward (x 44)"), " an average per ward"), react["createElement"]("dt", null, react["createElement"]("strong", null, "Per Neighbourhood (x 4 x 44)"), " an average per neighbourhood, 4 per ward, about walking distance")))), react["createElement"]("hr", null), react["createElement"]("p", null, react["createElement"]("strong", null, react["createElement"]("em", null, "Inflation adjusted")), " is on by default, but can be turned off."), react["createElement"]("dl", null, react["createElement"]("dd", null, "This uses the Statistics Canada\'s estimated CPI for Toronto, to adjust historical figures in terms of recent currency valuations, for more meaningful trend analysis.")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Chart Options"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, " Chart options vary according to the time options selected. The time options available are:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "13", y: "13", width: "10", height: "10" })), " One year (default)"), react["createElement"]("dd", null, " Select a specific year to investigate."), react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "4", y: "13", width: "10", height: "10" }), react["createElement"]("rect", { x: "22", y: "13", width: "10", height: "10" })), " Two years"), react["createElement"]("dd", null, " Allows data for two years to be presented side by side for comparison."), react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("ellipse", { cx: "6", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "18", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "30", cy: "18", rx: "4", ry: "4" })), " All years (all available years)"), react["createElement"]("dd", null, " Shows all available years to investigate trends.")), react["createElement"]("p", null, "Specific years can be selected in the selection dropdowns under the charts."), react["createElement"]("hr", null), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "13", y: "13", width: "10", height: "10" })), " Chart options when one year is chosen include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "insert_chart"), " Column Chart"), react["createElement"]("dd", null, " This shows the basics of the components of the chart. Float the mouse over the column to see the number, or click on a column to drill down."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "donut_small"), " Donut Chart"), react["createElement"]("dd", null, " This shows the percentages of each number in relation to the whole.")))), react["createElement"]("hr", null), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("rect", { x: "4", y: "13", width: "10", height: "10" }), react["createElement"]("rect", { x: "22", y: "13", width: "10", height: "10" })), " Chart options when two years is chosen include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "insert_chart"), " Column Chart"), react["createElement"]("dd", null, " This offers a difference chart. The light colored bars are background bars."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "donut_small"), " A piechart difference chart"), react["createElement"]("dd", null, " This shows the differences between the two years chosen.")))), react["createElement"]("hr", null), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    }, viewBox: "0 0 36 36" }, react["createElement"]("ellipse", { cx: "6", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "18", cy: "18", rx: "4", ry: "4" }), react["createElement"]("ellipse", { cx: "30", cy: "18", rx: "4", ry: "4" })), " Chart options when all years is chosen include:"), react["createElement"]("dd", null, react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "timeline"), " Line Chart"), react["createElement"]("dd", null, " Basic time lines"), react["createElement"]("dt", null, react["createElement"](SvgIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle"\n    } }, react["createElement"]("path", { d: "M20,6c0-0.587-0.257-1.167-0.75-1.562c-0.863-0.69-2.121-0.551-2.812,0.312l-2.789,3.486L11.2,6.4  c-0.864-0.648-2.087-0.493-2.762,0.351l-4,5C4.144,12.119,4,12.562,4,13v3h16V6z" }), react["createElement"]("path", { d: "M20,19H4c-0.552,0-1,0.447-1,1s0.448,1,1,1h16c0.552,0,1-0.447,1-1S20.552,19,20,19z" })), " Area Chart"), react["createElement"]("dd", null, " Same data as timelines, but stacked."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "view_stream"), " Proportional Chart "), react["createElement"]("dd", null, " All lines add to 100%; individual amounts are shown in proportion to the whole.")))))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Context Options"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, " Context options are offered to provide contextual information for the data being viewed, and to afford the reader the opportunity to contribute to the process surrounding the budget. These are the options offered, found under each chart:"), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "info_outline"), " The ", react["createElement"]("em", null, "information"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " invokes a dialog containing information related to the current data. This could be brief explanations, links to related information, or links to websites which specialize in the subject matter. The idea is to allow the reader to discover more context and detail about the subject matter at hand."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "note"), " The ", react["createElement"]("em", null, "notes"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " invokes detailed technical information about the data presented, including source documents, exceptions, errors, and any relevant notes about the way the data was processed. If there are errors or exceptions in place, the note icon changes colour to red or orange, depending on severity."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "share"), " The ", react["createElement"]("em", null, "share"), " icon "), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " provides access to relevant social media sites, to allow readers to read or contribute to discussion about the subject at hand."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "announcement"), " The ", react["createElement"]("em", null, "announcement"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " provides the user with lists of calls to actions or meetings related to the subject matter, or to contribute their own call to action or meetings."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "view_list"), " The ", react["createElement"]("em", null, "data"), " icon"), react["createElement"]("dd", null, react["createElement"]("em", null, "[deferred]"), " brings up the data underlying the currently viewed chart, with an option to download same."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "swap_horiz"), " The ", react["createElement"]("em", null, "harmonize"), " icon"), react["createElement"]("dd", null, " allows the user to impose the settings made in the current chart onto the other charts in the row (", react["createElement"]("em", null, "Exhibit"), ").")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Cloning Features"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, "The Budget Explorer organizes charts into horizontal drill-down sequences which we call ", react["createElement"]("em", null, "Exhibits"), ". We allow for cloning and re-ordering these exhibits to allow for comparison, exploration, and publication. This clone contains all the option controls of the original. The clone is independent of the original."), react["createElement"]("dl", null, react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "add_circle_outline"), " Add a clone of the current Exhibit"), react["createElement"]("dd", null, "This icon when invoked adds a clone of the current row of charts below the current row. ", react["createElement"]("em", null, "The clone reproduces all of the components and selections of the current row.")), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "remove_circle_outline"), " Remove the current Exhibit"), react["createElement"]("dd", null, "This icon when invoked removes the current row of charts (cannot currently be undone)."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "arrow_upward"), " Move the current Exhibit up one position"), react["createElement"]("dd", null, "When mulitple rows (", react["createElement"]("em", null, "Exhibits"), ") exist, they can be re-ordered. The up arrow icon (to the upper right of the row title) moves the row up one position."), react["createElement"]("dt", null, react["createElement"](FontIcon_default.a, { style: {\n        height: "18px",\n        width: "18px",\n        padding: "0 3px",\n        border: "1px solid silver",\n        borderRadius: "5px",\n        verticalAlign: "middle",\n        fontSize: "18px"\n    }, className: "material-icons" }, "arrow_downward"), " Move the current Exhibit down one position"), react["createElement"]("dd", null, "When mulitple rows (", react["createElement"]("em", null, "Exhibits"), ") exist, they can be re-ordered. The down arrow icon (to the upper right of the row title) moves the row down one position.")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Actionable Features"), react["createElement"](Card["CardText"], { expandable: true, style: { paddingTop: "0px" } }, react["createElement"]("p", null, "We\'ve provided a few actionable features to help you find and share charts with friends and associates."), react["createElement"]("dl", null, react["createElement"]("dt", null, "Find"), react["createElement"]("dd", null, "This lets you find a chart by the title of the City account, or classification, that it highlights. Enter a key word that is likely to be found in a name."), react["createElement"]("dt", null, "Share"), react["createElement"]("dd", null, "This gives you a bitly (short) url that you can share with friends. When they go to that url, it will reproduce the current row of charts for them. A good basis for discussion."), react["createElement"]("dt", null, "Sources"), react["createElement"]("dd", null, "This provides a list of the source reports used to collect the data for the current viewpoint."), react["createElement"]("dt", null, "Printing charts"), react["createElement"]("dd", null, "To print charts, turn off options on each row of charts to remove clutter, and then use a browser utility like Fireshot for Chrome to print the entire visible page.")))));\n/* harmony default export */ var helpcontent = (content);\n// EXTERNAL MODULE: ./ts/addons/explorer/modules/utilities.tsx\nvar utilities = __webpack_require__(1016);\n\n// CONCATENATED MODULE: ./ts/addons/explorer/explorer.tsx\n// copyright (c) 2016 Henrik Bechmann, Toronto, MIT Licence\n// explorer.tsx\n/*\n    BUG: in _getBranchCloneSettings unselect parent child creates \'data not availble in child branch\'\n    BUG: \'Working\' sign persists when click fails to drill down,\n        such as when staff aspect is selected and max depth is reached\n    BUG: navigating to dialog help box loses bar selection\n    TODO:\n    - change terms Expenditures and Receipts to Cost Elements and Revenue Elements\n    - scroll down to new branch after hitting + sign\n    - do systematic check for error handling requirements; protect against\n        unexpected data (extrenal)\n    - move state to central store\n    ? Classes:\n        Explorer\n        ExporerNode\n        BudgetData = budgetdata -- package of aspects, lookup, and viewpoint data\n        BudgetExplorer (set of BudgetNodes)\n        BudgetNode (derive from chartconfig) Node within Hierarchy\n        BedgetChart (derive from chartcomfig) - presentation of BudgetNode\n        BudgetInfo explanation of budget node\n        BudgetPath series of drilldown budgetnodes\n        BudgetMatrix complete set of budget paths for BudgetExplorer\n*/\n\n\n\nvar { Component } = react;\n// doesn\'t require .d.ts...! (reference available in index.tsx)\n\n\n\n\n\n\n// import AutoComplete from \'material-ui/AutoComplete\'\n\n\n\n\n\n\n\n\n\n\nlet uuid = __webpack_require__(509); // use uuid.v4() for unique id\nlet jsonpack = __webpack_require__(1029);\nlet ReactGA = __webpack_require__(498);\nvar { Chart } = __webpack_require__(1021);\n// import ExplorerBranch from \'./components/explorerbranch\'\n// import SearchDialog from \'./components/searchdialog\'\nconst Loading = () => react["createElement"]("div", null, "Loading...");\nconst ExplorerBranch = react_loadable_lib_default()({\n    loader: () => Promise.all(/* import() | ExplorerBranch */[__webpack_require__.e(4), __webpack_require__.e(8)]).then(__webpack_require__.bind(null, 1160)),\n    loading: Loading\n});\nconst SearchDialog = react_loadable_lib_default()({\n    loader: () => Promise.all(/* import() | SearchDialog */[__webpack_require__.e(2), __webpack_require__.e(7)]).then(__webpack_require__.bind(null, 1163)),\n    loading: Loading\n});\n// import * as Actions from \'../../core/actions/actions\'\n\n\n\n\n\nlet Explorer = class extends Component {\n    constructor() {\n        // ---------------------[ Initialize ]-------------------------\n        super(...arguments);\n        this.state = {\n            budgetBranches: [],\n            dialogOpen: false,\n            searchDialogOpen: false,\n            storyboardDialogOpen: false,\n            analystNotesDialogOpen: false,\n            viewTaxonomyDialogOpen: false,\n            selectStoryboard: \'SELECT\'\n        };\n        this.toastrmessages = {\n            error: null,\n            warning: null,\n            success: null,\n            info: null\n        };\n        // Value    Notes\n        // args.category    String. Required. A top level category for these events. \n        //     E.g. \'User\', \'Navigation\', \'App Editing\', etc.\n        // args.action    String. Required. A description of the behaviour. \n        //     E.g. \'Clicked Delete\', \'Added a component\', \'Deleted account\', etc.\n        // args.label    String. Optional. More precise labelling of the related action. \n        //     E.g. alongside the \'Added a component\' action, we could add the name of a component as the label. E.g. \'Survey\', \'Heading\', \'Button\', etc.\n        // args.value    Int. Optional. A means of recording a numerical value against an event. \n        //     E.g. a rating, a score, etc.\n        // args.nonInteraction    Boolean. Optional. If an event is not triggered by a user interaction, \n        //     but instead by our code \n        //     (e.g. on page load, \n        //         it should be flagged as a nonInteraction event to avoid skewing bounce rate data.\n        // args.transport    String. Optional. \n        //     This specifies the transport mechanism with which hits will be sent. \n        //     Valid values include \'beacon\', \'xhr\', or \'image\'.\n        this.logEvent = parms => {\n            if (window.location.hostname == \'budgetpedia.ca\') {\n                ReactGA.event(parms);\n            }\n        };\n        this.setToast = (version, message) => {\n            this.toastrmessages[version] = message;\n        };\n        // ----------------------------[ Lifecycle operations ]-------------------------------\n        this.urlparms = null;\n        this.clearUrlParms = () => {\n            this.urlparms = null;\n        };\n        this.stories = null;\n        this.storiescleared = [];\n        this.clearStories = branch => {\n            this.storiescleared.push(branch);\n            if (this.storiescleared.length == this.stories.length) {\n                this.stories = null;\n                this.storiescleared = [];\n                this.setState({\n                    storyboardDialogOpen: false\n                });\n            }\n        };\n        this.storyboardDialog = () => react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Your storyboard is being prepared"), modal: true, open: this.state.storyboardDialogOpen, autoScrollBodyContent: false, contentStyle: { maxWidth: \'600px\' }, autoDetectWindowHeight: false }, react["createElement"]("div", null, "please wait while the charts are rendered...", react["createElement"]("br", null), "Toggle any row\'s \\"Show chart controls\\" to experiment with settings for that row", react["createElement"](LinearProgress_default.a, { mode: "indeterminate" })));\n        this.getUrlParameter = name => {\n            name = name.replace(/[\\[]/, \'\\\\[\').replace(/[\\]]/, \'\\\\]\');\n            var regex = new RegExp(\'[\\\\?&]\' + name + \'=([^&#]*)\');\n            var results = regex.exec(location.search);\n            return results === null ? \'\' : decodeURIComponent(results[1].replace(/\\+/g, \' \'));\n        };\n        /*\n            harmonizeBranches creates branches to match branch declarations\n            called from componentWillMount for initialization of imported datasets\n            and from componentWillReceiveProps to modify branch list\n        */\n        this.harmonizeBranchesToState = (budgetBranches, branchList, branchesById) => {\n            // reset state branches if a change is made\n            let change = false;\n            // delete branches that are no longer required\n            let newBranches = budgetBranches.filter(branch => {\n                return !!branchesById[branch.uid];\n            });\n            if (newBranches.length != budgetBranches.length) {\n                change = true;\n            }\n            // add branches not yet created\n            // let length = newBranches.length\n            for (let i = 0; i < branchList.length; i++) {\n                let uid = branchList[i];\n                let foundbranch = newBranches.filter(branch => {\n                    if (branch.uid == uid) return branch;\n                });\n                if (foundbranch.length == 0) {\n                    // branch not found, so add it\n                    if (!change) change = true;\n                    let budgetBranch = new branch_class["a" /* default */]({ uid });\n                    newBranches.push(budgetBranch);\n                }\n            }\n            // sort branches into correct order, per state branchlist\n            let sortedBranches = [];\n            for (let i = 0; i < branchList.length; i++) {\n                let uid = branchList[i];\n                let foundbranch = newBranches.filter(branch => {\n                    if (branch.uid == uid) return branch;\n                });\n                if (!(foundbranch.length == 1)) {\n                    console.error(\'System error -- unexpected mismatch between state branch list and explorer branch list\', branchList, newBranches);\n                    throw Error(\'System error -- unexpected mismatch between state branch list and explorer branch list\');\n                }\n                sortedBranches.push(foundbranch[0]);\n            }\n            if (!change) {\n                for (let i = 0; i < budgetBranches.length; i++) {\n                    if (budgetBranches[i].uid != sortedBranches[i].uid) {\n                        change = true;\n                        break;\n                    }\n                }\n            }\n            if (change) {\n                this.setState({\n                    budgetBranches: sortedBranches\n                });\n            }\n        };\n        // ------------------------[ ancillary ui ]---------------------------\n        this.handleDialogOpen = e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.logEvent({\n                category: \'Explorer\',\n                action: \'Show help\'\n            });\n            this.setState({\n                dialogOpen: true\n            });\n        };\n        this.handleDialogClose = () => {\n            this.setState({\n                dialogOpen: false\n            });\n        };\n        // ---------------[ create action calls versions for currying (branchid) ]---------------\n        // node consumer\n        this.updateNode = branchuid => nodeuid => this.props.updateNode(branchuid, nodeuid);\n        this.changeTab = branchuid => (nodeuid, tabvalue) => this.props.changeTab(branchuid, nodeuid, tabvalue);\n        this.addCellDeclarations = branchuid => (nodeuid, settingslist) => this.props.addCellDeclarations(branchuid, nodeuid, settingslist);\n        this.normalizeCellYearDependencies = branchuid => (nodeuid, cellList, yearsRange) => this.props.normalizeCellYearDependencies(branchuid, nodeuid, cellList, yearsRange);\n        // cell consumer\n        this.updateCellTimeScope = branchuid => nodeuid => (celluid, selection) => this.props.updateCellTimeScope(branchuid, nodeuid, celluid, selection);\n        this.updateCellChartSelection = branchuid => nodeuid => (celluid, selection) => this.props.updateCellChartSelection(branchuid, nodeuid, celluid, selection);\n        this.updateCellYearSelections = branchuid => nodeuid => (leftyear, rightyear) => this.props.updateCellYearSelections(branchuid, nodeuid, leftyear, rightyear);\n        this.updateCellChartCode = branchuid => nodeuid => (celluid, explorerChartCode) => this.props.updateCellChartCode(branchuid, nodeuid, celluid, explorerChartCode);\n        // ----------------------------[ ui responses ]------------------------------\n        this.onExpandChange = expanded => {\n            return;\n            // TODO: change background color of title if it is collapsed\n            // this.props.resetLastAction()\n        };\n        this.branchMoveUp = branchuid => {\n            this.props.branchMoveUp(branchuid);\n        };\n        this.branchMoveDown = branchuid => {\n            this.props.branchMoveDown(branchuid);\n        };\n        this._getBranchCloneSettings = refbranchid => {\n            let declarationData = this.props.declarationData;\n            let clones = {\n                branch: {},\n                nodes: {},\n                cells: {}\n            };\n            let uidmap = {};\n            // clone branch\n            uidmap[refbranchid] = uuid.v4();\n            clones.branch[refbranchid] = this._getClone(declarationData.branchesById[refbranchid]);\n            // console.log(\'clones\', clones)\n            // clone branch nodes\n            for (let nodeid of clones.branch[refbranchid].nodeList) {\n                let nodeobject = declarationData.nodesById[nodeid];\n                // console.log(\'nodeobject\', nodeobject)\n                clones.nodes[nodeid] = this._getClone(nodeobject);\n                uidmap[nodeid] = uuid.v4();\n            }\n            // clone node cells\n            for (let nodeid in clones.nodes) {\n                for (let cellid of clones.nodes[nodeid].cellList) {\n                    clones.cells[cellid] = this._getClone(declarationData.cellsById[cellid]);\n                    uidmap[cellid] = uuid.v4();\n                    clones.cells[cellid].celluid = uidmap[cellid]; // TODO: this reference shouldn\'t be in cell declaration!!\n                }\n            }\n            // console.log(\'cell clones\',clones.cells)\n            // map old uid\'s to new uid\'s\n            let newclones = {\n                newbranchid: uidmap[refbranchid],\n                branch: {},\n                nodes: {},\n                cells: {}\n            };\n            let newrefbranchid = uidmap[refbranchid];\n            newclones.branch[newrefbranchid] = clones.branch[refbranchid];\n            let oldlist = newclones.branch[newrefbranchid].nodeList;\n            let newlist = [];\n            for (let id of oldlist) {\n                newlist.push(uidmap[id]);\n            }\n            newclones.branch[newrefbranchid].nodeList = newlist;\n            for (let id in clones.nodes) {\n                let newid = uidmap[id];\n                let nodeclone = newclones.nodes[newid] = clones.nodes[id];\n                let oldlist = nodeclone.cellList;\n                let newlist = [];\n                for (let cellid of oldlist) {\n                    newlist.push(uidmap[cellid]);\n                }\n                nodeclone.cellList = newlist;\n            }\n            for (let oldid in clones.cells) {\n                newclones.cells[uidmap[oldid]] = clones.cells[oldid];\n            }\n            return newclones;\n        };\n        this._getClone = object => {\n            return JSON.parse(JSON.stringify(object));\n        };\n        this.addBranch = refbranchuid => {\n            let cloneSettings = this._getBranchCloneSettings(refbranchuid);\n            this.logEvent({\n                category: \'ExplorerBranch\',\n                action: \'Add branch\'\n            });\n            this.props.cloneBranchDeclaration(refbranchuid, cloneSettings);\n            this.onCloneCreation();\n        };\n        // crude scroll down on branch clone\n        this.onCloneCreation = () => {\n            setTimeout(() => {\n                let adjustment = 400;\n                let frames = 60;\n                let t = 1 / frames;\n                let counter = 0;\n                let base = 0;\n                let tick = () => {\n                    counter++;\n                    let factor = this.easeOutCubic(counter * t);\n                    let scrollinterval = adjustment * factor;\n                    window.scrollBy(0, scrollinterval - base);\n                    base = scrollinterval;\n                    if (counter < frames) {\n                        requestAnimationFrame(tick);\n                    }\n                };\n                requestAnimationFrame(tick);\n            }, 1000); // give charts some time to render and take up space\n        };\n        // TODO: should be in utilities\n        // from https://github.com/DelvarWorld/easing-utils/blob/master/src/easing.js\n        this.easeOutCubic = t => {\n            const t1 = t - 1;\n            return t1 * t1 * t1 + 1;\n        };\n        this.removeBranch = branchuid => {\n            this.props.removeBranchDeclaration(branchuid);\n        };\n        this.removeBranches = () => {\n            this.props.removeBranches();\n        };\n        this.findParameters = {\n            applySearchBranchSettings: null\n        };\n        // ==================[ FIND CHART ]=======================\n        this.handleSearchDialogOpen = (e, applySearchBranchSettings) => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.findParameters.applySearchBranchSettings = applySearchBranchSettings;\n            // this.resetSelectionParameters()\n            this.setState({\n                searchDialogOpen: true\n            });\n        };\n        this.handleSearchDialogClose = () => {\n            this.setState({\n                searchDialogOpen: false\n            });\n        };\n        // =======================[ Storyboard Creation ]=====================\n        this.storyBoards = null;\n        this.getStoryboardsPromise = () => {\n            let filespec = \'./db/repositories/toronto/storyboards/storyboards.json\';\n            let promise = new Promise((resolve, reject) => {\n                fetch(filespec).then(response => {\n                    if (response.ok) {\n                        // console.log(\'response for \' + path,response)\n                        try {\n                            let json = response.json().then(json => {\n                                resolve(json);\n                            }).catch(reason => {\n                                let msg = \'failure to resolve \' + filespec + \' \' + reason;\n                                console.log(msg);\n                                reject(msg);\n                            });\n                        } catch (e) {\n                            console.log(\'error \' + filespec, e.message);\n                            reject(\'failure to load \' + filespec);\n                        }\n                    } else {\n                        reject(\'could not load file \' + filespec);\n                    }\n                }).catch(reason => {\n                    reject(reason + \' \' + filespec);\n                });\n            });\n            return promise;\n        };\n        this.onSelectStoryboard = value => {\n            let showdialog = true;\n            if (value == \'SELECT\') {\n                showdialog = false;\n            }\n            this.logEvent({\n                category: \'Explorer\',\n                action: \'Select storyboard\',\n                label: value\n            });\n            this.setState({\n                selectStoryboard: value,\n                storyboardDialogOpen: showdialog\n            });\n            if (value == \'SELECT\') {\n                return;\n            }\n            this.processStoryboardSelection(value);\n        };\n        this.processStoryboardSelection = selection => {\n            // console.log(\'processing selection\',selection)\n            if (!this.storyBoards) {\n                let promise = this.getStoryboardsPromise();\n                promise.then(json => {\n                    this.storyBoards = json;\n                    if (!this._doProcessStoryboardSelection(selection)) {\n                        this.setState({\n                            selectStoryboard: \'SELECT\',\n                            storyboardDialogOpen: false\n                        });\n                        if (this.state.budgetBranches.length == 0) {\n                            this.resetBranches();\n                        }\n                    }\n                }).catch(reason => {\n                    console.error(\'error in processStoryboardSelection\', reason);\n                    this.setState({\n                        selectStoryboard: \'SELECT\',\n                        storyboardDialogOpen: false\n                    });\n                });\n            } else {\n                if (!this._doProcessStoryboardSelection(selection)) {\n                    this.setState({\n                        selectStoryboard: \'SELECT\',\n                        storyboardDialogOpen: false\n                    });\n                }\n            }\n        };\n        /*\n            each story consists of the following properties\n            {\n                viewpoint:"", FUNCTIONAL, STRUCTURAL, ACTUALEXPENSES, ACTUALREVENUES, EXPENDITURES\n                source:"",\n                    for FUNCTIONAL or STRUCTURAL:\n                        SUMMARY, PBFT, VARIANCE\n                    otherwise source = viewpoint\n                level:"",\n        \n                    for FUNCTIONAL or STRUCTURAL Expenses:\n                        Taxonomy, Program, Service, Activity, Expense\n        \n                    for FUNCTIONAL or STRUCTURAL Revenues:\n                        Taxonomy, Program, Service, Activity, Revenue\n        \n                    for FUNCTIONAL or STRUCTURAL Staffing:\n                        Taxonomy, Program, Permanence\n        \n                    for ACTUALEXPENSES Expenses\n                        Taxonomy, Expense\n        \n                    for ACTUALREVENUES Revenues\n                        Taxonomy, Revenue\n        \n                    for EXPENDITURES Expenditure\n                        Taxonomy, Expenditure\n                code:"",\n                aspect:"",\n                    for FUNCTIONAL or STRUCTURAL:\n                        Expenses, Revenues, Staffing\n                    for ACTUALEXPENSES,\n                        Expenses\n                    for ACTUALREVENUES:\n                        Revenues\n                    for EXPENDITURES:\n                        Expenditure\n                name:""\n            }\n        */\n        this._doProcessStoryboardSelection = selection => {\n            let storyboard = this.storyBoards.storyboards[selection];\n            if (!storyboard) {\n                lib["toastr"].error(\'storyboard not found for \' + selection);\n                return false;\n            }\n            // console.log(\'processing story board\',selection,storyboard)\n            let stories = storyboard.stories;\n            this.stories = stories;\n            if (!stories) {\n                lib["toastr"].error(\'stories not found for storyboard \' + selection);\n                return false;\n            }\n            // clear all branches\n            if (this.state.budgetBranches.length > 0) {\n                this.removeBranches();\n                this.setState({\n                    budgetBranches: []\n                });\n            }\n            let explorer = this;\n            setTimeout(() => {\n                for (let story of stories) {\n                    // create branch\n                    let defaultSettings = JSON.parse(JSON.stringify(explorer.props.declarationData.defaults.branch));\n                    let settings = Object.assign(defaultSettings, {\n                        viewpoint: story.viewpoint,\n                        version: story.source,\n                        aspect: story.aspect,\n                        story: story,\n                        showOptions: false\n                    });\n                    explorer.props.addBranchDeclaration(null, settings); // change state \n                }\n            });\n            return true;\n        };\n        this.resetBranches = () => {\n            let value = \'SELECT\';\n            this.setState({\n                selectStoryboard: value\n            });\n            this.removeBranches();\n            let defaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.branch));\n            this.props.addBranchDeclaration(null, defaultSettings); // change state        \n        };\n        this._inputonfocus = () => {\n            this._inputfieldref.setSelectionRange(0, this._inputfieldref.value.length);\n        };\n        this.shareStoryboard = () => {\n            let longurl = this._getShareUrl();\n            // console.log(\'long url\',longurl)\n            let toastrComponent = () => react["createElement"]("div", { style: { width: "300px" } }, react["createElement"]("p", { style: { width: "240px" } }, "To share this storyboard (not including any changes you may have made), copy the url below, and send it to a friend."), react["createElement"]("input", { ref: node => {\n                    this._inputfieldref = node;\n                }, onFocus: this._inputonfocus, style: { width: "310px", marginLeft: \'-60px\' }, value: longurl, readOnly: true }));\n            let toastrOptions = {\n                icon: react["createElement"](FontIcon_default.a, { className: "material-icons" }, "share"),\n                component: toastrComponent\n            };\n            lib["toastr"].message(\'Share\', toastrOptions);\n        };\n        this._getShareUrl = () => {\n            this.logEvent({\n                category: \'Explorer\',\n                action: \'Share storyboard\',\n                label: this.state.selectStoryboard\n            });\n            return \'http://\' + location.hostname + \'/explorer?storyboard=\' + this.state.selectStoryboard;\n        };\n        // =============================================================================\n        // ---------------------------[ View Taxonomy/dataset ]-----------------------\n        this.viewtaxonomydata = {\n            options: {\n                allowHtml: true,\n                allowCollapse: false\n            }\n        };\n        this.taxonomyleafnodeselection = null;\n        // TODO: should log event for google analytics\n        this.onCallViewTaxonomy = (viewpointdata, viewpointselection, applytaxonomyselection) => {\n            let self = this;\n            self.viewtaxonomydata.applytaxonomyselection = applytaxonomyselection;\n            self.taxonomyleafnodeselection = null;\n            window[\'taxonomyCall\'] = function (value) {\n                self.taxonomyleafnodeselection = value;\n                // console.log(\'set taxonomynodeselection\',value)\n            };\n            // console.log(\'viewpointdata,viewpointselection\',viewpointdata, viewpointselection)\n            this.viewtaxonomydata.viewpointdata = viewpointdata;\n            this.viewtaxonomydata.viewpointselection = viewpointselection;\n            this.setViewTaxonomyData();\n            this.setState({\n                viewTaxonomyDialogOpen: true\n            });\n        };\n        this.setViewTaxonomyData = () => {\n            let viewpointdata = this.viewtaxonomydata.viewpointdata;\n            let data = [];\n            data.push([\'Code\', \'Parent\', \'Tooltip\']);\n            let code = viewpointdata.NamingConfigRef;\n            data.push([{ v: code, f: viewpointdata.Meta.NamingConfigurations[code].Contents.Alias }, \'\', \'\']);\n            this.setViewTaxonomyRow(code, viewpointdata.Components, data);\n            this.viewtaxonomydata.data = data;\n        };\n        // recursive\n        this.setViewTaxonomyRow = (parentcode, components, data) => {\n            let baselines = { string: \'\' };\n            for (let code in components) {\n                let component = components[code];\n                if (component.Baseline) {\n                    // console.log(\'single baseline\',component)\n                    if (!baselines.code) {\n                        baselines.code = code;\n                    }\n                    baselines.string += \'<div style="border:2px solid gray;margin-bottom:3px;border-radius:6px;font-size:smaller" onClick="taxonomyCall(\\\'\' + code + \'\\\')">\' + component.Name + \'</div>\';\n                } else {\n                    data.push([{ v: code, f: component.Name }, parentcode, \'\']);\n                    this.setViewTaxonomyRow(code, component.Components, data);\n                }\n            }\n            // console.log(\'baselines\',baselines)\n            if (baselines.code) {\n                data.push([{ v: baselines.code, f: \'<div style="background-color:pink;height:100%">\' + baselines.string + \'</div>\' }, parentcode, \'\']);\n            }\n        };\n        this.setSelectionBranchNodes = selection => {\n            setTimeout(() => {\n                let selectedleafnode = null;\n                let selectedtreenode = null;\n                let selectednoderow = selection[0].row;\n                let datanode = this.viewtaxonomydata.data[selectednoderow + 1];\n                if (this.taxonomyleafnodeselection) {\n                    // an html injected div has been clicked\n                    selectedleafnode = this.taxonomyleafnodeselection;\n                    selectedtreenode = datanode[1]; // parent\n                } else {\n                    let substr = datanode[0].f.substring(0, 4);\n                    if (substr == \'<div\') {\n                        // a constructed node. get parent\n                        selectedtreenode = datanode[1]; // parent\n                    } else {\n                        // get current code\n                        selectedtreenode = datanode[0].v; // node code\n                    }\n                }\n                let parms = {\n                    selectedleafnode,\n                    selectedtreenode\n                };\n                this.viewtaxonomydata.applytaxonomyselection(parms);\n                // console.log(\'viewtaxonomydata.data\',this.viewtaxonomydata.data)\n                // console.log(\'selectedleafnode, selectedtreenode, chart selection, taxonomynodeselection\', selectedleafnode, selectedtreenode, selection, this.taxonomyleafnodeselection)\n            });\n        };\n        this.taxonomyevents = () => {\n            let self = this;\n            return [{\n                eventName: \'select\',\n                callback: (Chart, err) => {\n                    let chart = Chart.chart;\n                    let selection = chart.getSelection();\n                    self.setState({\n                        viewTaxonomyDialogOpen: false\n                    });\n                    if (selection.length) {\n                        self.setSelectionBranchNodes(selection);\n                    }\n                }\n            }];\n        };\n        this.taxonomychart = () => {\n            // console.log(\'viewtaxonomydata\',this.viewtaxonomydata)\n            return this.viewtaxonomydata.data ? react["createElement"](Chart, { chartType: \'OrgChart\', options: this.viewtaxonomydata.options, chartEvents: this.taxonomyevents(), data: this.viewtaxonomydata.data }) : null;\n        };\n        this.viewTaxonomyDialog = () => {\n            if (!this.viewtaxonomydata.viewpointdata) return null;\n            let taxonomyselection = this.viewtaxonomydata.viewpointselection.viewpoint;\n            return react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Chart view of selected dataset tree (", react["createElement"]("span", { style: { fontStyle: \'italic\' } }, this.viewtaxonomydata.viewpointselection.name), ")"), modal: false, onRequestClose: () => {\n                    this.setState({\n                        viewTaxonomyDialogOpen: false\n                    });\n                }, open: this.state.viewTaxonomyDialogOpen, contentStyle: { width: \'90%\', maxWidth: \'none\', height: \'90%\', maxHeight: \'none\' }, autoScrollBodyContent: true }, react["createElement"](IconButton_default.a, { style: {\n                    top: 0,\n                    right: 0,\n                    padding: 0,\n                    height: "36px",\n                    width: "36px",\n                    position: "absolute",\n                    zIndex: 2\n                }, onClick: () => {\n                    this.setState({\n                        viewTaxonomyDialogOpen: false\n                    });\n                } }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", { style: { height: window.innerHeight } }, react["createElement"]("div", { style: { fontStyle: \'italic\', fontSize: \'smaller\' } }, "click on a cell to view chart. ", react["createElement"]("div", { style: {\n                    display: \'inline-block\',\n                    height: \'9px\',\n                    width: \'9px\',\n                    backgroundColor: \'pink\',\n                    border: \'1px solid gray\'\n                } }), " = ", taxonomyselection == \'FUNCTIONAL\' || taxonomyselection == \'STRUCTURAL\' ? \'City Divisions and Agencies\' : \'Source document base categories\'), this.taxonomychart()));\n        };\n        // ===================================================================\n        // ---------------------------[ Analyst Notes ]-----------------------\n        this.analystNotesDialog = () => react["createElement"](Dialog_default.a, { title: react["createElement"]("div", { style: { padding: \'12px 0 0 12px\' } }, "Budget Analyst Notes"), modal: false, onRequestClose: () => {\n                this.onSelectAnalystNotes(null, null);\n            }, open: this.state.analystNotesDialogOpen, autoScrollBodyContent: true }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: () => {\n                this.setState({\n                    analystNotesDialogOpen: false\n                });\n            } }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), react["createElement"]("div", null, this.getAnalystNotesDisplay()));\n        this.getAnalystNotesDisplay = () => {\n            let display = [];\n            display.push(this.getDisplayRoot());\n            return display;\n        };\n        this.getDisplayRoot = () => {\n            let display = this.analystnotes.displaylist;\n            let displayroot = display[0] || {};\n            return react["createElement"]("div", { key: "main" }, react["createElement"]("h3", null, displayroot.name), this.getDisplayTail(displayroot));\n        };\n        this.getDisplayTail = displayobj => {\n            if (displayobj.subset) {\n                return this.getDisplaySubset(displayobj.subset);\n            } else if (displayobj.notes) {\n                return this.getDisplayNotes(displayobj.notes);\n            } else {\n                return react["createElement"]("div", null, "no notes to display");\n            }\n        };\n        this.getDisplaySubset = subset => {\n            let elements = [];\n            for (let index in subset) {\n                let displayobj = subset[index];\n                elements.push(react["createElement"]("div", { key: index, style: {\n                        borderLeft: \'1px solid silver\',\n                        marginLeft: \'3px\',\n                        paddingLeft: \'3px\'\n                    } }, react["createElement"]("h4", { style: displayobj.notes ? { fontStyle: \'italic\' } : null }, displayobj.name), this.getDisplayTail(displayobj)));\n            }\n            return elements;\n        };\n        this.getDisplayNotes = notes => {\n            let elements = [];\n            for (let index in notes) {\n                let note = notes[index];\n                elements.push(react["createElement"]("div", { key: index }, "- ", react["createElement"]("a", { target: "_blank", href: note.link }, note.title)));\n            }\n            if (elements.length == 0) {\n                elements.push(react["createElement"]("div", { key: "none", style: { fontStyle: \'italic\' } }, "(no notes)"));\n            }\n            return elements;\n        };\n        // TODO: This needs to be hooked into event that opens analyst notes window!!\n        this.onSelectAnalystNotes = (code, index) => {\n            if (code !== null) {\n                this.logEvent({\n                    category: \'Explorer\',\n                    action: \'Select analyst notes\',\n                    label: code\n                });\n            }\n            this.setState({\n                analystNotesDialogOpen: false\n            });\n            // open window for analyst notes\n        };\n        this.analystnotes = {\n            nodepath: null,\n            taxonomies: {},\n            analystnoteslist: null,\n            displaylist: {}\n        };\n        // TODO: should log this for google analytics\n        this.onCallAnalystNotes = (taxonomycode, nodepath) => {\n            this.analystnotes.nodepath = nodepath;\n            // console.log(\'taxonomy code for call analyst notes\',taxonomycode, nodepath)\n            if (this.analystnotes.taxonomies[taxonomycode]) {\n                let json = this.analystnotes.taxonomies[taxonomycode];\n                this.processTaxonomyTree(json);\n            } else {\n                let taxonomyPromise = this.filePromise(\'viewpoints/\' + taxonomycode.toLowerCase() + \'.json\');\n                let explorer = this;\n                taxonomyPromise.then(json => {\n                    this.processTaxonomyTree(json);\n                }).catch(reason => {\n                    lib["toastr"].error(\'could not find analyst notes framework:\' + reason);\n                });\n            }\n        };\n        this.processTaxonomyTree = taxonomyTree => {\n            // console.log(\'taxonomy tree\', taxonomyTree)\n            if (this.analystnotes.analystnoteslist) {\n                this.displayAnalystChoices(taxonomyTree);\n            } else {\n                let listPromise = this.filePromise(\'resources/analystnotes.json\');\n                let explorer = this;\n                listPromise.then(json => {\n                    this.analystnotes.analystnoteslist = json;\n                    // console.log(\'analyst notes loaded\', json)\n                    this.displayAnalystChoices(taxonomyTree);\n                }).catch(reason => {\n                    lib["toastr"].error(\'could not find analyst notes list:\' + reason);\n                });\n            }\n        };\n        this.displayAnalystChoices = taxonomytree => {\n            let nodepath = this.analystnotes.nodepath;\n            let headnode = null;\n            let count = 0;\n            let tailbranch = taxonomytree;\n            while (true) {\n                if (count == nodepath.length) break;\n                if (!tailbranch.Components) break;\n                headnode = nodepath[count];\n                // console.log(\'headnode, tailbranch\', headnode, tailbranch)\n                if (tailbranch.Components[headnode]) {\n                    tailbranch = tailbranch.Components[headnode];\n                } else {\n                    tailbranch = null;\n                    break;\n                }\n                count++;\n                // console.log(\'count\',count)\n            }\n            if (!tailbranch) {\n                lib["toastr"].error(\'unable to find path in taxononmy\');\n                return;\n            }\n            // console.log(\'headnode, tailbranch\',headnode,tailbranch)\n            let displaylist = this.getDisplayList(headnode, tailbranch, taxonomytree);\n            // console.log(\'displaylist\',displaylist)\n            this.analystnotes.displaylist = displaylist;\n            this.setState({\n                analystNotesDialogOpen: true\n            });\n        };\n        this.getDisplayList = (headnode, tailbranch, taxonomytree) => {\n            let analystnotes = this.analystnotes.analystnoteslist;\n            let displaylist = [];\n            let displayset = this.getDisplaySet(headnode, tailbranch, taxonomytree, analystnotes);\n            displaylist.push(displayset);\n            return displaylist;\n        };\n        this.getDisplaySet = (headnode, tailbranch, taxonomytree, analystnotes) => {\n            let displayset = {};\n            try {\n                if (tailbranch.Baseline) {\n                    let noteset = analystnotes[headnode];\n                    displayset.code = headnode;\n                    if (!noteset) {\n                        displayset.name = headnode;\n                        displayset.notes = [];\n                    } else {\n                        displayset.name = noteset.name;\n                        displayset.notes = noteset.links;\n                    }\n                } else {\n                    let subset = [];\n                    for (let subcode in tailbranch.Components) {\n                        let displayset = this.getDisplaySet(subcode, tailbranch.Components[subcode], taxonomytree, analystnotes);\n                        subset.push(displayset);\n                    }\n                    displayset.code = headnode;\n                    if (!headnode) {\n                        let contents = taxonomytree.Meta.NamingConfigurations[taxonomytree.NamingConfigRef].Contents;\n                        displayset.name = contents.Alias || contents.Name;\n                    } else {\n                        displayset.name = taxonomytree.Meta.Lookups.Taxonomy[headnode];\n                    }\n                    displayset.subset = subset;\n                }\n            } catch (e) {\n                console.error(\'error!\', e);\n            }\n            return displayset;\n        };\n        this.filePromise = path => {\n            let root = \'./db/repositories/toronto/\';\n            let filespec = root + path;\n            let promise = new Promise((resolve, reject) => {\n                fetch(filespec).then(response => {\n                    if (response.ok) {\n                        // console.log(\'response for \' + path,response)\n                        try {\n                            let json = response.json().then(json => {\n                                resolve(json);\n                            }).catch(reason => {\n                                let msg = \'failure to resolve \' + path + \' \' + reason;\n                                console.log(msg);\n                                reject(msg);\n                            });\n                        } catch (e) {\n                            console.log(\'error \' + path, e.message);\n                            reject(\'failure to load \' + path);\n                        }\n                    } else {\n                        reject(\'could not load file \' + path);\n                    }\n                }).catch(reason => {\n                    reject(reason + \' \' + path);\n                });\n            });\n            return promise;\n        };\n    }\n    componentWillMount() {\n        // console.log(\'explorer props location.query\',this.props.location.query)\n        // console.log(\'window.location,state, props\',window.location, this.state, this.props)\n        // if (!this.props.declarationData.onetimenotification) {\n        //     this.toastrmessages.info = "Click or tap on any chart column to drill down (except as noted)."\n        //     this.props.onetimeNotification()\n        // }\n        let query = {\n            search: this.props.location.search,\n            branch: this.getUrlParameter(\'branch\'),\n            settings: this.getUrlParameter(\'settings\'),\n            hash: this.getUrlParameter(\'hash\'),\n            storyboard: this.getUrlParameter(\'storyboard\')\n        };\n        // console.log(\'query\',query)\n        let branchdata, settingsdata, hash;\n        if (query.branch && query.settings && query.hash) {\n            branchdata = jsonpack.unpack(query.branch);\n            settingsdata = jsonpack.unpack(query.settings);\n            let newhash = utilities["c" /* hashCode */](query.branch + query.settings).toString();\n            if (newhash == query.hash) {\n                this.urlparms = {\n                    branchdata,\n                    settingsdata\n                };\n                let defaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.branch));\n                // console.log(\'branchdata, settingsdata,defaultSettings\',branchdata,settingsdata,defaultSettings)\n                let querysettings = {\n                    inflationAdjusted: branchdata.ad,\n                    aspect: branchdata.as,\n                    prorata: branchdata.pr,\n                    repository: branchdata.g,\n                    version: branchdata.ve,\n                    viewpoint: branchdata.vi,\n                    showOptions: true\n                };\n                let settings = Object.assign(defaultSettings, querysettings);\n                this.props.addBranchDeclaration(null, settings); // change state\n                return;\n            } else {\n                this.toastrmessages.error = \'the url parameters have apparently been damaged. Using defaults instead...\';\n                console.error(\'url hash no match\', lib["toastr"], query.hash, newhash);\n            }\n        }\n        if (query && query.storyboard) {\n            let value = query.storyboard;\n            this.setState({\n                selectStoryboard: value,\n                storyboardDialogOpen: true\n            });\n            this.processStoryboardSelection(value);\n            return;\n        }\n        let { branchList, branchesById } = this.props.declarationData;\n        if (branchList.length == 0) {\n            // initialize explorer with first branch\n            // this.freshstart = true\n            let defaultSettings = JSON.parse(JSON.stringify(this.props.declarationData.defaults.branch));\n            this.props.addBranchDeclaration(null, defaultSettings); // change state\n        } else {\n            // harmonize branch instances to branch declarations\n            let { branchList, branchesById } = this.props.declarationData;\n            let budgetBranches = [...this.state.budgetBranches];\n            this.harmonizeBranchesToState(budgetBranches, branchList, branchesById);\n        }\n    }\n    // componentDidMount() {\n    //     let query = this.props.location\n    //     if (query && query.query && query.query.storyboard) {\n    //         setTimeout(()=>{\n    //             this.onSelectStoryboard(query.query.storyboard)\n    //         },5000)\n    //     }\n    // }\n    // start with open reminder to user that click on charts drills down\n    componentWillUnmount() {\n        this.props.resetLastAction(); // clear sentinals for unmount //TODO verify this!\n    }\n    componentDidUpdate() {\n        let { branchList, branchesById } = this.props.declarationData;\n        let budgetBranches = [...this.state.budgetBranches];\n        this.harmonizeBranchesToState(budgetBranches, branchList, branchesById);\n        let { toastrmessages } = this;\n        for (let version in toastrmessages) {\n            let msg = toastrmessages[version];\n            if (msg) {\n                toastrmessages[version] = null;\n                lib["toastr"][version](msg);\n            }\n        }\n    }\n    // ===================================================================\n    // ---------------------------[ Render ]------------------------------ \n    render() {\n        let showhelp = react["createElement"](RaisedButton_default.a, { label: "Help", style: { margin: \'3px 6px 0 6px\' }, type: "button", onClick: this.handleDialogOpen, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "help_outline") });\n        let showanalystnotes = react["createElement"](RaisedButton_default.a, { label: "Latest Analyst Notes", style: { margin: \'3px 6px 0 6px\' }, type: "button", onClick: () => {\n                this.onCallAnalystNotes(\'FUNCTIONAL\', []);\n            } });\n        let showvideos = react["createElement"](RaisedButton_default.a, { label: "Videos", style: { margin: \'3px 6px 0 6px\' }, type: "button", onClick: () => {\n                this.logEvent({\n                    category: \'Explorer\',\n                    action: \'Show videos\'\n                });\n                window.open(\'https://www.youtube.com/channel/UCatXKvLCA5qGkzj3jw8AQig\', \'_blank\');\n            }, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5\' }, className: "material-icons" }, "videocam") });\n        let explorer = this;\n        let dialogbox = react["createElement"](Dialog_default.a, { title: "Budget Explorer Options", modal: false, open: explorer.state.dialogOpen, onRequestClose: explorer.handleDialogClose, bodyStyle: { padding: \'12px\' }, autoScrollBodyContent: true, contentStyle: { width: \'95%\', maxWidth: \'600px\' } }, react["createElement"](IconButton_default.a, { style: {\n                top: 0,\n                right: 0,\n                padding: 0,\n                height: "36px",\n                width: "36px",\n                position: "absolute",\n                zIndex: 2\n            }, onClick: explorer.handleDialogClose }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "close")), helpcontent);\n        // -----------[ BRANCH SEGMENT]-------------\n        let branchSegments = () => {\n            let budgetBranches = explorer.state.budgetBranches;\n            // console.log(\'budgetBranches\',budgetBranches)\n            // map over budgetBranches state\n            let segments = budgetBranches.map((budgetBranch, branchIndex) => {\n                let urlparms = null;\n                if (branchIndex == 0 && this.urlparms) {\n                    urlparms = this.urlparms;\n                }\n                // collect functions to pass down to nested components\n                let actionFunctions = {\n                    // curried\n                    addCellDeclarations: this.addCellDeclarations(budgetBranch.uid),\n                    normalizeCellYearDependencies: this.normalizeCellYearDependencies(budgetBranch.uid),\n                    updateCellTimeScope: this.updateCellTimeScope(budgetBranch.uid),\n                    updateCellChartSelection: this.updateCellChartSelection(budgetBranch.uid),\n                    updateCellYearSelections: this.updateCellYearSelections(budgetBranch.uid),\n                    changeTab: this.changeTab(budgetBranch.uid),\n                    updateCellChartCode: this.updateCellChartCode(budgetBranch.uid),\n                    updateNode: this.updateNode(budgetBranch.uid),\n                    // pass-through\n                    addNodeDeclaration: this.props.addNodeDeclaration,\n                    addNodeDeclarations: this.props.addNodeDeclarations,\n                    removeNodeDeclarations: this.props.removeNodeDeclarations,\n                    changeViewpoint: this.props.changeViewpoint,\n                    updateBranch: this.props.updateBranch,\n                    changeVersion: this.props.changeVersion,\n                    toggleInflationAdjusted: this.props.toggleInflationAdjusted,\n                    updateProrata: this.props.updateProrata,\n                    changeAspect: this.props.changeAspect,\n                    incrementBranchDataVersion: this.props.incrementBranchDataVersion,\n                    clearBranchStory: this.props.clearBranchStory,\n                    toggleShowOptions: this.props.toggleShowOptions,\n                    updateCellsDataseriesName: this.props.updateCellsDataseriesName,\n                    resetLastAction: this.props.resetLastAction,\n                    harmonizeCells: this.props.harmonizeCells\n                };\n                // ----------------[ Contains ExplorerBranch ]-------------------------\n                // console.log(\'explorer branchindex and stories\',branchIndex,this.stories)\n                return react["createElement"](Card["Card"], { initiallyExpanded: true, key: budgetBranch.uid, onExpandChange: expanded => {\n                        this.onExpandChange(expanded);\n                    } }, budgetBranches.length > 1 ? react["createElement"](Card["CardTitle"], { actAsExpander: false, showExpandableButton: false }, "Row " + (branchIndex + 1) + " ", react["createElement"]("input", { defaultValue: this.stories ? this.stories[branchIndex].title : \'\', type: "text", style: { width: \'350px\', fontWeight: \'bold\', fontSize: \'14px\' }, onClick: ev => {\n                        ev.stopPropagation();\n                    } }), react["createElement"](IconButton_default.a, { style: {\n                        float: "right",\n                        marginRight: "30px"\n                    }, disabled: branchIndex == budgetBranches.length - 1, onClick: (uid => ev => {\n                        ev.stopPropagation();\n                        this.branchMoveDown(uid);\n                    })(budgetBranch.uid), tooltip: "Move down" }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "arrow_downward")), react["createElement"](IconButton_default.a, { style: {\n                        float: "right"\n                    }, disabled: branchIndex == 0, onClick: (uid => ev => {\n                        ev.stopPropagation();\n                        this.branchMoveUp(uid);\n                    })(budgetBranch.uid), tooltip: "Move up" }, react["createElement"](FontIcon_default.a, { className: "material-icons", style: { cursor: "pointer" } }, "arrow_upward"))) : null, react["createElement"](Card["CardText"], { expandable: false }, react["createElement"](ExplorerBranch, { budgetBranch: budgetBranch, declarationData: explorer.props.declarationData, globalStateActions: actionFunctions, urlparms: urlparms, clearUrlParms: this.clearUrlParms, clearStories: this.clearStories, setToast: this.setToast, handleSearchDialogOpen: this.handleSearchDialogOpen, onCallAnalystNotes: this.onCallAnalystNotes, onCallViewTaxonomy: this.onCallViewTaxonomy })), react["createElement"](Card["CardActions"], { expandable: false }, react["createElement"](FloatingActionButton_default.a, { onClick: (uid => () => {\n                        this.addBranch(uid);\n                    })(budgetBranch.uid) }, react["createElement"](add_default.a, null)), budgetBranches.length > 1 ? react["createElement"](FloatingActionButton_default.a, { onClick: (uid => () => {\n                        this.removeBranch(uid);\n                    })(budgetBranch.uid), secondary: true }, react["createElement"](remove_default.a, null)) : null));\n            });\n            return segments;\n        };\n        // -----------[ COMBINE SEGMENTS ]---------------\n        let branches = branchSegments();\n        return react["createElement"]("div", null, react["createElement"]("div", { style: {\n                backgroundColor: "lemonchiffon",\n                padding: "3px",\n                margin: "3px",\n                borderRadius: "8px",\n                fontFamily: "Roboto,sans-serif",\n                fontSize: "12px"\n            } }, "PLEASE READ NOTICES BELOW. Caution: This is an early version of the Budgetpedia Explorer. The data presented in these charts should be treated as approximations. There are numerous data source quality and continuity issues, the intake process has not been validated, and the data presented has not been rigorously verified against source data."), react["createElement"]("div", { style: { backgroundColor: "white" } }, react["createElement"](Card["CardText"], null, "Taking a tour?", react["createElement"]("button", { type: "button", style: { verticalAlign: "middle", borderRadius: "6px" } }, react["createElement"](react_router_dom_es["a" /* Link */], { to: \'/context\' }, "next page", react["createElement"]("span", { style: { verticalAlign: \'middle\' }, className: "material-icons" }, "navigate_next"))), react["createElement"]("button", { type: "button", style: { verticalAlign: "middle", borderRadius: "6px" } }, react["createElement"](react_router_dom_es["a" /* Link */], { to: \'/tracker\' }, react["createElement"]("span", { style: { verticalAlign: \'middle\' }, className: "material-icons" }, "navigate_before"), "previous page")), react["createElement"]("button", { type: "button", style: { verticalAlign: "middle", borderRadius: "6px" } }, react["createElement"](react_router_dom_es["a" /* Link */], { to: \'/basics\' }, react["createElement"]("span", { style: { verticalAlign: \'middle\' }, className: "material-icons" }, "first_page"), "start")))), react["createElement"](Card["Card"], null, react["createElement"](Card["CardTitle"], { actAsExpander: true, showExpandableButton: true }, "Budget Explorer"), react["createElement"](Card["CardText"], { expandable: true }, react["createElement"]("div", { style: { display: \'inline-block\', verticalAlign: \'top\' } }, react["createElement"]("div", null, react["createElement"]("span", { style: { lineHeight: \'48px\', verticalAlign: \'23px\' } }, "Explore charts below, or select an area of interest: "), react["createElement"](DropDownMenu_default.a, { style: { verticalAlign: \'top\' }, value: this.state.selectStoryboard, onChange: (event, index, value) => {\n                this.onSelectStoryboard(value);\n            } }, react["createElement"](MenuItem_default.a, { value: \'SELECT\', primaryText: "Select" }), react["createElement"](MenuItem_default.a, { value: \'SHARED\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "General Services") }), react["createElement"](MenuItem_default.a, { value: "WASTE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Solid Waste Management") }), react["createElement"](MenuItem_default.a, { value: "WATER", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Toronto Water") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "TTC", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "TTC") }), react["createElement"](MenuItem_default.a, { value: "WHEELTRANS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Wheel Trans") }), react["createElement"](MenuItem_default.a, { value: "TRANSPORTATION", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Transportation (Roads)") }), react["createElement"](MenuItem_default.a, { value: "PARKING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Parking") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "PFRACTIVITIES", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Parks, Forestry & Activity Centres") }), react["createElement"](MenuItem_default.a, { value: "LIBRARY", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Toronto Public Library") }), react["createElement"](MenuItem_default.a, { value: "ATTRACTIONS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Public Attractions") }), react["createElement"](MenuItem_default.a, { value: "CONSERVHERITAGE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Conservation & Heritage") }), react["createElement"](MenuItem_default.a, { value: \'SUPPORT\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "Citizen Support Services") }), react["createElement"](MenuItem_default.a, { value: "FIRE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Fire") }), react["createElement"](MenuItem_default.a, { value: "PARAMEDICS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Paramedics") }), react["createElement"](MenuItem_default.a, { value: "POLICE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Policing & Court Services") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "EMPLOYMENT", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Income Support Services") }), react["createElement"](MenuItem_default.a, { value: "HOUSING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Housing Support Services") }), react["createElement"](MenuItem_default.a, { value: "CHILDREN", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Children\'s Services") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "HEALTH", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Public Health") }), react["createElement"](MenuItem_default.a, { value: "LONGTERMCARE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Long Term Care") }), react["createElement"](MenuItem_default.a, { value: \'ADMINISTRATIVE\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "Administrative Services") }), react["createElement"](MenuItem_default.a, { value: "COUNCIL", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Corporate Management") }), react["createElement"](MenuItem_default.a, { value: "PLANNING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Planning & Development") }), react["createElement"](MenuItem_default.a, { value: "PERMITS", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Permits, Licencing & Standards") }), react["createElement"](Divider_default.a, { inset: true }), react["createElement"](MenuItem_default.a, { value: "INTERNAL", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Internal Services") }), react["createElement"](MenuItem_default.a, { value: "CORPORATE", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Corporate Accounts (Finance)") }), react["createElement"](MenuItem_default.a, { disabled: true, value: \'SPECIAL\', primaryText: react["createElement"]("div", { style: { fontWeight: \'bold\' } }, "Special Analytics") }), react["createElement"](MenuItem_default.a, { value: "STAFFING", primaryText: react["createElement"]("div", { style: { paddingLeft: "20px" } }, "Staffing costs") })), react["createElement"](RaisedButton_default.a, { disabled: this.state.selectStoryboard == \'SELECT\', type: "button", style: { margin: \'3px 6px 0 0\', verticalAlign: \'23px\' }, label: "Share", onClick: this.shareStoryboard, labelPosition: "before", icon: react["createElement"](FontIcon_default.a, { style: { color: \'rgba(0,0,0,0.5)\' }, className: "material-icons" }, "share") }), react["createElement"](RaisedButton_default.a, { style: { verticalAlign: \'25px\' }, type: "button", label: "Reset", onClick: () => {\n                this.resetBranches();\n            } })), react["createElement"]("div", null, "For some background see ", showhelp, " or ", showvideos, " or ", showanalystnotes)), react["createElement"]("div", null))), dialogbox, this.storyboardDialog(), this.analystNotesDialog(), this.viewTaxonomyDialog(), this.state.searchDialogOpen ? react["createElement"](SearchDialog, { onRequestClose: this.handleSearchDialogClose, onConfirm: this.findParameters.applySearchBranchSettings }) : null, branches);\n    }\n};\n// ====================================================================================\n// ------------------------------[ INJECT DATA STORE ]---------------------------------\nlet mapStateToProps = state => {\n    return {\n        declarationData: Object(reducers["b" /* getExplorerDeclarationData */])(state)\n    };\n};\n// initialize all these call backs with dispatch\nExplorer = Object(es["connect"])(mapStateToProps, {\n    // presentation\n    onetimeNotification: actions["s" /* onetimeNotification */],\n    // toggleShowControls\n    // branch actions - components\n    addBranchDeclaration: actions["a" /* addBranchDeclaration */],\n    cloneBranchDeclaration: actions["n" /* cloneBranchDeclaration */],\n    removeBranchDeclaration: actions["t" /* removeBranchDeclaration */],\n    removeBranches: actions["u" /* removeBranches */],\n    addNodeDeclaration: actions["c" /* addNodeDeclaration */],\n    addNodeDeclarations: actions["d" /* addNodeDeclarations */],\n    removeNodeDeclarations: actions["v" /* removeNodeDeclarations */],\n    addCellDeclarations: actions["b" /* addCellDeclarations */],\n    normalizeCellYearDependencies: actions["r" /* normalizeCellYearDependencies */],\n    harmonizeCells: actions["o" /* harmonizeCells */],\n    // removeCellDeclarations:ExplorerActions.removeCellDeclarations,\n    // branch actions - variations\n    changeViewpoint: actions["l" /* changeViewpoint */],\n    updateBranch: actions["A" /* updateBranch */],\n    changeVersion: actions["k" /* changeVersion */],\n    changeAspect: actions["i" /* changeAspect */],\n    toggleInflationAdjusted: actions["x" /* toggleInflationAdjusted */],\n    updateProrata: actions["G" /* updateProrata */],\n    incrementBranchDataVersion: actions["p" /* incrementBranchDataVersion */],\n    clearBranchStory: actions["m" /* clearBranchStory */],\n    toggleShowOptions: actions["y" /* toggleShowOptions */],\n    resetLastAction: actions["w" /* resetLastAction */],\n    // toggleInflationAdjustment\n    branchMoveUp: actions["f" /* branchMoveUp */],\n    branchMoveDown: actions["e" /* branchMoveDown */],\n    // node actions\n    changeTab: actions["j" /* changeTab */],\n    // cell actions\n    updateCellTimeScope: actions["D" /* updateCellTimeScope */],\n    updateCellChartSelection: actions["C" /* updateCellChartSelection */],\n    updateCellYearSelections: actions["E" /* updateCellYearSelections */],\n    // updateCellsDataseriesName: ExplorerActions.updateCellsDataseriesName,\n    updateCellChartCode: actions["B" /* updateCellChartCode */],\n    updateNode: actions["F" /* updateNode */]\n})(Explorer);\n/* harmony default export */ var explorer_explorer = __webpack_exports__["default"] = (Explorer);\n\n//# sourceURL=webpack:///./ts/addons/explorer/explorer.tsx_+_1_modules?')}}]);